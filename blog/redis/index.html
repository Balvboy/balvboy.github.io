<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis为何使用单线程 | ZhouYang's Blog</title><meta name=keywords content="redis"><meta name=description content="Redis为何使用单线程"><meta name=author content="zhouyang"><link rel=canonical href=https://balvboy.github.io/blog/redis/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.3f6a79d84dce1064322991082a04723d5157c86c73768c45927919cf00b4462f.css integrity="sha256-P2p52E3OEGQyKZEIKgRyPVFXyGxzdoxFknkZzwC0Ri8=" rel="preload stylesheet" as=style><link rel=icon href=https://balvboy.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://balvboy.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://balvboy.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://balvboy.github.io/img/favicon.ico><link rel=mask-icon href=https://balvboy.github.io/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-146899866-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Redis为何使用单线程 "><meta property="og:description" content="Redis为何使用单线程"><meta property="og:type" content="article"><meta property="og:url" content="https://balvboy.github.io/blog/redis/"><meta property="og:image" content="https://balvboy.github.io/img/z.jpg"><meta property="article:published_time" content="2021-03-19T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-19T00:00:00+00:00"><meta property="og:site_name" content="Life is Fantastic"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://balvboy.github.io/img/z.jpg"><meta name=twitter:title content="Redis为何使用单线程 "><meta name=twitter:description content="Redis为何使用单线程"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis为何使用单线程 ","name":"Redis为何使用单线程 ","description":"Redis的线程 从接触到Redis开始，就了解到Redis的一个重要特性就是单线程。 带着这个特性，我通过命令top -H -p 2582查看了Redis Server内部开启的线程，发现Redis中并非只有1个线程，而是有4个。 这里面肯定有一主线程是负责Redis的操作的，那剩下的3个线程是负责什么的呢。\n我们在Redis …","keywords":["redis"],"articleBody":" Redis的线程 从接触到Redis开始，就了解到Redis的一个重要特性就是单线程。 带着这个特性，我通过命令top -H -p 2582查看了Redis Server内部开启的线程，发现Redis中并非只有1个线程，而是有4个。 这里面肯定有一主线程是负责Redis的操作的，那剩下的3个线程是负责什么的呢。\n我们在Redis的源码中寻找一下答案\nRedis源码分析 1.main方法 server.supervised = redisIsSupervised(server.supervised_mode); int background = server.daemonize \u0026\u0026 !server.supervised; //判断Redis的启动模式 if (background) daemonize(); initServer(); //初始化server服务 if (background || server.pidfile) createPidFile(); redisSetProcTitle(argv[0]); redisAsciiArt(); checkTcpBacklogSettings(); 2.initServer函数 if (server.cluster_enabled) clusterInit(); replicationScriptCacheInit(); scriptingInit(1); slowlogInit(); latencyMonitorInit(); //初始化 background io bioInit(); server.initial_memory_usage = zmalloc_used_memory(); 这里我们主要关注bioInit();方法，bio这里就是background IO的简写\n3.BIO  /* Background I/O service for Redis. * * This file implements operations that we need to perform in the background. * Currently there is only a single operation, that is a background close(2) * system call. This is needed as when the process is the last owner of a * reference to a file closing it means unlinking it, and the deletion of the * file is slow, blocking the server. * * In the future we'll either continue implementing new things we need or * we'll switch to libeio. However there are probably long term uses for this * file as we may want to put here Redis specific background tasks (for instance * it is not impossible that we'll need a non blocking FLUSHDB/FLUSHALL * implementation). 从上面的描述可以看出BIO目前只包括一个操作，就是后台 close内核函数操作，因为这个操作牵扯到很重的文件IO，文件IO会严重阻塞redis-server，所以需要开辟线程来单独处理这些操作。\nvoid bioInit(void) { pthread_attr_t attr; pthread_t thread; size_t stacksize; int j; /* Initialization of state vars and objects */ for (j = 0; j  BIO_NUM_OPS; j++) { pthread_mutex_init(\u0026bio_mutex[j],NULL); pthread_cond_init(\u0026bio_newjob_cond[j],NULL); pthread_cond_init(\u0026bio_step_cond[j],NULL); bio_jobs[j] = listCreate(); bio_pending[j] = 0; } /* Set the stack size as by default it may be small in some system */ pthread_attr_init(\u0026attr); pthread_attr_getstacksize(\u0026attr,\u0026stacksize); if (!stacksize) stacksize = 1; /* The world is full of Solaris Fixes */ while (stacksize  REDIS_THREAD_STACK_SIZE) stacksize *= 2; pthread_attr_setstacksize(\u0026attr, stacksize); /* Ready to spawn our threads. We use the single argument the thread * function accepts in order to pass the job ID the thread is * responsible of. */ for (j = 0; j  BIO_NUM_OPS; j++) { //循环创建bio线程  void *arg = (void*)(unsigned long) j; if (pthread_create(\u0026thread,\u0026attr,bioProcessBackgroundJobs,arg) != 0) { serverLog(LL_WARNING,\"Fatal: Can't initialize Background Jobs.\"); exit(1); } bio_threads[j] = thread; } } 这个函数，从名字就可以看出它的主要功能是完成BIO的初始化操作，在源代码中我们找到了线程开辟操作，这里的思路是线程池，那么问题来了，BIO线程池中到底开辟几个线程呢？\n通过观察第121行，可以看到BIO_NUM_OPS参数影响了BIO线程池的线程量，那么这个数值到底为多少呢，我们稍微跟踪一下就可以获取：\n42 #define BIO_NUM_OPS 3 //bio.h文件 现在可以看出BIO_NUM_OPS默认数值为3，这个数值加上1个主线程，正好是图片中的4个线程。\n4. BIO线程执行的操作 while(1) { listNode *ln; /* The loop always starts with the lock hold. */ if (listLength(bio_jobs[type]) == 0) { pthread_cond_wait(\u0026bio_newjob_cond[type],\u0026bio_mutex[type]); continue; } /* Pop the job from the queue. */ ln = listFirst(bio_jobs[type]); //从任务队列中获取任务  job = ln-value; /* It is now possible to unlock the background system as we know have * a stand alone job structure to process.*/ pthread_mutex_unlock(\u0026bio_mutex[type]); /* Process the job accordingly to its type. */ if (type == BIO_CLOSE_FILE) { //文件关闭操作  close((long)job-arg1); } else if (type == BIO_AOF_FSYNC) { //异步文件同步操作  redis_fsync((long)job-arg1); } else if (type == BIO_LAZY_FREE) { //redis内存懒释放  /* What we free changes depending on what arguments are set: * arg1 - free the object at pointer. * arg2 \u0026 arg3 - free two dictionaries (a Redis DB). * only arg3 - free the skiplist. */ if (job-arg1) lazyfreeFreeObjectFromBioThread(job-arg1); //懒释放对象  else if (job-arg2 \u0026\u0026 job-arg3) lazyfreeFreeDatabaseFromBioThread(job-arg2,job-arg3);//懒释数据库  else if (job-arg3) lazyfreeFreeSlotsMapFromBioThread(job-arg3);//懒释放槽位型Map内存  } else { serverPanic(\"Wrong job type in bioProcessBackgroundJobs().\"); } zfree(job); 通过最初的现象，我们可以看出Redis-server开辟了四个线程，并通过源代码分析，我们可以看出后三个线程是BIO线程，这三个线程完成的功能是一样的，主要包括：从BIO任务队列中取出任务，文件描述符关闭、磁盘文件同步、内存对象懒释放操作。 其他的任务均由主线程完成。\nRedis单线程的优势 我们看到Redis在处理大多数命令的时候，是通过单线程来处理的这可能给Redis带来下面的优势 1. 使用单线程模型也能并发的处理客户端的请求； 2. 使用单线程模型能带来更好的可维护性，方便开发和调试； 3. Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；\n单线程也能并发 这里首先要说一下一个老生常谈的问题，并发和并行的区别。 这里用一个例子来说明  例如，一个调酒师能够照顾几个顾客，而一次只能准备一种饮料。因此，他可以在没有并行的情况下提供并发。\n所以说并发是，在一个时间段内能够处理多个请求即可，而并行是在同一个时刻能够处理多个请求。\n而Redis就可以理解为，上面的例子中提到的调酒师，Redis通过IO 多路复用技术就能够方便的实现同时照看成百上千个顾客,但是Redis在同一时刻只能处理一个顾客的请求。\n但是因为Redis几乎所有操作都是在内存中完成，所以他的每个操作的耗时都非常短，这里有一个计算机各个硬件执行时间的对比。 我们看到内存的读取访问时间是在纳秒级别，而到了硬盘就到了毫秒级。所以Redis这样的以内存操作为主的服务，能够达到每秒 10W甚至100W的并发都是有可能的(当然这个和很多情况有关，比如key的大小，命令的时间复杂度等等)。 同样在这种主要针对内存操作的情况下，Redis对于CPU的消耗是相对比较小的。所以CPU通常并不会成为Redis的瓶颈。  It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.  FAQ\n如果说你想更好的让Redis利用CPU，或者说Redis的并发量还不能满足你的要求，Redis给出的官方建议是，使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。  However, to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. At some point a single box may not be enough anyway, so if you want to use multiple CPUs you can start thinking of some way to shard earlier.  FAQ\n可维护性 可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。\n性能瓶颈 上面也提到了，CPU一般不会成为Redis的瓶颈，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。\n AOF 是 Redis 的一种持久化机制，它会在每次收到来自客户端的写请求时，将其记录到日志中，每次 Redis 服务器启动时都会重放 AOF 日志构建原始的数据集，保证数据的持久性。\n 多线程虽然会帮助我们更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销，其中包括：\n 保存线程 1 的执行上下文； 加载线程 2 的执行上下文；  频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。\n引入多线程  However with Redis 4.0 we started to make Redis more threaded. For now this is limited to deleting objects in the background, and to blocking commands implemented via Redis modules. For the next releases, the plan is to make Redis more and more threaded.\n 从4.0版本开始，Redis加入了一些可以被其他线程异步处理的删除操作。\n删除操作 我们可以在 Redis 在中使用 DEL 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是同步地删除这些键值对也不会消耗太多的时间。\n但是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。\n总结 Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；（因为单线程的Redis已经这么快了，而且瓶颈不在CPU，并且开发起来更简单，所以顺理成章的使用了单线程） 而 Redis 引入多线程操作也是出于性能上的考虑(目前只是针对一些大键的删除)，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。\n参考 [Redis-Server 线程模型源码剖析]\n[为什么Redis使用单线程模型]\n[Redis is single-threaded, then how does it do concurrent I/O?]\n[为什么说Redis是单线程的以及Redis为什么这么快！]\n","wordCount":"760","inLanguage":"en","datePublished":"2021-03-19T00:00:00Z","dateModified":"2021-03-19T00:00:00Z","author":{"@type":"Person","name":"zhouyang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://balvboy.github.io/blog/redis/"},"publisher":{"@type":"Organization","name":"ZhouYang's Blog","logo":{"@type":"ImageObject","url":"https://balvboy.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://balvboy.github.io accesskey=h title="Home (Alt + H)"><img src=/img/zhouyang.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://balvboy.github.io/blog/ title=blogs><span>blogs</span></a></li><li><a href=https://balvboy.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://balvboy.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://balvboy.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?a3d79563dfbd078b66e86495caf11120",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script><script src=/js/mermaid.js></script></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Redis为何使用单线程</h1><div class=post-description>Redis为何使用单线程</div><div class=post-meta>March 19, 2021&nbsp;·&nbsp;4 min&nbsp;·&nbsp;zhouyang</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#redis%e7%9a%84%e7%ba%bf%e7%a8%8b aria-label=Redis的线程>Redis的线程</a></li><li><a href=#redis%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 aria-label=Redis源码分析>Redis源码分析</a><ul><li><a href=#1-main%e6%96%b9%e6%b3%95 aria-label=1.main方法>1.main方法</a></li><li><a href=#2-initserver%e5%87%bd%e6%95%b0 aria-label=2.initServer函数>2.initServer函数</a></li><li><a href=#3-bio aria-label=3.BIO>3.BIO</a></li><li><a href=#4-bio%e7%ba%bf%e7%a8%8b%e6%89%a7%e8%a1%8c%e7%9a%84%e6%93%8d%e4%bd%9c aria-label="4. BIO线程执行的操作">4. BIO线程执行的操作</a></li></ul></li><li><a href=#redis%e5%8d%95%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%bc%98%e5%8a%bf aria-label=Redis单线程的优势>Redis单线程的优势</a><ul><li><a href=#%e5%8d%95%e7%ba%bf%e7%a8%8b%e4%b9%9f%e8%83%bd%e5%b9%b6%e5%8f%91 aria-label=单线程也能并发>单线程也能并发</a></li><li><a href=#%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7 aria-label=可维护性>可维护性</a></li><li><a href=#%e6%80%a7%e8%83%bd%e7%93%b6%e9%a2%88 aria-label=性能瓶颈>性能瓶颈</a></li></ul></li><li><a href=#%e5%bc%95%e5%85%a5%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=引入多线程>引入多线程</a><ul><li><a href=#%e5%88%a0%e9%99%a4%e6%93%8d%e4%bd%9c aria-label=删除操作>删除操作</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><h1 id=redis的线程>Redis的线程<a hidden class=anchor aria-hidden=true href=#redis的线程>#</a></h1><p>从接触到Redis开始，就了解到Redis的一个重要特性就是单线程。
带着这个特性，我通过命令<code>top -H -p 2582</code>查看了Redis Server内部开启的线程，发现Redis中并非只有1个线程，而是有4个。
<img src=/img/15785618967309.jpg alt>
这里面肯定有一主线程是负责Redis的操作的，那剩下的3个线程是负责什么的呢。</p><p>我们在Redis的源码中寻找一下答案</p><h1 id=redis源码分析>Redis源码分析<a hidden class=anchor aria-hidden=true href=#redis源码分析>#</a></h1><h2 id=1-main方法>1.main方法<a hidden class=anchor aria-hidden=true href=#1-main方法>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>server.supervised <span style=color:#f92672>=</span> redisIsSupervised(server.supervised_mode);
<span style=color:#66d9ef>int</span> background <span style=color:#f92672>=</span> server.daemonize <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>server.supervised;
<span style=color:#75715e>//判断Redis的启动模式
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (background) daemonize();
  
initServer(); <span style=color:#75715e>//初始化server服务
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (background <span style=color:#f92672>||</span> server.pidfile) createPidFile();
redisSetProcTitle(argv[<span style=color:#ae81ff>0</span>]);
redisAsciiArt();
checkTcpBacklogSettings();</code></pre></div><h2 id=2-initserver函数>2.initServer函数<a hidden class=anchor aria-hidden=true href=#2-initserver函数>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>if</span> (server.cluster_enabled) clusterInit();
replicationScriptCacheInit();
scriptingInit(<span style=color:#ae81ff>1</span>);
slowlogInit();
latencyMonitorInit();
<span style=color:#75715e>//初始化 background io
</span><span style=color:#75715e></span>bioInit();
server.initial_memory_usage <span style=color:#f92672>=</span> zmalloc_used_memory();</code></pre></div><p>这里我们主要关注<code>bioInit();</code>方法，<code>bio</code>这里就是background IO的简写</p><h2 id=3-bio>3.BIO<a hidden class=anchor aria-hidden=true href=#3-bio>#</a></h2><pre><code> /* Background I/O service for Redis.
   *
   * This file implements operations that we need to perform in the background.
   * Currently there is only a single operation, that is a background close(2)
   * system call. This is needed as when the process is the last owner of a
   * reference to a file closing it means unlinking it, and the deletion of the
   * file is slow, blocking the server.
   *
   * In the future we&#39;ll either continue implementing new things we need or
   * we&#39;ll switch to libeio. However there are probably long term uses for this
   * file as we may want to put here Redis specific background tasks (for instance
   * it is not impossible that we&#39;ll need a non blocking FLUSHDB/FLUSHALL
   * implementation).</code></pre><p>从上面的描述可以看出BIO目前只包括一个操作，就是后台 close内核函数操作，因为这个操作牵扯到很重的文件IO，文件IO会严重阻塞redis-server，所以需要开辟线程来单独处理这些操作。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bioInit</span>(<span style=color:#66d9ef>void</span>) {
      pthread_attr_t attr;
      pthread_t <span style=color:#66d9ef>thread</span>;
      size_t stacksize;
      <span style=color:#66d9ef>int</span> j;
  
      <span style=color:#75715e>/* Initialization of state vars and objects */</span>
      <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> BIO_NUM_OPS; j<span style=color:#f92672>++</span>) {
          pthread_mutex_init(<span style=color:#f92672>&amp;</span>bio_mutex[j],NULL);
          pthread_cond_init(<span style=color:#f92672>&amp;</span>bio_newjob_cond[j],NULL);
          pthread_cond_init(<span style=color:#f92672>&amp;</span>bio_step_cond[j],NULL);
          bio_jobs[j] <span style=color:#f92672>=</span> listCreate();
          bio_pending[j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      }
  
      <span style=color:#75715e>/* Set the stack size as by default it may be small in some system */</span>
      pthread_attr_init(<span style=color:#f92672>&amp;</span>attr);
      pthread_attr_getstacksize(<span style=color:#f92672>&amp;</span>attr,<span style=color:#f92672>&amp;</span>stacksize);
      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>stacksize) stacksize <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/* The world is full of Solaris Fixes */</span>
      <span style=color:#66d9ef>while</span> (stacksize <span style=color:#f92672>&lt;</span> REDIS_THREAD_STACK_SIZE) stacksize <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>;
      pthread_attr_setstacksize(<span style=color:#f92672>&amp;</span>attr, stacksize);
  
      <span style=color:#75715e>/* Ready to spawn our threads. We use the single argument the thread
</span><span style=color:#75715e>       * function accepts in order to pass the job ID the thread is
</span><span style=color:#75715e>       * responsible of. */</span>
      <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> BIO_NUM_OPS; j<span style=color:#f92672>++</span>) { <span style=color:#75715e>//循环创建bio线程
</span><span style=color:#75715e></span>          <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>arg <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>) j;
          <span style=color:#66d9ef>if</span> (pthread_create(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>thread</span>,<span style=color:#f92672>&amp;</span>attr,bioProcessBackgroundJobs,arg) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
              serverLog(LL_WARNING,<span style=color:#e6db74>&#34;Fatal: Can&#39;t initialize Background Jobs.&#34;</span>);
              exit(<span style=color:#ae81ff>1</span>);
          }
          bio_threads[j] <span style=color:#f92672>=</span> <span style=color:#66d9ef>thread</span>;
      }
 }</code></pre></div><p>这个函数，从名字就可以看出它的主要功能是完成BIO的初始化操作，在源代码中我们找到了线程开辟操作，这里的思路是线程池，那么问题来了，BIO线程池中到底开辟几个线程呢？</p><p>通过观察第121行，可以看到BIO_NUM_OPS参数影响了BIO线程池的线程量，那么这个数值到底为多少呢，我们稍微跟踪一下就可以获取：</p><pre><code>42  #define BIO_NUM_OPS       3   //bio.h文件</code></pre><p>现在可以看出BIO_NUM_OPS默认数值为3，这个数值加上1个主线程，正好是图片中的4个线程。</p><h2 id=4-bio线程执行的操作>4. BIO线程执行的操作<a hidden class=anchor aria-hidden=true href=#4-bio线程执行的操作>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>      <span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>) {
          listNode <span style=color:#f92672>*</span>ln;
  
          <span style=color:#75715e>/* The loop always starts with the lock hold. */</span>
          <span style=color:#66d9ef>if</span> (listLength(bio_jobs[type]) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
              pthread_cond_wait(<span style=color:#f92672>&amp;</span>bio_newjob_cond[type],<span style=color:#f92672>&amp;</span>bio_mutex[type]);
              <span style=color:#66d9ef>continue</span>;
          }
          <span style=color:#75715e>/* Pop the job from the queue. */</span>
          ln <span style=color:#f92672>=</span> listFirst(bio_jobs[type]); <span style=color:#75715e>//从任务队列中获取任务
</span><span style=color:#75715e></span>          job <span style=color:#f92672>=</span> ln<span style=color:#f92672>-&gt;</span>value;
          <span style=color:#75715e>/* It is now possible to unlock the background system as we know have
</span><span style=color:#75715e>           * a stand alone job structure to process.*/</span>
          pthread_mutex_unlock(<span style=color:#f92672>&amp;</span>bio_mutex[type]);
  
          <span style=color:#75715e>/* Process the job accordingly to its type. */</span>
          <span style=color:#66d9ef>if</span> (type <span style=color:#f92672>==</span> BIO_CLOSE_FILE) { <span style=color:#75715e>//文件关闭操作
</span><span style=color:#75715e></span>              close((<span style=color:#66d9ef>long</span>)job<span style=color:#f92672>-&gt;</span>arg1);
          } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (type <span style=color:#f92672>==</span> BIO_AOF_FSYNC) { <span style=color:#75715e>//异步文件同步操作
</span><span style=color:#75715e></span>              redis_fsync((<span style=color:#66d9ef>long</span>)job<span style=color:#f92672>-&gt;</span>arg1);
          } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (type <span style=color:#f92672>==</span> BIO_LAZY_FREE) { <span style=color:#75715e>//redis内存懒释放
</span><span style=color:#75715e></span>              <span style=color:#75715e>/* What we free changes depending on what arguments are set:
</span><span style=color:#75715e>               * arg1 -&gt; free the object at pointer.
</span><span style=color:#75715e>               * arg2 &amp; arg3 -&gt; free two dictionaries (a Redis DB).
</span><span style=color:#75715e>               * only arg3 -&gt; free the skiplist. */</span>
              <span style=color:#66d9ef>if</span> (job<span style=color:#f92672>-&gt;</span>arg1)
                  lazyfreeFreeObjectFromBioThread(job<span style=color:#f92672>-&gt;</span>arg1); <span style=color:#75715e>//懒释放对象
</span><span style=color:#75715e></span>              <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (job<span style=color:#f92672>-&gt;</span>arg2 <span style=color:#f92672>&amp;&amp;</span> job<span style=color:#f92672>-&gt;</span>arg3)
                  lazyfreeFreeDatabaseFromBioThread(job<span style=color:#f92672>-&gt;</span>arg2,job<span style=color:#f92672>-&gt;</span>arg3);<span style=color:#75715e>//懒释数据库
</span><span style=color:#75715e></span>              <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (job<span style=color:#f92672>-&gt;</span>arg3)
                  lazyfreeFreeSlotsMapFromBioThread(job<span style=color:#f92672>-&gt;</span>arg3);<span style=color:#75715e>//懒释放槽位型Map内存
</span><span style=color:#75715e></span>          } <span style=color:#66d9ef>else</span> {
              serverPanic(<span style=color:#e6db74>&#34;Wrong job type in bioProcessBackgroundJobs().&#34;</span>);
          }
          zfree(job);</code></pre></div><p>通过最初的现象，我们可以看出Redis-server开辟了四个线程，并通过源代码分析，我们可以看出后三个线程是BIO线程，这三个线程完成的功能是一样的，主要包括：从BIO任务队列中取出任务，文件描述符关闭、磁盘文件同步、内存对象懒释放操作。
其他的任务均由主线程完成。</p><h1 id=redis单线程的优势>Redis单线程的优势<a hidden class=anchor aria-hidden=true href=#redis单线程的优势>#</a></h1><p>我们看到Redis在处理大多数命令的时候，是通过单线程来处理的这可能给Redis带来下面的优势
1. 使用单线程模型也能并发的处理客户端的请求；
2. 使用单线程模型能带来更好的可维护性，方便开发和调试；
3. Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；</p><h2 id=单线程也能并发>单线程也能并发<a hidden class=anchor aria-hidden=true href=#单线程也能并发>#</a></h2><p>这里首先要说一下一个老生常谈的问题，并发和并行的区别。
这里用一个例子来说明
> 例如，一个调酒师能够照顾几个顾客，而一次只能准备一种饮料。因此，他可以在没有并行的情况下提供并发。</p><p><code>所以说并发是，在一个时间段内能够处理多个请求即可，而并行是在同一个时刻能够处理多个请求。</code></p><p>而Redis就可以理解为，上面的例子中提到的调酒师，Redis通过<code>IO 多路复用技术</code>就能够方便的实现同时照看成百上千个<code>顾客</code>,但是Redis在同一时刻只能处理一个<code>顾客</code>的请求。</p><p>但是因为Redis几乎所有操作都是在内存中完成，所以他的每个操作的耗时都非常短，这里有一个计算机各个硬件执行时间的对比。
<img src=media/15786476237474.jpg alt></p><p>我们看到内存的读取访问时间是在纳秒级别，而到了硬盘就到了毫秒级。所以Redis这样的以内存操作为主的服务，能够达到每秒 10W甚至100W的并发都是有可能的(当然这个和很多情况有关，比如key的大小，命令的时间复杂度等等)。
同样在这种主要针对内存操作的情况下，Redis对于CPU的消耗是相对比较小的。所以CPU通常并不会成为Redis的瓶颈。
> It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.
> <a href=https://redis.io/topics/faq>FAQ</a></p><p>如果说你想更好的让Redis利用CPU，或者说Redis的并发量还不能满足你的要求，Redis给出的官方建议是，使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。
> However, to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. At some point a single box may not be enough anyway, so if you want to use multiple CPUs you can start thinking of some way to shard earlier.
> <a href=https://redis.io/topics/faq>FAQ</a></p><h2 id=可维护性>可维护性<a hidden class=anchor aria-hidden=true href=#可维护性>#</a></h2><p>可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。</p><h2 id=性能瓶颈>性能瓶颈<a hidden class=anchor aria-hidden=true href=#性能瓶颈>#</a></h2><p>上面也提到了，CPU一般不会成为Redis的瓶颈，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；<code>整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O</code>，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。</p><blockquote><p>AOF 是 Redis 的一种持久化机制，它会在每次收到来自客户端的写请求时，将其记录到日志中，每次 Redis 服务器启动时都会重放 AOF 日志构建原始的数据集，保证数据的持久性。</p></blockquote><p>多线程虽然会帮助我们更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销，其中包括：</p><ol><li>保存线程 1 的执行上下文；</li><li>加载线程 2 的执行上下文；</li></ol><p>频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。</p><h1 id=引入多线程>引入多线程<a hidden class=anchor aria-hidden=true href=#引入多线程>#</a></h1><blockquote><p>However with Redis 4.0 we started to make Redis more threaded. For now this is limited to deleting objects in the background, and to blocking commands implemented via Redis modules. For the next releases, the plan is to make Redis more and more threaded.</p></blockquote><p>从4.0版本开始，Redis加入了一些可以被其他线程异步处理的删除操作。</p><h2 id=删除操作>删除操作<a hidden class=anchor aria-hidden=true href=#删除操作>#</a></h2><p>我们可以在 Redis 在中使用 DEL 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是同步地删除这些键值对也不会消耗太多的时间。</p><p>但是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。</p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；（因为单线程的Redis已经这么快了，而且瓶颈不在CPU，并且开发起来更简单，所以顺理成章的使用了单线程）
而 Redis 引入多线程操作也是出于性能上的考虑(目前只是针对一些大键的删除)，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><p><a href=https://blog.icorer.com/index.php/archives/389/>[Redis-Server 线程模型源码剖析]</a></p><p><a href=https://draveness.me/whys-the-design-redis-single-thread>[为什么Redis使用单线程模型]</a></p><p><a href=https://stackoverflow.com/questions/10489298/redis-is-single-threaded-then-how-does-it-do-concurrent-i-o>[Redis is single-threaded, then how does it do concurrent I/O?]</a></p><p><a href=https://blog.csdn.net/xlgen157387/article/details/79470556>[为什么说Redis是单线程的以及Redis为什么这么快！]</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://balvboy.github.io/tags/redis/>redis</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Redis为何使用单线程  on twitter" href="https://twitter.com/intent/tweet/?text=Redis%e4%b8%ba%e4%bd%95%e4%bd%bf%e7%94%a8%e5%8d%95%e7%ba%bf%e7%a8%8b%20&url=https%3a%2f%2fbalvboy.github.io%2fblog%2fredis%2f&hashtags=redis"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis为何使用单线程  on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbalvboy.github.io%2fblog%2fredis%2f&title=Redis%e4%b8%ba%e4%bd%95%e4%bd%bf%e7%94%a8%e5%8d%95%e7%ba%bf%e7%a8%8b%20&summary=Redis%e4%b8%ba%e4%bd%95%e4%bd%bf%e7%94%a8%e5%8d%95%e7%ba%bf%e7%a8%8b%20&source=https%3a%2f%2fbalvboy.github.io%2fblog%2fredis%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis为何使用单线程  on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbalvboy.github.io%2fblog%2fredis%2f&title=Redis%e4%b8%ba%e4%bd%95%e4%bd%bf%e7%94%a8%e5%8d%95%e7%ba%bf%e7%a8%8b%20"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis为何使用单线程  on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbalvboy.github.io%2fblog%2fredis%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis为何使用单线程  on whatsapp" href="https://api.whatsapp.com/send?text=Redis%e4%b8%ba%e4%bd%95%e4%bd%bf%e7%94%a8%e5%8d%95%e7%ba%bf%e7%a8%8b%20%20-%20https%3a%2f%2fbalvboy.github.io%2fblog%2fredis%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis为何使用单线程  on telegram" href="https://telegram.me/share/url?text=Redis%e4%b8%ba%e4%bd%95%e4%bd%bf%e7%94%a8%e5%8d%95%e7%ba%bf%e7%a8%8b%20&url=https%3a%2f%2fbalvboy.github.io%2fblog%2fredis%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//balvboy.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href=https://balvboy.github.io>ZhouYang's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button>
</a><link rel=stylesheet type=text/css href=/css/table.css><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script><script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>