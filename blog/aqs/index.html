<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java同步机制(六)- AQS | ZhouYang's Blog</title><meta name=keywords content="AQS,ReentranLock"><meta name=description content="AbstractQueuedSynchronizer"><meta name=author content="    &#34;zhouyang&#34;"><link rel=canonical href=https://balvboy.github.io/blog/aqs/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.3f6a79d84dce1064322991082a04723d5157c86c73768c45927919cf00b4462f.css integrity="sha256-P2p52E3OEGQyKZEIKgRyPVFXyGxzdoxFknkZzwC0Ri8=" rel="preload stylesheet" as=style><link rel=icon href=https://balvboy.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://balvboy.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://balvboy.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://balvboy.github.io/img/favicon.ico><link rel=mask-icon href=https://balvboy.github.io/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-146899866-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Java同步机制(六)- AQS"><meta property="og:description" content="AbstractQueuedSynchronizer"><meta property="og:type" content="article"><meta property="og:url" content="https://balvboy.github.io/blog/aqs/"><meta property="og:image" content="https://balvboy.github.io/img/z.png"><meta property="article:published_time" content="2021-06-24T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-24T00:00:00+00:00"><meta property="og:site_name" content="Life is Fantastic"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://balvboy.github.io/img/z.png"><meta name=twitter:title content="Java同步机制(六)- AQS"><meta name=twitter:description content="AbstractQueuedSynchronizer"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java同步机制(六)- AQS","name":"Java同步机制(六)- AQS","description":"终于来到了重头戏-AQS,AQS可以说是整个J.U.C的核心，整个工具包中的大部分同步工具都是借助于AQS来实现的。接下来我们将通过ReentranLock的实现来了解AQS的原理\nAQS结构 同步状态 首先在AQS中维护了一个名叫state的字段，是由volatile修饰的，它就是所谓的同步状态：\nprivate volatile int state; 并 …","keywords":["AQS","ReentranLock"],"articleBody":" 终于来到了重头戏-AQS,AQS可以说是整个J.U.C的核心，整个工具包中的大部分同步工具都是借助于AQS来实现的。接下来我们将通过ReentranLock的实现来了解AQS的原理\nAQS结构 同步状态 首先在AQS中维护了一个名叫state的字段，是由volatile修饰的，它就是所谓的同步状态：\nprivate volatile int state; 并且提供了几个访问这个字段的方法：\n   方法名称 描述     protected final int getState() 获取state的值   protected final void setState(int newState) 设置state的值   protected final boolean compareAndSetState(int expect, int update) 使用CAS方式更新state的值    可以看到这几个方法都是final修饰的，说明子类中无法重写它们。另外它们都是protected修饰的，说明只能在子类中使用这些方法。\n同步队列 AQS使用一个Volatile的int类型的成员变量state来表示同步状态，通过内置的FIFO同步队列来完成资源获取的排队工作。\n有一点值得注意，就是这里的头结点是一个虚节点，它的thread为空，头结点的存在更多意义上是为了编程方便。当然为了方便理解，我们可以认为头结点就是获取了锁的线程的节点，但是thread被清空了\n当线程获取到锁的时候，会把线程所在的节点设置为头结点，设置为头结点后，会把不需要的属性设置为null。\n/** * Sets head of queue to be node, thus dequeuing. Called only by * acquire methods. Also nulls out unused fields for sake of GC * and to suppress unnecessary signals and traversals. * * @param node the node */ private void setHead(Node node) { head = node; node.thread = null; node.prev = null; } AQS中定义一个头节点引用，一个尾节点引用：\nprivate transient volatile Node head; //执行队列的头结点 private transient volatile Node tail; //执行队列的尾节点  上面图中的每个线程，都对应着一个Node节点，Node是AQS中的一个内部类，下面解释一下几个方法和属性值的含义：\n   方法和属性 含义     waitStatus 当前节点在队列中的状态   thread 表示处于该节点的线程   prev 指向前一个节点的指针   next 指向后一个节点的指针   predecessor 返回前一个节点，没有的话抛出npe   nextWaiter 指向下一个处于CONDITION状态的节点(暂不多做介绍)       枚举 含义     0 Node初始化的默认值   CANCELLED 为1，表示节点已经取消获取锁   CONDITION 为-2，表示节点在等待队列中，节点线程等待唤醒   PROPAGATE 为-3，当前线程处在SHARED情况下，该字段才会使用   SIGNAL 为-1，表示该节点的继任者(下一个节点)，已经或者将要被block    这里把java源码中的注释也贴出来，方便大家理解\n/** * Status field, taking on only the values: * SIGNAL: The successor of this node is (or will soon be) * blocked (via park), so the current node must * unpark its successor when it releases or * cancels. To avoid races, acquire methods must * first indicate they need a signal, * then retry the atomic acquire, and then, * on failure, block. * CANCELLED: This node is cancelled due to timeout or interrupt. * Nodes never leave this state. In particular, * a thread with cancelled node never again blocks. * CONDITION: This node is currently on a condition queue. * It will not be used as a sync queue node * until transferred, at which time the status * will be set to 0. (Use of this value here has * nothing to do with the other uses of the * field, but simplifies mechanics.) * PROPAGATE: A releaseShared should be propagated to other * nodes. This is set (for head node only) in * doReleaseShared to ensure propagation * continues, even if other operations have * since intervened. * 0: None of the above * * The values are arranged numerically to simplify use. * Non-negative values mean that a node doesn't need to * signal. So, most code doesn't need to check for particular * values, just for sign. * * The field is initialized to 0 for normal sync nodes, and * CONDITION for condition nodes. It is modified using CAS * (or when possible, unconditional volatile writes). */ volatile int waitStatus; todo 后面我们在补充一下\n独占和共享模式 在一些线程协调的场景中，一个线程在进行某些操作的时候其他的线程都不能执行该操作，比如持有锁时的操作，在同一时刻只能有一个线程持有锁，我们把这种情景称为独占模式； 在另一些线程协调的场景中，可以同时允许多个线程同时进行某种操作，我们把这种情景称为共享模式。 我们可以通过修改AQS中state字段代表的同步状态来实现多线程的独占模式或者共享模式。\n 独占模式 在独占模式下，我们设置state为0，线程要进行独占操作的时候，需要使用CAS操作，把0修改为1，我们把这个过程称为尝试获取同步状态。然后在执行完成后，同样再通过CAS操作修改回来,把这个操作成为释放同步状态。这洋就能保证任何时候，都只能有一个线程独占。\n 共享模式 在共享模式下，我们设置state为能支持共享的最大线程数，比如10。线程在执行共享操作时，每次都判断state是否大于0，如果大于0，通过CAS把state的值减1,我们把这个过程成为尝试获取共享同步状态。然后每个线程再执行完之后，再通过CAS把state的值+1,我们把这个操作成为释放共享同步状态。\n  在后面的代码分析中会详细讲解独占模式和共享模式。\n对于上面提到的获取共享状态和释放共享状态以及尝试获取共享同步状态和释放共享同步状态，AQS中定义了几个方法\n   方法名称 描述     protected boolean tryAcquire(int arg) 独占式的获取同步状态，获取成功返回true，否则false   protected boolean tryRelease(int arg) 独占式的释放同步状态，释放成功返回true，否则false   protected int tryAcquireShared(int arg) 共享式的获取同步状态，获取成功返回true，否则false   protected boolean tryReleaseShared(int arg) 共享式的释放同步状态，释放成功返回true，否则false   protected boolean isHeldExclusively() 在独占模式下，如果当前线程已经获取到同步状态，则返回 true；其他情况则返回 false    这几个方法，AQS都没有实现，而是要求子类去实现。如果我们自定义的同步工具需要在独占模式下工作，那么我们就重写tryAcquire、tryRelease和isHeldExclusively方法。\n在了解了上面这些内容之后，我们通过ReentranLock来详细了解一下AQS的独占模式是如何工作的。\nReentranLock 先来看一下ReentranLock的代码结构：\npublic class ReentrantLock implements Lock, java.io.Serializable { /** Synchronizer providing all implementation mechanics */ private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer{ ... } static final class NonfairSync extends Sync { ... } static final class FairSync extends Sync { ... } public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } public void lock() { sync.lock();} public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } public boolean tryLock() { return sync.nonfairTryAcquire(1); } public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(timeout)); } public void unlock() { sync.release(1); } public Condition newCondition() { return sync.newCondition(); } } 上面我们把ReentranLock的主要结构，罗列出来。、\n 首先定义了一个Sync属性sync 接下来是Sync的内部类，Sync继承自AbstractQueuedSynchronizer 然后是两个Sync的子类，分别是非公平锁和公平锁的实现 接下来是两个构造方法，可以看到，默认是使用的非公平锁 然后就是实现自Lock接口的方法，可以看到方法都是最终调用了sync，也就是我们前面说的，ReentranLock借助于AQS实现了Lock。  我们看到ReentranLock的几个方法中，都是调用的Sync的相关方法，下面我们就来看一下Sync和它的两个子类NonfairSync与FairSync:\nSync内部类 Sync继承自AbstractQueuedSynchronizer,并重写了tryRelease和isHeldExclusively方法。独占模式要求的另一个方法tryAcquire，由他的子类NonfairSync和FairSync分别实现。\n看到这里，我们可以知道什么，那就是非公平锁和公平锁只在获取锁上有区别，在释放锁的上没有任何区别\nabstract static class Sync extends AbstractQueuedSynchronizer { abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */ //注释说到， tryAcquire在子类中实现，但是tryLock是使用nofair的，所以放到了父类中  final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { //如果当前没有线程持有，则直接尝试获取一次，不管后面后又没其他线程再等待  if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } //判断是否为锁重入  else if (current == getExclusiveOwnerThread()) { //记录重入  int nextc = c + acquires; //判断int overflow的情况，所以最大的重入次数为int的最大值  if (nextc  0) // overflow  throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } //尝试释放锁  protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; //如通c == 0，表示所有的锁都释放完了  //则设置持有锁线程为null  //返回释放锁成功  if (c == 0) { free = true; setExclusiveOwnerThread(null); } //如果c != 0 则表示发生了锁重入，只是里层释放了锁  //返回没有完全释放锁  setState(c); return free; } protected final boolean isHeldExclusively() { // While we must in general read state before owner,  // we don't need to do so to check if current thread is owner  return getExclusiveOwnerThread() == Thread.currentThread(); } // 省略掉一些不太重要的方法。。。。 } 下面在看NonfairSync这个子类\n/** * Sync object for non-fair locks */ static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; /** * performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() { //非公平锁上来就先尝试获取一次,就是这里体现了不公平，  if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else //如果没有获取成功,通过acquire方法，加入队列中等待  acquire(1); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } } 在看一下FairSync这个子类\n/** * Sync object for fair locks */ static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; final void lock() { acquire(1); } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ //公平锁的tryAcquire和非公平锁的差别就是，非公平锁会直接尝试一次CAS获取锁  //而公平锁则会先判断一下等待队列是不是为空。  //如果都尝试获取失败，之后的处理逻辑都是一样的  protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { //如果队列为空，或者当前线程已经处于队列的最前，则尝试一次通过CAS获取锁  //否则不获取  if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } //判断重入的逻辑  else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc  0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } //获取锁失败，并且不是重入，则tryAcquire失败  return false; } } 公平锁和非公平锁在获取锁时的区别 我们看到NonfairSync和FairSync都是只有两个方法，tryAcquire和lock方法。其中tryAcquire方法是实现自AQS。 那么公平锁和非公平锁的区别就体现在，这两个类，对着两个方法的实现上。\n我们先看tryAcquire方法的区别。 - NonfairSync是直接调用的父类的nonfairTryAcquire方法，它呢不会管当前有没有其他线程再等待，只要当前没有线程持有，就尝试获取一次 - FairSync是会先判断是否有其他线程再等待，只有没有线程等待或者它本身就是最前面的节点的时候，才会尝试获取。\n我们再看lock方法 - NonfairSync,上来直接使用CAS，尝试获取一次，获取不到则调用AQS的acquire方法，在acquire方法中会调用NonfairSync的tryAcquire，如果仍然失败，加入到等待队列中。 - FairSync,直接调用父类AQS的acquire方法，在acquire方法中会调用FairSync的tryAcquire)，如果失败，加入到等待队列中。\n我们看到公平锁和非公平锁的区别就在，非公平锁不会管现在又没有线程在等待，而是直接尝试获取。\nnonfairTryAcquire方法为何定义在父类 看这个方法名称nonfairTryAcquire,感觉应该写在子类NonfairSync中会比较合适,这里会写到父类中呢？方法的注释中写到\n/** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */ 执行非公平的tryLock。 tryAcquire在子类中实现。但两者都需要非公平的trylock方法。 意思是在调用Lock.tryLock()方法的时候，都会用到nonfairTryAcquire,所以需要写到父类中。\n那么为什么tryLock都要用非公平的nonfairTryAcquire呢？\n我们再来看一下tryLock方法的注释\n注释中写到， - 在当前没有线程持有这个锁的时候，那么tryLock方法就可以立即抢占这个锁，即使使用的公平锁的策略。这种行为在有些情况下能够带来更好的性能，尽管它会破坏公平性。 - 如果不想破坏公平性，那么可以使用tryLock(0, TimeUnit.SECONDS)方法。\n公平锁和非公平锁的性能对比 上面我们说到tryLock方法一直使用非公平的方式尝试获取锁，是因为非公平锁的性能要更好。那下面我们来分析一下原因和验证一下\n 因为公平锁在获取锁时，永远是等待时间最长的线程获取到锁，这样当线程T1释放锁以后，如果还想继续再获取锁，它也得去同步队列尾部排队，这样就会频繁的发生线程的上下文切换，当线程越多，对CPU的损耗就会越严重。 而且在唤醒队首的线程后，线程不会立即执行，而是需要等待CPU分配时间片，才能获取到锁。 而非公平锁，是有机会跳过等待队列，和等待CPU分配时间片的这个情况的，所以性能会好一些。 非公平锁性能虽然优于公平锁，但是会存在导致线程饥饿的情况。在最坏的情况下，可能存在某个线程一直获取不到锁。不过相比性能而言，饥饿问题可以暂时忽略。  下面我们通过代码来验证一下：\npublic class FairVsNonFairLock { // 公平锁  private static Lock fairLock = new ReentrantLock(true); // 非公平锁  private static Lock nonFairLock = new ReentrantLock(false); // 计数器  private static int fairCount = 0; // 计数器  private static int nonFairCount = 0; private static int threadCount = 1; public static void main(String[] args) throws InterruptedException { System.out.println(\"公平锁耗时: \" + testFairLock(threadCount) + \" ms\"); System.out.println(\"非公平锁耗时: \" + testNonFairLock(threadCount) + \" ms\"); } public static long testFairLock(int threadNum) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(threadNum); // 创建threadNum个线程，让其以公平锁的方式，对fairCount进行自增操作  ListThread fairList = new ArrayList(); for (int i = 0; i  threadNum; i++) { fairList.add(new Thread(() - { for (int j = 0; j  10000; j++) { fairLock.lock(); fairCount++; fairLock.unlock(); } countDownLatch.countDown(); })); } long startTime = System.currentTimeMillis(); for (Thread thread : fairList) { thread.start(); } // 让所有线程执行完  countDownLatch.await(); return System.currentTimeMillis() - startTime; } public static long testNonFairLock(int threadNum) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(threadNum); // 创建threadNum个线程，让其以非公平锁的方式，对nonFairCountCount进行自增操作  ListThread nonFairList = new ArrayList(); for (int i = 0; i  threadNum; i++) { nonFairList.add(new Thread(() - { for (int j = 0; j  10000; j++) { nonFairLock.lock(); nonFairCount++; nonFairLock.unlock(); } countDownLatch.countDown(); })); } long startTime = System.currentTimeMillis(); for (Thread thread : nonFairList) { thread.start(); } // 让所有线程执行完  countDownLatch.await(); return System.currentTimeMillis() - startTime; } }  线程数为1,跑3次\n公平锁耗时: 4 ms 非公平锁耗时: 2 ms ----- 公平锁耗时: 5 ms 非公平锁耗时: 3 ms ----- 公平锁耗时: 6 ms 非公平锁耗时: 3 ms 线程数为5，跑3次\n公平锁耗时: 337 ms 非公平锁耗时: 11 ms ------ 公平锁耗时: 497 ms 非公平锁耗时: 11 ms ------ 公平锁耗时: 421 ms 非公平锁耗时: 13 ms 线程数为10，跑3次\n公平锁耗时: 991 ms 非公平锁耗时: 22 ms ------ 公平锁耗时: 903 ms 非公平锁耗时: 31 ms ------ 公平锁耗时: 768 ms 非公平锁耗时: 18 ms  我们看到随着线程数的增加，非公平锁的性能要明显高于非公平锁了。所以这应该就是ReentranLock默认使用非公平锁的原因了。 其实我们看synchronized的源码，它也是非公平锁。\n独占式同步状态获取和释放 我们先来看一下获取同步状态的方法调用流程\n调用ReentranLock的lock方法，调用的是FairSync或者NonfairSync的lock()方法。 - NonfairSync会先尝试CAS获取一次，如果获取失败则调用AQS的acquire()方法 - FairSync则是直接调用AQS的acquire方法。 - acquire方法中，首先会调用FairSync或者NonfairSync的tryAcquire()方法 - 如果tryAcquire()失败，则会进入等待队列中。\n下面我们一个方法一个方法的分析，先来看acquire()。\n加锁逻辑 acquire方法 /** * Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once {@link #tryAcquire}, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking {@link * #tryAcquire} until success. This method can be used * to implement method {@link Lock#lock}. * * @param arg the acquire argument. This value is conveyed to * {@link #tryAcquire} but is otherwise uninterpreted and * can represent anything you like. */ public final void acquire(int arg) { if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //自我中断，用来传递线程在获取锁的过程中被中断的状态  selfInterrupt(); }  注释中提到，这个方法是忽略中断的。也就是说线程在获取锁的过程中，无法通过调用线程的interrupt()方法中断获取锁的行为。 会至少调用一次tryAcquire()方法，如果获取成功则返回。 所以说，如果一个线程是第一获取锁的线程，那么它会直接获取成功，并不会创建节点，只有第二个线程来获取，才会创建节点，然后加入等待队列。 如果失败线程会进入等待队列。 在队列中获取到锁之后会返回，  如果返回true则表示线程在获取锁过程中被调用过中断，则需要调用selfInterrupt()重新中断一下自己，把中断状态传传出来 如果返回false则表示没有被调用过中断。   addWaiter封装线程为Node节点 /** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */ private Node addWaiter(Node mode) { //构建新的node节点  Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure  //这里进行一次快速入队，而不是直接走完整的入队方法的考虑是  //完整入队操作，是通过死循环，然后调用CAS来实现的。JVM或者操作系统，在处理循环的时候，需要很多额外的资源和开销，  //所以先进行一次单独的CAS操作，如果成功的话，就能节省掉死循环的开销,如果不成功再使用enq，也不会有太大的开销  Node pred = tail; //如果尾节点不为空，把当前节点的前置节点设置为尾节点  //这里入队的时候，先尝试快速入队  if (pred != null) { //先和前面的节点建立联系，保证从后面遍历的时候，能够遍历到所有的节点  node.prev = pred; //使用CAS设置当前节点为尾节点  if (compareAndSetTail(pred, node)) { //如果设置成功，把前置节点的next指向当前节点  pred.next = node; return node; } } //如果CAS失败，或者尾结点为空，则需要进入完整的入队逻辑。  //CAS失败，则说明，有另一个线程进入了队列，并成为了尾结点。  enq(node); return node; }  首先通过当前线程构建一个Node节点 然后判断如果尾节点不为空，则尝试一次快速入队(通过单次CAS操作)  这里有一点需要注意，就是快速入队的时候，是先设置的node.prev = pred,然后在设置的pred.next = node，包括enq里面的操作也是，这里是有原因的，下面我们会详细的分析一下  如果快速入队失败，则调用enq(node),执行完整的入队操作  enq完整入队 我们说他是一个完整入队逻辑的原因是，它在for循环里，执行CAS操作，直到成功加入队列才会跳出循环\n这种操作也叫做 slow path\n/** * Inserts node into queue, initializing if necessary. See picture above. * @param node the node to insert * @return node's predecessor */ private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize  //走到这里的话说明，说明Node还没有初始化，需要创建一个节点，当做头结点  //初始化的时候，只有一个节点，所以这个节点既是头结点又是尾结点  if (compareAndSetHead(new Node())) tail = head; } else { //当初始化完成之后，会继续循环，直到把当前节点设置为尾结点。  node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } }  如果当前队列为空，或者快速入队失败，则会执行完整的入队逻辑 完整入队的其实就是循环调用快速入队的逻辑，直到成功。 如果当前队列为空，这时候需要先把头结点创建出来，然后下次循环的时候，在把真正的节点加入到头结点的后面。 所以，头结点是被第二个获取锁的线程，获取锁失败的时候，创建的。  acquireQueued方法 这个方法就是线程等待队列中获取锁，在这个方法中，线程会不断的进行尝试获取-挂起-唤醒-尝试获取知道获得锁\n/** * Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire. * * @param node the node * @param arg the acquire argument * @return {@code true} if interrupted while waiting 如果在等待过程，被中断过，获取锁之后返回true */ final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); //如果这个节点的前置节点是头结点，那么则表示这个节点有获取锁的资格。  //顺便说一下，在AQS的队列中个，头结点是一个虚节点，是为了在编程的时候更为方便，或者可以理解为已经获取到锁的节点  //调用tryAcquire()尝试获取锁  if (p == head \u0026\u0026 tryAcquire(arg)) { setHead(node); //把之前的头结点踢出等待队列  p.next = null; // help GC  failed = false; //获取锁成功之后，返回中断状态  return interrupted; } //如果没有资格获取锁，或者获取锁失败  //则需要通过shouldParkAfterFailedAcquire()，判断这个线程是否需要挂起  //如果当前节点，是头结点的下一个节点，那么shouldParkAfterFailedAcquire()方法会返回false，直接跳过挂起，再执行上面的逻辑获取一次  //如果需要park，则调用parkAndCheckInterrupt()方法，进行挂起。  //线程在挂起的时候，有两种唤醒的方式，  // 1.使用unpark  // 2.使用线程中断方法  //如果这个线程是被线程中断方法唤醒，那么会把这个interrupted变量置为true  //然后在等到这个线程获取到锁的时候，会把这个中断状态传出去  //这里使用到的一个特性就是，被park挂起的线程，当线程中断的时候不会抛出线程中断异常  if (shouldParkAfterFailedAcquire(p, node) \u0026\u0026 //如果返回true，表示是被中断唤醒的  parkAndCheckInterrupt()) //记录中断状态  interrupted = true; } } finally { if (failed) cancelAcquire(node); } }  线程被封装成Node节点加入等待队列之后，进入这个方法。 首先判断这个节点的前置节点是不是头结点，也就是说，这个节点是等待队列的第二个节点。 在AQS中，头结点是虚节点(或者理解为持有锁的节点)，只有第二个节点是有资格去获取锁。 然后调用tryAcquire尝试获取锁，获取成功后  会调用setHeader() 把当前线程的Node节点设置为头结点 并踢掉之前的头结点 并返回线程的中断状态，记录线程在获取锁的过程中，有没有被中断过。  如果不是第二个节点，或者tryAcquire失败，会调用shouldParkAfterFailedAcquire,判断线程是否应该挂起。  shouldParkAfterFailedAcquire方法 在这个方法中，会根据节点的状态判断线程是否要被挂起,并在某些情况下修改前置节点状态\n/** * Checks and updates status for a node that failed to acquire. * Returns true if thread should block. This is the main signal * control in all acquire loops. Requires that pred == node.prev. * * @param pred node's predecessor holding status * @param node the node * @return {@code true} if thread should block */ //在这个方法判断node节点的线程，是否需要挂起 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { //获取前置节点的waitStatus  int ws = pred.waitStatus; if (ws == Node.SIGNAL) //如果pred节点的waitStatus是SIGNAL，则表示pred节点正在等待别的通知来唤醒  //所以肯定还轮不到node节点来获取锁，直接挂起  //这个节点已经设置了请求释放资源的时候来通知它的状态，所以可以安全的挂起  /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws  0) { /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ //waitStatus  0 只有可能是canceled，那么则踢出pred节点  //让node的prev指向 pred节点的prev，就相当于跳过了pred节点。  //这里是一个循环操作，表示会把前面所有的连续的cancel状态的节点都踢出队列  do { node.prev = pred = pred.prev; } while (pred.waitStatus  0); pred.next = node; } else { /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ //执行到这里的话，waitStatus只能是0 或者 PROPAGATE。  //这时候会把前置节点的waitStatus 状态修改为signal，这样在下次循环的时候，当前节点就会执行挂起操作了  //每个节点的waitStatus都是由他的下一个节点来修改的  compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; }  首先拿到当前节点的前置节点的waitStatus,然后开始判断 如果waitStatus是SIGNAL状态,则返回true，表示新加入的节点已经告诉了他的前置节点，当前置节点释放的时候唤醒他，他可以放心的挂起了;下面的逻辑都会返回false，表示不会挂起。 如果waitStatus大于0，也就是CANCELLED状态，表示当前节点的前置节点已经被取消了，那么将这个前置节点踢出等待队列 并会把前面所有的连续的CANCELLED状态的节点都踢出队列 如果waitStatus不大于0，那么则waitStatus是0,或者PROPAGATE，那么就把它设置为SIGNAL状态，这样会再次尝试获取一次,如果仍然没有获取到，则会在下次判断shouldParkAfterFailedAcquire的时候，因为前置节点是SIGNAL而挂起。  这里的重点是对于SIGNAL状态的理解，我们再来看一下Java的解释，Java的解释有三个地方\n最后一张图片的注释中提到，AQS中使用和CLH相同的策略，在节点中保存一个后置节点的控制信息。当一个节点的前置节点被释放的时候，通知它的后置节点。 只有SIGNAL状态表示的是对后置节点的操作，其他状态都是表示的本身节点的状态\n上面提到，一个节点的waitStatus设置为SIGNAL，表示的是这个节点的后置节点正在或者将要被阻塞，也可以理解为这个节点的后置节点等待它前面节点唤醒(这个更符合SIGNAL的定义)。 - 所以说，一个节点的处于SIGNAL状态，表示的是，当这个节点被释放的时候，需要唤醒它的后续节点。 - 那么既然这个状态会指导对后置节点的操作，所以这个状态的变更也应该有后置节点来触发。 - 所以每个节点的初始状态都是0，当有后置节点加入队列的时候，会在后置节点执行shouldParkAfterFailedAcquire的时候，把这个节点的状态修改为SIGNAL\nparkAndCheckInterrupt挂起并检查中断状态 当经过上面的方法判断，线程需要被挂起，就会执行这个方法，使用LockSupport.park()挂起当前线程。\n//当线程被unpark()唤醒，或者被终端的时候返回当前线程的中断状态 //使用park()挂起的一个特点就是，当调用线程的中断方法时，不会抛出中断异常，同时也会保留线程的中断状态 private final boolean parkAndCheckInterrupt() { LockSupport.park(this); //这里注意一下，如果是通过调用线程interrupt方法唤醒了挂起的线程。  //这里调用的是 interrupted(),这个方法的作用是，返回当前线程的中断状态，然后清除掉中断状态，  //这里为什么必须要清除中断状态呢？  //因为线程被唤醒之后，需要再次去尝试获取锁，但是并不能保证肯定成功，如果失败了，还需要继续挂起。  //如果这里不清除中断状态，那么下次获取失败，需要再次挂起的时候，因为线程有中断状态，所以LockSuport.park()会失效，则导致线程无法挂起。  return Thread.interrupted(); }  线程被挂起后就会停在这行代码，等待被唤醒后继续向下执行。 线程被唤醒后，继续执行return Thread.interrupted();,返回当前线程的中断状态，然后清除掉中断状态。 所以如果线程是被中断方法唤醒的，parkAndCheckInterrupt()方法就会返回true，然后在acquireQueued()方法中就会执行interrupted = true;记录下来中断状态。 然后在线程成功获得锁之后，将记录的中断状态返回出去。  释放锁逻辑 release方法释放锁 当调用lock.unlock()方法释放锁时，会调用AQS的release()方法。\n/** * Releases in exclusive mode. Implemented by unblocking one or * more threads if {@link #tryRelease} returns true. * This method can be used to implement method {@link Lock#unlock}. * * @param arg the release argument. This value is conveyed to * {@link #tryRelease} but is otherwise uninterpreted and * can represent anything you like. * @return the value returned from {@link #tryRelease} * */ public final boolean release(int arg) { //tryRelease，尝试释放  //这里如果返回false，则表示发生了锁重入，这里只是释放了里层的，外层仍然还在持有锁  //如果返回true，则表示所有的重入都已经被释放了，可以唤醒下面的等待线程了  if (tryRelease(arg)) { Node h = head; //如果有head不为null，则表示至少有一个线程进入过等待队列，因为head节点是在后面线程进入等待队列的时候初始化的  //h.waitStatus != 0,为什么要加这个判断呢?  //因为waitStatus=0，是一个节点的初始状态，如果头结点处于这个状态，说明要么后面加入的线程还在执行中，没有执行到 shouldParkAfterFailedAcquire方法中的compareAndSetWaitStatus  //要么就是后面的线程在执行到 shouldParkAfterFailedAcquire()方法之前，已经超时了  //这两种情况都不需要唤醒  //第一种线程正在执行的情况，后面的线程会在第二次循环的时候tryAcquire(),能够拿到锁  if (h != null \u0026\u0026 h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } 1.首先调用Sync.tryRelease()方法，尝试释放锁\n//尝试释放锁 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; //如通c == 0，表示所有的锁都释放完了  //则设置持有锁线程为null  //返回释放锁成功  if (c == 0) { free = true; setExclusiveOwnerThread(null); } //如果c != 0 则表示发生了锁重入，只是里层释放了锁  //返回没有完全释放锁  setState(c); return free; } 这里主要处理了一个重入的逻辑，只有所有重入的锁都释放完毕了，才返回true。 值得注意的是，这个tryRelease()方法是写在Sync这个类中的，而不是FairSycn和NonFairSync，也就可以说明公平锁和非公平锁的释放逻辑是完全相同的。\n2.tryRelease()返回true，则需要判断是否需要唤醒后面的节点。\n我们来看这里的判断条件\nNode h = head; if (h != null \u0026\u0026 h.waitStatus != 0) unparkSuccessor(h); return true;  head!=null,因为head节点是，后续线程获取锁失败后，加入队列时创建的，所以head!=null就表示有后续节点。 h.waitStatus != 0一个节点的初始状态是0，在后置节点第一次判断是否应该挂起的时候，会把他的前置节点状态修改为SIGNAL也就是1。所以h.waitStatus=0就可以理解为  后置节点正在执行中，还没有挂起，所以不需要唤醒 后置节点调用的是带有超时的acquire()方法，已经等待所超时了 这几种情况都不需要唤醒。   unparkSuccessor唤醒后置节点 当一个线程释放了锁，并且确定有线程需要唤醒的时候，会调用unparkSuccessor()唤醒后面的节点。\n/** * Wakes up node's successor, if one exists. * * @param node the node */ private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ // 这里传入的是头结点，头结点已经完成了唤醒后面节点的操作，那么则可以把这个状态改回默认值了  int ws = node.waitStatus; if (ws  0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ /** 这里从后向前遍历的原因是，在新节点node入队的时候，都是先设置 node.prev = p（之前的tail节点）(也就是说从后向前可以遍历整个队里了) 然后通过cas，把node节点设置为tail 如果cas成功，才设置 p.next = node (这时候从head节点向后才能遍历整个队列) 以为cas成功，和 设置 p.next = node 这两个步骤并不是原子的 所以如果cas成功之后，在执行 p.next = node之前，unparkSuccessor()被调用。 线程开始从前往后遍历，这时候 p.next 还是为null的，所以就不能遍历队列所有的节点了。 **/ /** * 因为Node是一个双向队列 * 在插入新节点的时候，总是会先把新节点和前面的节点(也就是之前的尾结点)建立联系。node.prev = p; * 然后当新节点成功的成为尾结点之后，才会把 前面的节点和新节点建立联系 p.next = node; * * 这是可以理解，也是必须的。 * 因为 p(之前的尾结点)，已经是队列中确定的一个节点，如果在node节点确定加入队列之前就修改了p节点的next属性，如果node能在紧接着的 * cas操作成功还好，如果cas失败，那就是让p.next指向了一个队列外的节点。这肯定是不行的。 * * 所以说要么把入队和与p.next = node 这两个操作搞成一个原子操作(但是这样肯定会影响性能)，要么想出一个方案，在节点已经入队(已经成为了尾结点)，但是前面节点p还没和node节点建立联系的情况下，也能顺利的遍历所有的节点。 * * 先执行node.prev = p，就是解决这个问题的办法。 * * 所以导致了这里必须采用从队尾开始遍历的方案 * */ //拿到头结点的下一个节点  Node s = node.next; //如果为空，或者状态是已取消，则从尾结点开始找到一个非canceled状态的节点，然后唤醒它  if (s == null || s.waitStatus  0) { s = null; for (Node t = tail; t != null \u0026\u0026 t != node; t = t.prev) if (t.waitStatus  0) s = t; } //如果找到了合适的节点，则使用unpark()方法唤醒  if (s != null) LockSupport.unpark(s.thread); }  首先拿到头结点的后置节点，如果为空或者状态是CANCELLED则从队列中寻找一个可用的节点 这里有一个关键就是从队尾开始寻找  如果找到了，则使用LockSupport.unpark(s.thread)唤醒指定的线程。 我们上面说过了，线程挂起之后就会停在 parkAndCheckInterrupt()方法的LockSupport.park()这里，被唤醒后会继续向下执行，就会继续在acquireQueued()方法中尝试获取锁 不断的循环尝试获取-失败-挂起-唤醒-尝试获取这个过程，直到成功获取。  Condition 在详细分析Condition代码之前，先说一下我对Condition的理解\n如果说Lock和synchronized相对应，那么Conditon就是和wait(),notify相对应\nCondition为Lock提供了条件等待的功能，即一个线程达到某个条件时暂停执行，直到另一个线程通知它再次执行。因为这个条件需要在不同的线程中被访问，所以对Conditon对象的操作必须受到Lock的保护，也就是必要获得Lock，才能执行。\nCondition原理  当一个线程A获取了lock锁，调用了condition.await(),会释放锁，并构建一个Node对象(和AQS中的一样)节点状态为CONDITION,-2，加入到Condition的条件队列中。 然后让当前线程挂起，等待唤醒，或者挂起一段时间自己唤醒 当另一个线程B获取了lock锁，调用了condition.signal(),会找到condition条件队列中的第一个节点，把它加入到AQS的同步队列中，然后唤醒Node中的线程。 线程A被唤醒后，会调用acquireQueued再次尝试获取锁  Condition的原理其实和JVM对于wait和notify的实现很类似。我们对比着来说明一下。\nwait和notify执行大致流程\n 线程A在同步代码块中，调用wait()方法，释放锁，并把A线程加入到waitSet中 线程挂起，等待唤醒，或者挂起一段时间自己唤醒 线程B，在同步代码块中，调用notify方法，会唤醒waitSet队列中的第一个节点，然后把这个节点加入到cxq队列中 线程A就在cxq队列中等待再次获取锁。  我们看到Condition和wait于notify的流程基本完全相同\n Condition队列对应着waitSet 同步队列对应着cxq 另外他们对于中断的处理也是很相似的。因为线程的挂起可以被中断方法唤醒，所以他们在被唤醒之后，都需要检查自己是不是被中断唤醒的 如果是被中断唤醒，需要有对应的处理，  wait是直接抛出中断异常 condition可以根据一定的策略，可以选择抛出中断异常和自我中断   有了这些概念，下面我们来进入代码分析\n代码分析 await() // Condition中的操作实际上是，先把自己加入到一个 Condition队列中。 // 然后释放掉获取的AQS锁，然后通过LockSupport挂起，等待其他线程唤醒，唤醒后在继续获取锁 public final void await() throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); //加入一个新节点到，condition队列中  Node node = addConditionWaiter(); //释放锁，想一下wait和notify，别人在唤醒你的时候，也需要获得锁，如果你不释放别人怎么唤醒你呢，所以这里要释放锁  int savedState = fullyRelease(node); int interruptMode = 0; //在调用signal的时候会把节点加入到同步队列中，  //如果已经在队列中了，那说明已经有人唤醒了它，把它加入到了队列中，那么直接获取锁就可以了。  //如果还没有加入队列，则需要挂起，等待唤醒的时候被加入到队列中。  while (!isOnSyncQueue(node)) { LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } //然后在进入等待队列中获取锁  if (acquireQueued(node, savedState) \u0026\u0026 interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled  unlinkCancelledWaiters(); if (interruptMode != 0) //根据interruptMode执行抛出异常或者自我中断  reportInterruptAfterWait(interruptMode); } addConditionWaiter /** * Adds a new waiter to wait queue. * @return its new wait node */ //这里之所以在向队列中添加节点的时候，没有采用AQS中的那种 形式 //是因为在调用 condition.await()的时候，需要先通过 lock.lock()获取到锁，所以在这一步不会存在竞争 //Condition队列是一个全新的队列 //这里因为没有并发问题，所以写起来就明朗多了，不用各种的CAS操作来保证并发安全了 private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out.  if (t != null \u0026\u0026 t.waitStatus != Node.CONDITION) { //删除所有cancelled状态的节点  unlinkCancelledWaiters(); t = lastWaiter; } //构建节点，初始即为Condition状态。  //如果当前队列为空，就设置为头结点  //如果不为空，就设置为当前tail的next  //最后设置当前节点为尾节点  Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; } fullyRelease //这里的fully的意思是，不管发生了几次重入，全部一次性释放 //所以这里是直接拿到当前的state，然后一次性release //并唤醒同步队列中的一个节点 final int fullyRelease(Node node) { boolean failed = true; try { int savedState = getState(); if (release(savedState)) { failed = false; return savedState; } else { throw new IllegalMonitorStateException(); } } finally { if (failed) node.waitStatus = Node.CANCELLED; } } checkInterruptWhileWaiting /** * Checks for interrupt, returning THROW_IE if interrupted * before signalled, REINTERRUPT if after signalled, or * 0 if not interrupted. */ /** * 在唤醒钱被中断，则返回 throw_ie,唤醒后中断则返回 REINTERRUPT * 没有中断，返回0 */ private int checkInterruptWhileWaiting(Node node) { return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; } signal public final void signal() { //首先判断是不是持有锁，如果没有持有锁，则抛出监视器状态异常  if (!isHeldExclusively()) throw new IllegalMonitorStateException(); //唤醒Condition队列的第一个节点  Node first = firstWaiter; if (first != null) doSignal(first); }//唤醒wait队列上的第一个节点 private void doSignal(Node first) { do { //判断是否队列上只有一个节点，如果是，就将lastWaiter 设置为null  if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; //既然要唤醒第一个节点，唤醒后，直接将第一个节点从队列上移除。  first.nextWaiter = null; //通过transferForSignal将节点加入到同步队列中。如果加入失败了，则重新取出wait队列的第一个节点并唤醒。  } while (!transferForSignal(first) \u0026\u0026 (first = firstWaiter) != null); }//将wait节点放入到同步队列中 final boolean transferForSignal(Node node) { /* * If cannot change waitStatus, the node has been cancelled. */ //这里如果CAS失败，说明当前节点的状态已经不是CONDITION，说明已经被其他线程唤醒了。  //返回false之后，外层是一个循环，会继续取出wait队列的第一个节点，继续执行唤醒操作  if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; /* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ //将当前节点加入到同步队列，注意，这里enq返回值返回的是假如队列节点的前一个节点，也就是原队尾节点。  Node p = enq(node); int ws = p.waitStatus; //这里的判断非常巧妙，我们知道，我们把Node节点从wait移动到同步队列，如果我们把节点线程唤醒，是没有问题的。  //因为唤醒后执行到await中的acquireQueued的时候，会被重新挂起，但是这样比较耗费性能，是没有必要的。  //所以这里进行了判断，如果移入到同步队列后，发现原尾节点的状态大于0，或者将尾节点的状态改为SIGNAL的时候失败了，才会唤醒。并在acquireQueued中重新整理同步队列并重新挂起。  //这里不挂起是没有问题的，因为在acquireQueued挂起前判断，如果当前节点是第一个节点，会直接获取锁。如果中断唤醒了，或继续从await挂起的地方继续执行，会继续在acquireQueued的地方重新挂起。  if (ws  0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true; } signalAll public final void signalAll() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); //拿到wait队列，执行doSignalAll  Node first = firstWaiter; if (first != null) doSignalAll(first);//理解了signal，理解这里的doSignalAll就很简单了。 //就是遍历wait队列上的节点逐个顺序取出放入到同步队列中。 private void doSignalAll(Node first) { lastWaiter = firstWaiter = null; do { Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; } while (first != null); } 重点问题总结 下面的一些重点问题，其实在上面方法的部分中已经提到了，这里专门整理出来，也是为了更方便的查看，AQS中的细节很多，如果全部都去了解需要耗费太多的精力。\n为什么线程被唤醒之后要调用Thread.interrupted()清除中断状态 parkAndCheckInterrupt挂起并检查中断状态 我们在上面的这个标题中个，讨论了这个问题。 主要原因就是线程在被中断唤醒之后，去获取锁不一定会成功，如果失败了，还需要继续挂起，如果不清除中断状态，就会无法挂起了，所以这里必须要清除\n为什么需要调用selfInterrupt进行自我中断 上面我们说到，线程在等待锁的状态下，被调用了中断。 - 在执行parkAndCheckInterrupt()方法后，会被清除掉线程的中断状态。 - 但是会在acquireQueued方法中记录下来被调用了中断的这个事情interrupted = true; - 线程在获取到锁之后，会返回中断状态 - 如果这时候返回的是true，表示线程在这段时间内被中断过，但是线程的中断状态已经被清除了 - 所以需要调用selfInterrupt自我中断一下，设置中断状态，一遍后面的代码可能会有用到中断状态的地方。 - AQS在这里秉持的一个原则就是，我可以不响应中断，但是我不能报中断状态吞掉\n唤醒后置节点的时候为什么从Tail开始遍历 这个问题我们在unparksuccessor的代码注释中有详细的说明。\nfast path和slow path 在查看synchronized原码的时候就很多次看到fast path和slow path这两个词。这次又在AQS的代码中看到相关的概念，稍微有一点想法，尝试着解释一下。\nfast path\n 我忍为可以理解为一种，使用一种相对比较轻量级的方式来达成目标，但是不能保证一定成功。比如在AQS中这里的fast path指的就是一次CAS操作。  slow path\n-相对的slow path，就是指的一种重量级的方式，可以确保一定会成功。在AQS中，slow path指的就是循环调用CAS操作。操作系统在执行循环操作的时候，会需要一些额外的资源。\n一般在编写过程中，可以先尝试使用一次fast path - 如果成功了则节省了很多资源 - 如果失败了那么在调用slow path，比直接调用slow path只多出了一次fast path操作，消耗也可以接受。\nCANCELED节点 这里我们讨论一下CANCELED状态节点的问题。\nCANCELED节点何时产生 在代码里我们看到CANCELED被直接用到的地方只有两处代码 第二处调用的方法fullyRelease是Condition相关的，我们先不看，主要看第一个方法cancelAcquire。\n我们看这个方法的名字就很清晰，表示取消获取锁，它在什么时候被调用呢?\n我们看到它被调用的地方都很统一，就是在各种各样的获取锁方法中被调用。代码的逻辑也都很一致。 - 在方法中定义一个局部变量 fail = true； - 在获取锁成功的时候设置 fail = false; - 在finally代码块中判断fail，如果为true，则执行cancelAcquire方法。 这就表示，在获取锁的过程中，只要发生了任何意外情况导致获取锁失败了，像执行出现异常、获取锁超时、获取锁被中断(不响应中断的获取锁除外)都会执行到这个方法。\n下面就来看一下这个方法\nprivate void cancelAcquire(Node node) { // Ignore if node doesn't exist  if (node == null) return; //将节点中的线程设置为null  //设置该节点不关联任何线程，也就是虚节点  node.thread = null; // Skip cancelled predecessors  //跳过前面节点中状态为cancel的节点，把这个节点的前置节点引用指向一个不是cancel状态的节点(0,或者SIGNAL)  Node pred = node.prev; while (pred.waitStatus  0) node.prev = pred = pred.prev; // predNext is the apparent node to unsplice. CASes below will  // fail if not, in which case, we lost race vs another cancel  // or signal, so no further action is necessary.  Node predNext = pred.next; // Can use unconditional write instead of CAS here.  // After this atomic step, other Nodes can skip past us.  // Before, we are free of interference from other threads.  //把当前节点的状态设置为取消  node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves.  // 如果当前节点是尾结点，则修改当前节点的前置节点为新的尾结点  if (node == tail \u0026\u0026 compareAndSetTail(node, pred)) { //如果修改成功，然后把前置节点的next 设置为null,这时候前置节点已经是尾结点了，所以它没有next节点了  //这一步成功失败，并不重要，如果失败，表示节点已经为null了，或者有新的节点加入，成为了它的next  compareAndSetNext(pred, predNext, null); } else { // If successor needs signal, try to set pred's next-link  // so it will get one. Otherwise wake it up to propagate.  //如果走到这里，说明要么当前节点不是tail节点  //或者，在cas的时候node不是尾结点了，有新的线程加入成为了新的尾结点。  int ws; //首先判断node节点的前置节点是不是head,如果是则直接走else逻辑  if (pred != head \u0026\u0026 //如果node的前置节点不是head  //则判断waitStatus是不是signal  //如果不是signal，则判断是不是非cancelled状态，如果是则cas把状态设置为signal  //判断pred的线程不能为null  ((ws = pred.waitStatus) == Node.SIGNAL || (ws  0 \u0026\u0026 compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) \u0026\u0026 pred.thread != null) { //接下来的操作，我理解就是把node的前置节点和node的next节点，连接起来  Node next = node.next; if (next != null \u0026\u0026 next.waitStatus  0) compareAndSetNext(pred, predNext, next); } else { //如果是head的话那么现在队列的情况是 head - node - node1 - tail  //这时候 node节点是cancel状态，那么就需要唤醒 node1节点  //唤醒node1 需要传入的是node1的前置节点也就是node，所以 unparkSuccessor(node);  unparkSuccessor(node); } //为什么不是=null呢？  node.next = node; // help GC  } }  设置Node的thread为null 把当前节点的挂到一个非CANCELLED状态的节点上，并没有清除,因为这这里并没有设置pred.next = node 设置当前Node状态为CANCELLED 拿到前置节点的后置节点，一般来说正常情况下，就是Node节点 判断当前节点是不是尾节点 如果是尾节点，就把当前节点的前置节点设为尾节点  如果设置成功，把前置节点(也就是当前的尾节点)的next设置为null(这一步失败了也没有关系)  如果不是尾节点，或者设置尾节点失败(表示有新节点加入成为了新的尾节点)。执行else逻辑  else中的逻辑判断比较复杂，我们单独来看一下\n 首先如果Node节点的前置节点是Head节点,也就是下面这种情况，其中Node表示当前节点，Node节点为CANCELLED状态。本来正常情况下Node节点是下次被唤醒的节点，但是它取消了，那么就应该唤醒它的后置节点node1了。 唤醒它的后置节点后，后置节点会尝试获取锁，这时候如果之前持有锁的线程还没有释放，他会获取失败，然后在shouldParkAfterFailedAcquire方法中，把处于CANCELLED状态的节点移除队列 如果获取成功了，那么前面的节点肯定也会被排除队列了\nHead - cancelledNode - node1 如果前置节点不是头结点，并且前置节点的状态不是CANCELLED,后面这些判断条件看看前置节点是不是SIGNAL状态，或者能不能设置为SIGNAL状态\n 如果可以，就把CANCELLED状态节点的后置节点和他的前置节点连接上。相当于把自己踢出队列\nHead - node1- cancelledNode - node2 Head - node1- node2  CANCELLED节点何时被踢出 大部分的踢出CANCELLED节点的操作都在shouldParkAfterFailedAcquire方法中完成。也就是这部分代码\nif (ws  0) { /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do { node.prev = pred = pred.prev; } while (pred.waitStatus  0); pred.next = node; } 在JDK原码中有很多这种写法，看的有点蒙蒙的，我们把它拆解一下\npred = pred.prev; node.prev = pred; 就是pred，往前挪一个节点，然后node.prev指向新的pred节点。 下面用图来表示一下，tail表示 node节点\n 初始状态，pred指向node3，node.prev指向node3， 因为node3状态为 cancelled,所以pred向前挪一个,指向node2，同时node.prev指向node2 因为node2状态为 cancelled,所以pred向前挪一个,指向node1，同时node.prev指向node1 node1状态为SIGNAL,跳出循环，设置node1.next = node,把node2和node3排除队列  参考 java并发编程系列：牛逼的AQS（上）\n从ReentrantLock的实现看AQS的原理及应用\n公平锁与非公平锁的对比\nReentrantLock Condition源码分析\n","wordCount":"3189","inLanguage":"en","datePublished":"2021-06-24T00:00:00Z","dateModified":"2021-06-24T00:00:00Z","author":{"@type":"Person","name":"    \"zhouyang\""},"mainEntityOfPage":{"@type":"WebPage","@id":"https://balvboy.github.io/blog/aqs/"},"publisher":{"@type":"Organization","name":"ZhouYang's Blog","logo":{"@type":"ImageObject","url":"https://balvboy.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://balvboy.github.io accesskey=h title="Home (Alt + H)"><img src=/img/zhouyang.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://balvboy.github.io/blog/ title=blogs><span>blogs</span></a></li><li><a href=https://balvboy.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://balvboy.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://balvboy.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?a3d79563dfbd078b66e86495caf11120",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script><script src=/js/mermaid.js></script></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Java同步机制(六)- AQS</h1><div class=post-description>AbstractQueuedSynchronizer</div><div class=post-meta>June 24, 2021&nbsp;·&nbsp;15 min&nbsp;·&nbsp;    "zhouyang"</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#aqs%e7%bb%93%e6%9e%84 aria-label=AQS结构>AQS结构</a><ul><li><a href=#%e5%90%8c%e6%ad%a5%e7%8a%b6%e6%80%81 aria-label=同步状态>同步状态</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e9%98%9f%e5%88%97 aria-label=同步队列>同步队列</a></li><li><a href=#%e7%8b%ac%e5%8d%a0%e5%92%8c%e5%85%b1%e4%ba%ab%e6%a8%a1%e5%bc%8f aria-label=独占和共享模式>独占和共享模式</a></li></ul></li><li><a href=#reentranlock aria-label=ReentranLock>ReentranLock</a><ul><li><a href=#sync%e5%86%85%e9%83%a8%e7%b1%bb aria-label=Sync内部类>Sync内部类</a><ul><li><a href=#%e5%85%ac%e5%b9%b3%e9%94%81%e5%92%8c%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81%e5%9c%a8%e8%8e%b7%e5%8f%96%e9%94%81%e6%97%b6%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=公平锁和非公平锁在获取锁时的区别>公平锁和非公平锁在获取锁时的区别</a></li><li><a href=#nonfairtryacquire%e6%96%b9%e6%b3%95%e4%b8%ba%e4%bd%95%e5%ae%9a%e4%b9%89%e5%9c%a8%e7%88%b6%e7%b1%bb aria-label=nonfairTryAcquire方法为何定义在父类>nonfairTryAcquire方法为何定义在父类</a></li><li><a href=#%e5%85%ac%e5%b9%b3%e9%94%81%e5%92%8c%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81%e7%9a%84%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94 aria-label=公平锁和非公平锁的性能对比>公平锁和非公平锁的性能对比</a></li></ul></li><li><a href=#%e7%8b%ac%e5%8d%a0%e5%bc%8f%e5%90%8c%e6%ad%a5%e7%8a%b6%e6%80%81%e8%8e%b7%e5%8f%96%e5%92%8c%e9%87%8a%e6%94%be aria-label=独占式同步状态获取和释放>独占式同步状态获取和释放</a></li><li><a href=#%e5%8a%a0%e9%94%81%e9%80%bb%e8%be%91 aria-label=加锁逻辑>加锁逻辑</a><ul><li><a href=#acquire%e6%96%b9%e6%b3%95 aria-label=acquire方法>acquire方法</a></li><li><a href=#addwaiter%e5%b0%81%e8%a3%85%e7%ba%bf%e7%a8%8b%e4%b8%banode%e8%8a%82%e7%82%b9 aria-label=addWaiter封装线程为Node节点>addWaiter封装线程为Node节点</a></li><li><a href=#enq%e5%ae%8c%e6%95%b4%e5%85%a5%e9%98%9f aria-label=enq完整入队>enq完整入队</a></li><li><a href=#acquirequeued%e6%96%b9%e6%b3%95 aria-label=acquireQueued方法>acquireQueued方法</a></li><li><a href=#shouldparkafterfailedacquire%e6%96%b9%e6%b3%95 aria-label=shouldParkAfterFailedAcquire方法>shouldParkAfterFailedAcquire方法</a></li><li><a href=#parkandcheckinterrupt%e6%8c%82%e8%b5%b7%e5%b9%b6%e6%a3%80%e6%9f%a5%e4%b8%ad%e6%96%ad%e7%8a%b6%e6%80%81 aria-label=parkAndCheckInterrupt挂起并检查中断状态>parkAndCheckInterrupt挂起并检查中断状态</a></li></ul></li><li><a href=#%e9%87%8a%e6%94%be%e9%94%81%e9%80%bb%e8%be%91 aria-label=释放锁逻辑>释放锁逻辑</a><ul><li><a href=#release%e6%96%b9%e6%b3%95%e9%87%8a%e6%94%be%e9%94%81 aria-label=release方法释放锁>release方法释放锁</a></li><li><a href=#unparksuccessor%e5%94%a4%e9%86%92%e5%90%8e%e7%bd%ae%e8%8a%82%e7%82%b9 aria-label=unparkSuccessor唤醒后置节点>unparkSuccessor唤醒后置节点</a></li></ul></li><li><a href=#condition aria-label=Condition>Condition</a><ul><li><a href=#condition%e5%8e%9f%e7%90%86 aria-label=Condition原理>Condition原理</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90 aria-label=代码分析>代码分析</a><ul><li><a href=#await aria-label=await()>await()</a></li><li><a href=#addconditionwaiter aria-label=addConditionWaiter>addConditionWaiter</a></li><li><a href=#fullyrelease aria-label=fullyRelease>fullyRelease</a></li><li><a href=#checkinterruptwhilewaiting aria-label=checkInterruptWhileWaiting>checkInterruptWhileWaiting</a></li><li><a href=#signal aria-label=signal>signal</a></li><li><a href=#signalall aria-label=signalAll>signalAll</a></li></ul></li></ul></li><li><a href=#%e9%87%8d%e7%82%b9%e9%97%ae%e9%a2%98%e6%80%bb%e7%bb%93 aria-label=重点问题总结>重点问题总结</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%ba%bf%e7%a8%8b%e8%a2%ab%e5%94%a4%e9%86%92%e4%b9%8b%e5%90%8e%e8%a6%81%e8%b0%83%e7%94%a8thread-interrupted-%e6%b8%85%e9%99%a4%e4%b8%ad%e6%96%ad%e7%8a%b6%e6%80%81 aria-label=为什么线程被唤醒之后要调用Thread.interrupted()清除中断状态>为什么线程被唤醒之后要调用Thread.interrupted()清除中断状态</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e8%b0%83%e7%94%a8selfinterrupt%e8%bf%9b%e8%a1%8c%e8%87%aa%e6%88%91%e4%b8%ad%e6%96%ad aria-label=为什么需要调用selfInterrupt进行自我中断>为什么需要调用selfInterrupt进行自我中断</a></li><li><a href=#%e5%94%a4%e9%86%92%e5%90%8e%e7%bd%ae%e8%8a%82%e7%82%b9%e7%9a%84%e6%97%b6%e5%80%99%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bb%8etail%e5%bc%80%e5%a7%8b%e9%81%8d%e5%8e%86 aria-label=唤醒后置节点的时候为什么从Tail开始遍历>唤醒后置节点的时候为什么从Tail开始遍历</a></li><li><a href=#fast-path%e5%92%8cslow-path aria-label="fast path和slow path">fast path和slow path</a></li><li><a href=#canceled%e8%8a%82%e7%82%b9 aria-label=CANCELED节点>CANCELED节点</a><ul><li><a href=#canceled%e8%8a%82%e7%82%b9%e4%bd%95%e6%97%b6%e4%ba%a7%e7%94%9f aria-label=CANCELED节点何时产生>CANCELED节点何时产生</a></li><li><a href=#cancelled%e8%8a%82%e7%82%b9%e4%bd%95%e6%97%b6%e8%a2%ab%e8%b8%a2%e5%87%ba aria-label=CANCELLED节点何时被踢出>CANCELLED节点何时被踢出</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><p>终于来到了重头戏-<code>AQS</code>,AQS可以说是整个<code>J.U.C</code>的核心，整个工具包中的大部分同步工具都是借助于AQS来实现的。接下来我们将通过<code>ReentranLock</code>的实现来了解AQS的原理</p><h1 id=aqs结构>AQS结构<a hidden class=anchor aria-hidden=true href=#aqs结构>#</a></h1><h2 id=同步状态>同步状态<a hidden class=anchor aria-hidden=true href=#同步状态>#</a></h2><p>首先在AQS中维护了一个名叫state的字段，是由volatile修饰的，它就是所谓的同步状态：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int</span> state<span style=color:#f92672>;</span></code></pre></div><p>并且提供了几个访问这个字段的方法：</p><table><thead><tr><th align=left>方法名称</th><th align=left>描述</th></tr></thead><tbody><tr><td align=left>protected final int getState()</td><td align=left>获取state的值</td></tr><tr><td align=left>protected final void setState(int newState)</td><td align=left>设置state的值</td></tr><tr><td align=left>protected final boolean compareAndSetState(int expect, int update)</td><td align=left>使用CAS方式更新state的值</td></tr></tbody></table><p>可以看到这几个方法都是final修饰的，说明子类中无法重写它们。另外它们都是protected修饰的，说明只能在子类中使用这些方法。</p><h2 id=同步队列>同步队列<a hidden class=anchor aria-hidden=true href=#同步队列>#</a></h2><p>AQS使用一个Volatile的int类型的成员变量<code>state</code>来表示同步状态，通过内置的FIFO同步队列来完成资源获取的排队工作。</p><p><img src=/img/clhqueue.webp alt></p><p><span style=color:red>有一点值得注意，就是这里的头结点是一个虚节点，它的thread为空，头结点的存在更多意义上是为了编程方便。当然为了方便理解，我们可以认为头结点就是获取了锁的线程的节点，但是thread被清空了</span></p><p>当线程获取到锁的时候，会把线程所在的节点设置为头结点，设置为头结点后，会把不需要的属性设置为null。</p><pre><code>/**
 * Sets head of queue to be node, thus dequeuing. Called only by
 * acquire methods.  Also nulls out unused fields for sake of GC
 * and to suppress unnecessary signals and traversals.
 *
 * @param node the node
 */
private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}</code></pre><p>AQS中定义一个头节点引用，一个尾节点引用：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>volatile</span> Node head<span style=color:#f92672>;</span> <span style=color:#75715e>//执行队列的头结点
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>volatile</span> Node tail<span style=color:#f92672>;</span> <span style=color:#75715e>//执行队列的尾节点
</span></code></pre></div><p>上面图中的每个线程，都对应着一个Node节点，Node是AQS中的一个内部类，下面解释一下几个方法和属性值的含义：</p><table><thead><tr><th align=center>方法和属性</th><th align=center>含义</th></tr></thead><tbody><tr><td align=center>waitStatus</td><td align=center>当前节点在队列中的状态</td></tr><tr><td align=center>thread</td><td align=center>表示处于该节点的线程</td></tr><tr><td align=center>prev</td><td align=center>指向前一个节点的指针</td></tr><tr><td align=center>next</td><td align=center>指向后一个节点的指针</td></tr><tr><td align=center>predecessor</td><td align=center>返回前一个节点，没有的话抛出npe</td></tr><tr><td align=center>nextWaiter</td><td align=center>指向下一个处于CONDITION状态的节点(暂不多做介绍)</td></tr></tbody></table><table><thead><tr><th align=center>枚举</th><th align=center>含义</th></tr></thead><tbody><tr><td align=center>0</td><td align=center>Node初始化的默认值</td></tr><tr><td align=center>CANCELLED</td><td align=center>为1，表示节点已经取消获取锁</td></tr><tr><td align=center>CONDITION</td><td align=center>为-2，表示节点在等待队列中，节点线程等待唤醒</td></tr><tr><td align=center>PROPAGATE</td><td align=center>为-3，当前线程处在SHARED情况下，该字段才会使用</td></tr><tr><td align=center>SIGNAL</td><td align=center>为-1，表示该节点的继任者(下一个节点)，已经或者将要被block</td></tr></tbody></table><p>这里把java源码中的注释也贴出来，方便大家理解</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e>  * Status field, taking on only the values:
</span><span style=color:#75715e>  *   SIGNAL:     The successor of this node is (or will soon be)
</span><span style=color:#75715e>  *               blocked (via park), so the current node must
</span><span style=color:#75715e>  *               unpark its successor when it releases or
</span><span style=color:#75715e>  *               cancels. To avoid races, acquire methods must
</span><span style=color:#75715e>  *               first indicate they need a signal,
</span><span style=color:#75715e>  *               then retry the atomic acquire, and then,
</span><span style=color:#75715e>  *               on failure, block.
</span><span style=color:#75715e>  *   CANCELLED:  This node is cancelled due to timeout or interrupt.
</span><span style=color:#75715e>  *               Nodes never leave this state. In particular,
</span><span style=color:#75715e>  *               a thread with cancelled node never again blocks.
</span><span style=color:#75715e>  *   CONDITION:  This node is currently on a condition queue.
</span><span style=color:#75715e>  *               It will not be used as a sync queue node
</span><span style=color:#75715e>  *               until transferred, at which time the status
</span><span style=color:#75715e>  *               will be set to 0. (Use of this value here has
</span><span style=color:#75715e>  *               nothing to do with the other uses of the
</span><span style=color:#75715e>  *               field, but simplifies mechanics.)
</span><span style=color:#75715e>  *   PROPAGATE:  A releaseShared should be propagated to other
</span><span style=color:#75715e>  *               nodes. This is set (for head node only) in
</span><span style=color:#75715e>  *               doReleaseShared to ensure propagation
</span><span style=color:#75715e>  *               continues, even if other operations have
</span><span style=color:#75715e>  *               since intervened.
</span><span style=color:#75715e>  *   0:          None of the above
</span><span style=color:#75715e>  *
</span><span style=color:#75715e>  * The values are arranged numerically to simplify use.
</span><span style=color:#75715e>  * Non-negative values mean that a node doesn&#39;t need to
</span><span style=color:#75715e>  * signal. So, most code doesn&#39;t need to check for particular
</span><span style=color:#75715e>  * values, just for sign.
</span><span style=color:#75715e>  *
</span><span style=color:#75715e>  * The field is initialized to 0 for normal sync nodes, and
</span><span style=color:#75715e>  * CONDITION for condition nodes.  It is modified using CAS
</span><span style=color:#75715e>  * (or when possible, unconditional volatile writes).
</span><span style=color:#75715e>  */</span>
  <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int</span> waitStatus<span style=color:#f92672>;</span></code></pre></div><p>todo 后面我们在补充一下</p><h2 id=独占和共享模式>独占和共享模式<a hidden class=anchor aria-hidden=true href=#独占和共享模式>#</a></h2><p>在一些线程协调的场景中，一个线程在进行某些操作的时候其他的线程都不能执行该操作，比如持有锁时的操作，在同一时刻只能有一个线程持有锁，我们把这种情景称为<code>独占模式</code>；
在另一些线程协调的场景中，可以同时允许多个线程同时进行某种操作，我们把这种情景称为<code>共享模式</code>。
我们可以通过修改AQS中state字段代表的同步状态来实现多线程的独占模式或者共享模式。</p><ul><li><p>独占模式
在独占模式下，我们设置state为0，线程要进行独占操作的时候，需要使用CAS操作，把0修改为1，我们把这个过程称为<code>尝试获取同步状态</code>。然后在执行完成后，同样再通过CAS操作修改回来,把这个操作成为<code>释放同步状态</code>。这洋就能保证任何时候，都只能有一个线程独占。</p></li><li><p>共享模式
在共享模式下，我们设置state为能支持共享的最大线程数，比如10。线程在执行共享操作时，每次都判断state是否大于0，如果大于0，通过CAS把state的值减1,我们把这个过程成为<code>尝试获取共享同步状态</code>。然后每个线程再执行完之后，再通过CAS把state的值+1,我们把这个操作成为<code>释放共享同步状态</code>。</p></li></ul><p>在后面的代码分析中会详细讲解独占模式和共享模式。</p><p>对于上面提到的<code>获取共享状态</code>和<code>释放共享状态</code>以及<code>尝试获取共享同步状态</code>和<code>释放共享同步状态</code>，AQS中定义了几个方法</p><table><thead><tr><th align=left>方法名称</th><th align=left>描述</th></tr></thead><tbody><tr><td align=left>protected boolean tryAcquire(int arg)</td><td align=left>独占式的获取同步状态，获取成功返回true，否则false</td></tr><tr><td align=left>protected boolean tryRelease(int arg)</td><td align=left>独占式的释放同步状态，释放成功返回true，否则false</td></tr><tr><td align=left>protected int tryAcquireShared(int arg)</td><td align=left>共享式的获取同步状态，获取成功返回true，否则false</td></tr><tr><td align=left>protected boolean tryReleaseShared(int arg)</td><td align=left>共享式的释放同步状态，释放成功返回true，否则false</td></tr><tr><td align=left>protected boolean isHeldExclusively()</td><td align=left>在独占模式下，如果当前线程已经获取到同步状态，则返回 true；其他情况则返回 false</td></tr></tbody></table><p>这几个方法，AQS都没有实现，而是要求子类去实现。如果我们自定义的同步工具需要在独占模式下工作，那么我们就重写tryAcquire、tryRelease和isHeldExclusively方法。</p><p>在了解了上面这些内容之后，我们通过<code>ReentranLock</code>来详细了解一下AQS的独占模式是如何工作的。</p><h1 id=reentranlock>ReentranLock<a hidden class=anchor aria-hidden=true href=#reentranlock>#</a></h1><p>先来看一下<code>ReentranLock</code>的代码结构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReentrantLock</span> <span style=color:#66d9ef>implements</span> Lock<span style=color:#f92672>,</span> java<span style=color:#f92672>.</span><span style=color:#a6e22e>io</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Serializable</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>/** Synchronizer providing all implementation mechanics */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Sync sync<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Sync</span> <span style=color:#66d9ef>extends</span> AbstractQueuedSynchronizer<span style=color:#f92672>{</span>
      <span style=color:#f92672>...</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NonfairSync</span> <span style=color:#66d9ef>extends</span> Sync <span style=color:#f92672>{</span>
      <span style=color:#f92672>...</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FairSync</span> <span style=color:#66d9ef>extends</span> Sync <span style=color:#f92672>{</span>
      <span style=color:#f92672>...</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ReentrantLock</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> sync <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NonfairSync<span style=color:#f92672>();</span> <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ReentrantLock</span><span style=color:#f92672>(</span><span style=color:#66d9ef>boolean</span> fair<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        sync <span style=color:#f92672>=</span> fair <span style=color:#f92672>?</span> <span style=color:#66d9ef>new</span> FairSync<span style=color:#f92672>()</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> NonfairSync<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lock</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> sync<span style=color:#f92672>.</span><span style=color:#a6e22e>lock</span><span style=color:#f92672>();}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lockInterruptibly</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
        sync<span style=color:#f92672>.</span><span style=color:#a6e22e>acquireInterruptibly</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryLock</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> sync<span style=color:#f92672>.</span><span style=color:#a6e22e>nonfairTryAcquire</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryLock</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> timeout<span style=color:#f92672>,</span> TimeUnit unit<span style=color:#f92672>)</span>
            <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> sync<span style=color:#f92672>.</span><span style=color:#a6e22e>tryAcquireNanos</span><span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> unit<span style=color:#f92672>.</span><span style=color:#a6e22e>toNanos</span><span style=color:#f92672>(</span>timeout<span style=color:#f92672>));</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unlock</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        sync<span style=color:#f92672>.</span><span style=color:#a6e22e>release</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> Condition <span style=color:#a6e22e>newCondition</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> sync<span style=color:#f92672>.</span><span style=color:#a6e22e>newCondition</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div><p>上面我们把<code>ReentranLock</code>的主要结构，罗列出来。、</p><ul><li>首先定义了一个Sync属性sync</li><li>接下来是Sync的内部类，Sync继承自<code>AbstractQueuedSynchronizer</code></li><li>然后是两个Sync的子类，分别是非公平锁和公平锁的实现</li><li>接下来是两个构造方法，可以看到，默认是使用的非公平锁</li><li>然后就是实现自Lock接口的方法，可以看到方法都是最终调用了sync，也就是我们前面说的，<code>ReentranLock</code>借助于AQS实现了<code>Lock</code>。</li></ul><p>我们看到<code>ReentranLock</code>的几个方法中，都是调用的Sync的相关方法，下面我们就来看一下Sync和它的两个子类<code>NonfairSync</code>与<code>FairSync</code>:</p><h2 id=sync内部类>Sync内部类<a hidden class=anchor aria-hidden=true href=#sync内部类>#</a></h2><p><code>Sync</code>继承自<code>AbstractQueuedSynchronizer</code>,并重写了<code>tryRelease</code>和<code>isHeldExclusively</code>方法。独占模式要求的另一个方法<code>tryAcquire</code>，由他的子类<code>NonfairSync</code>和<code>FairSync</code>分别实现。</p><p>看到这里，我们可以知道什么，<span style=color:red>那就是非公平锁和公平锁只在获取锁上有区别，在释放锁的上没有任何区别</span></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Sync</span> <span style=color:#66d9ef>extends</span> AbstractQueuedSynchronizer <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lock</span><span style=color:#f92672>();</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Performs non-fair tryLock.  tryAcquire is implemented in
</span><span style=color:#75715e>     * subclasses, but both need nonfair try for trylock method.
</span><span style=color:#75715e>     */</span>
    <span style=color:#75715e>//注释说到， tryAcquire在子类中实现，但是tryLock是使用nofair的，所以放到了父类中
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>nonfairTryAcquire</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> acquires<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>final</span> Thread current <span style=color:#f92672>=</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> getState<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>//如果当前没有线程持有，则直接尝试获取一次，不管后面后又没其他线程再等待
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>compareAndSetState<span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> acquires<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
                setExclusiveOwnerThread<span style=color:#f92672>(</span>current<span style=color:#f92672>);</span>
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>//判断是否为锁重入
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>current <span style=color:#f92672>==</span> getExclusiveOwnerThread<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>//记录重入
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>int</span> nextc <span style=color:#f92672>=</span> c <span style=color:#f92672>+</span> acquires<span style=color:#f92672>;</span>
            <span style=color:#75715e>//判断int overflow的情况，所以最大的重入次数为int的最大值
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>nextc <span style=color:#f92672>&lt;</span> 0<span style=color:#f92672>)</span> <span style=color:#75715e>// overflow
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Maximum lock count exceeded&#34;</span><span style=color:#f92672>);</span>
            setState<span style=color:#f92672>(</span>nextc<span style=color:#f92672>);</span>
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>//尝试释放锁
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryRelease</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> releases<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> getState<span style=color:#f92672>()</span> <span style=color:#f92672>-</span> releases<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>()</span> <span style=color:#f92672>!=</span> getExclusiveOwnerThread<span style=color:#f92672>())</span>
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalMonitorStateException<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>boolean</span> free <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
        <span style=color:#75715e>//如通c == 0，表示所有的锁都释放完了
</span><span style=color:#75715e></span>        <span style=color:#75715e>//则设置持有锁线程为null
</span><span style=color:#75715e></span>        <span style=color:#75715e>//返回释放锁成功
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            free <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
            setExclusiveOwnerThread<span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>//如果c != 0 则表示发生了锁重入，只是里层释放了锁
</span><span style=color:#75715e></span>        <span style=color:#75715e>//返回没有完全释放锁
</span><span style=color:#75715e></span>        setState<span style=color:#f92672>(</span>c<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> free<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isHeldExclusively</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// While we must in general read state before owner,
</span><span style=color:#75715e></span>        <span style=color:#75715e>// we don&#39;t need to do so to check if current thread is owner
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> getExclusiveOwnerThread<span style=color:#f92672>()</span> <span style=color:#f92672>==</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>// 省略掉一些不太重要的方法。。。。
</span><span style=color:#75715e></span><span style=color:#f92672>}</span></code></pre></div><p>下面在看<code>NonfairSync</code>这个子类</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Sync object for non-fair locks
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NonfairSync</span> <span style=color:#66d9ef>extends</span> Sync <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> serialVersionUID <span style=color:#f92672>=</span> 7316153563782823691L<span style=color:#f92672>;</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * performs lock.  Try immediate barge, backing up to normal
</span><span style=color:#75715e>     * acquire on failure.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lock</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//非公平锁上来就先尝试获取一次,就是这里体现了不公平，
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>compareAndSetState<span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> 1<span style=color:#f92672>))</span>
            setExclusiveOwnerThread<span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>());</span>
        <span style=color:#66d9ef>else</span>
            <span style=color:#75715e>//如果没有获取成功,通过acquire方法，加入队列中等待
</span><span style=color:#75715e></span>            acquire<span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryAcquire</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> acquires<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> nonfairTryAcquire<span style=color:#f92672>(</span>acquires<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div><p>在看一下<code>FairSync</code>这个子类</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Sync object for fair locks
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FairSync</span> <span style=color:#66d9ef>extends</span> Sync <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> serialVersionUID <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>3000897897090466540L<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lock</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        acquire<span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Fair version of tryAcquire.  Don&#39;t grant access unless
</span><span style=color:#75715e>     * recursive call or no waiters or is first.
</span><span style=color:#75715e>     */</span>
    <span style=color:#75715e>//公平锁的tryAcquire和非公平锁的差别就是，非公平锁会直接尝试一次CAS获取锁
</span><span style=color:#75715e></span>    <span style=color:#75715e>//而公平锁则会先判断一下等待队列是不是为空。
</span><span style=color:#75715e></span>    <span style=color:#75715e>//如果都尝试获取失败，之后的处理逻辑都是一样的
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryAcquire</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> acquires<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>final</span> Thread current <span style=color:#f92672>=</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> getState<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>//如果队列为空，或者当前线程已经处于队列的最前，则尝试一次通过CAS获取锁
</span><span style=color:#75715e></span>            <span style=color:#75715e>//否则不获取
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>hasQueuedPredecessors<span style=color:#f92672>()</span> <span style=color:#f92672>&amp;&amp;</span>
                compareAndSetState<span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> acquires<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
                setExclusiveOwnerThread<span style=color:#f92672>(</span>current<span style=color:#f92672>);</span>
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>//判断重入的逻辑
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>current <span style=color:#f92672>==</span> getExclusiveOwnerThread<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>int</span> nextc <span style=color:#f92672>=</span> c <span style=color:#f92672>+</span> acquires<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>nextc <span style=color:#f92672>&lt;</span> 0<span style=color:#f92672>)</span>
                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Maximum lock count exceeded&#34;</span><span style=color:#f92672>);</span>
            setState<span style=color:#f92672>(</span>nextc<span style=color:#f92672>);</span>
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>//获取锁失败，并且不是重入，则tryAcquire失败
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div><h3 id=公平锁和非公平锁在获取锁时的区别>公平锁和非公平锁在获取锁时的区别<a hidden class=anchor aria-hidden=true href=#公平锁和非公平锁在获取锁时的区别>#</a></h3><p>我们看到<code>NonfairSync</code>和<code>FairSync</code>都是只有两个方法，<code>tryAcquire</code>和<code>lock</code>方法。其中<code>tryAcquire</code>方法是实现自AQS。
那么公平锁和非公平锁的区别就体现在，这两个类，对着两个方法的实现上。</p><p>我们先看<code>tryAcquire</code>方法的区别。
- <code>NonfairSync</code>是直接调用的父类的<code>nonfairTryAcquire</code>方法，它呢不会管当前有没有其他线程再等待，只要当前没有线程持有，就尝试获取一次
- <code>FairSync</code>是会先判断是否有其他线程再等待，只有没有线程等待或者它本身就是最前面的节点的时候，才会尝试获取。</p><p>我们再看<code>lock</code>方法
- <code>NonfairSync</code>,上来直接使用CAS，尝试获取一次，获取不到则调用AQS的<code>acquire</code>方法，在<code>acquire</code>方法中会调用<code>NonfairSync</code>的<code>tryAcquire</code>，如果仍然失败，加入到等待队列中。
- <code>FairSync</code>,直接调用父类AQS的<code>acquire</code>方法，在<code>acquire</code>方法中会调用<code>FairSync</code>的<code>tryAcquire</code>)，如果失败，加入到等待队列中。</p><p>我们看到公平锁和非公平锁的区别就在，非公平锁不会管现在又没有线程在等待，而是直接尝试获取。</p><h3 id=nonfairtryacquire方法为何定义在父类>nonfairTryAcquire方法为何定义在父类<a hidden class=anchor aria-hidden=true href=#nonfairtryacquire方法为何定义在父类>#</a></h3><p>看这个方法名称<code>nonfairTryAcquire</code>,感觉应该写在子类<code>NonfairSync</code>中会比较合适,这里会写到父类中呢？方法的注释中写到</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Performs non-fair tryLock.  tryAcquire is implemented in
</span><span style=color:#75715e> * subclasses, but both need nonfair try for trylock method.
</span><span style=color:#75715e> */</span></code></pre></div><p><code>执行非公平的tryLock。 tryAcquire在子类中实现。但两者都需要非公平的trylock方法。</code>
意思是在调用<code>Lock.tryLock()</code>方法的时候，都会用到<code>nonfairTryAcquire</code>,所以需要写到父类中。</p><p>那么为什么<code>tryLock</code>都要用非公平的<code>nonfairTryAcquire</code>呢？</p><p>我们再来看一下<code>tryLock</code>方法的注释</p><p><img src=/img/trylock.png alt></p><p>注释中写到，
- 在当前没有线程持有这个锁的时候，那么<code>tryLock</code>方法就可以立即抢占这个锁，即使使用的公平锁的策略。这种行为在有些情况下能够带来更好的性能，尽管它会破坏公平性。
- 如果不想破坏公平性，那么可以使用<code>tryLock(0, TimeUnit.SECONDS)</code>方法。</p><h3 id=公平锁和非公平锁的性能对比>公平锁和非公平锁的性能对比<a hidden class=anchor aria-hidden=true href=#公平锁和非公平锁的性能对比>#</a></h3><p>上面我们说到<code>tryLock</code>方法一直使用非公平的方式尝试获取锁，是因为非公平锁的性能要更好。那下面我们来分析一下原因和验证一下</p><ul><li>因为公平锁在获取锁时，永远是等待时间最长的线程获取到锁，这样当线程T1释放锁以后，如果还想继续再获取锁，它也得去同步队列尾部排队，这样就会频繁的发生线程的上下文切换，当线程越多，对CPU的损耗就会越严重。</li><li>而且在唤醒队首的线程后，线程不会立即执行，而是需要等待CPU分配时间片，才能获取到锁。</li><li>而非公平锁，是有机会跳过等待队列，和等待CPU分配时间片的这个情况的，所以性能会好一些。</li><li>非公平锁性能虽然优于公平锁，但是会存在导致线程饥饿的情况。在最坏的情况下，可能存在某个线程一直获取不到锁。不过相比性能而言，饥饿问题可以暂时忽略。</li></ul><p>下面我们通过代码来验证一下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FairVsNonFairLock</span> <span style=color:#f92672>{</span>

    <span style=color:#75715e>// 公平锁
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Lock fairLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock<span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
    <span style=color:#75715e>// 非公平锁
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Lock nonFairLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock<span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
    <span style=color:#75715e>// 计数器
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> fairCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
    <span style=color:#75715e>// 计数器
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> nonFairCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> threadCount <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;公平锁耗时:   &#34;</span> <span style=color:#f92672>+</span> testFairLock<span style=color:#f92672>(</span>threadCount<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; ms&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;非公平锁耗时: &#34;</span> <span style=color:#f92672>+</span> testNonFairLock<span style=color:#f92672>(</span>threadCount<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; ms&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>testFairLock</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> threadNum<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
        CountDownLatch countDownLatch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch<span style=color:#f92672>(</span>threadNum<span style=color:#f92672>);</span>
        <span style=color:#75715e>// 创建threadNum个线程，让其以公平锁的方式，对fairCount进行自增操作
</span><span style=color:#75715e></span>        List<span style=color:#f92672>&lt;</span>Thread<span style=color:#f92672>&gt;</span> fairList <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> threadNum<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
            fairList<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> j <span style=color:#f92672>&lt;</span> 10000<span style=color:#f92672>;</span> j<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
                    fairLock<span style=color:#f92672>.</span><span style=color:#a6e22e>lock</span><span style=color:#f92672>();</span>
                    fairCount<span style=color:#f92672>++;</span>
                    fairLock<span style=color:#f92672>.</span><span style=color:#a6e22e>unlock</span><span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span>
                countDownLatch<span style=color:#f92672>.</span><span style=color:#a6e22e>countDown</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}));</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>long</span> startTime <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Thread thread <span style=color:#f92672>:</span> fairList<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            thread<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>// 让所有线程执行完
</span><span style=color:#75715e></span>        countDownLatch<span style=color:#f92672>.</span><span style=color:#a6e22e>await</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>return</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>()</span> <span style=color:#f92672>-</span> startTime<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>testNonFairLock</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> threadNum<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
        CountDownLatch countDownLatch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch<span style=color:#f92672>(</span>threadNum<span style=color:#f92672>);</span>
        <span style=color:#75715e>// 创建threadNum个线程，让其以非公平锁的方式，对nonFairCountCount进行自增操作
</span><span style=color:#75715e></span>        List<span style=color:#f92672>&lt;</span>Thread<span style=color:#f92672>&gt;</span> nonFairList <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> threadNum<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
            nonFairList<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> j <span style=color:#f92672>&lt;</span> 10000<span style=color:#f92672>;</span> j<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
                    nonFairLock<span style=color:#f92672>.</span><span style=color:#a6e22e>lock</span><span style=color:#f92672>();</span>
                    nonFairCount<span style=color:#f92672>++;</span>
                    nonFairLock<span style=color:#f92672>.</span><span style=color:#a6e22e>unlock</span><span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span>
                countDownLatch<span style=color:#f92672>.</span><span style=color:#a6e22e>countDown</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}));</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>long</span> startTime <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Thread thread <span style=color:#f92672>:</span> nonFairList<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            thread<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>// 让所有线程执行完
</span><span style=color:#75715e></span>        countDownLatch<span style=color:#f92672>.</span><span style=color:#a6e22e>await</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>return</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>()</span> <span style=color:#f92672>-</span> startTime<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div><ul><li><p>线程数为1,跑3次</p><pre><code>公平锁耗时:   4 ms
非公平锁耗时: 2 ms
-----
公平锁耗时:   5 ms
非公平锁耗时: 3 ms
-----
公平锁耗时:   6 ms
非公平锁耗时: 3 ms</code></pre></li><li><p>线程数为5，跑3次</p><pre><code>公平锁耗时:   337 ms
非公平锁耗时: 11 ms
------
公平锁耗时:   497 ms
非公平锁耗时: 11 ms
------
公平锁耗时:   421 ms
非公平锁耗时: 13 ms</code></pre></li><li><p>线程数为10，跑3次</p><pre><code>公平锁耗时:   991 ms
非公平锁耗时: 22 ms
------
公平锁耗时:   903 ms
非公平锁耗时: 31 ms
------
公平锁耗时:   768 ms
非公平锁耗时: 18 ms</code></pre></li></ul><p>我们看到随着线程数的增加，非公平锁的性能要明显高于非公平锁了。所以这应该就是<code>ReentranLock</code>默认使用非公平锁的原因了。
其实我们看<code>synchronized</code>的源码，它也是非公平锁。</p><h2 id=独占式同步状态获取和释放>独占式同步状态获取和释放<a hidden class=anchor aria-hidden=true href=#独占式同步状态获取和释放>#</a></h2><p>我们先来看一下获取同步状态的方法调用流程</p><p><img src=/img/acquire.png alt></p><p>调用<code>ReentranLock</code>的<code>lock</code>方法，调用的是<code>FairSync</code>或者<code>NonfairSync</code>的<code>lock()</code>方法。
- NonfairSync会先尝试CAS获取一次，如果获取失败则调用AQS的<code>acquire()</code>方法
- FairSync则是直接调用AQS的<code>acquire</code>方法。
- <code>acquire</code>方法中，首先会调用<code>FairSync</code>或者<code>NonfairSync</code>的<code>tryAcquire()</code>方法
- 如果<code>tryAcquire()</code>失败，则会进入等待队列中。</p><p>下面我们一个方法一个方法的分析，先来看<code>acquire()</code>。</p><h2 id=加锁逻辑>加锁逻辑<a hidden class=anchor aria-hidden=true href=#加锁逻辑>#</a></h2><h3 id=acquire方法>acquire方法<a hidden class=anchor aria-hidden=true href=#acquire方法>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Acquires in exclusive mode, ignoring interrupts.  Implemented
</span><span style=color:#75715e> * by invoking at least once {@link #tryAcquire},
</span><span style=color:#75715e> * returning on success.  Otherwise the thread is queued, possibly
</span><span style=color:#75715e> * repeatedly blocking and unblocking, invoking {@link
</span><span style=color:#75715e> * #tryAcquire} until success.  This method can be used
</span><span style=color:#75715e> * to implement method {@link Lock#lock}.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * @param arg the acquire argument.  This value is conveyed to
</span><span style=color:#75715e> *        {@link #tryAcquire} but is otherwise uninterpreted and
</span><span style=color:#75715e> *        can represent anything you like.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>acquire</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> arg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>tryAcquire<span style=color:#f92672>(</span>arg<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span>
        acquireQueued<span style=color:#f92672>(</span>addWaiter<span style=color:#f92672>(</span>Node<span style=color:#f92672>.</span><span style=color:#a6e22e>EXCLUSIVE</span><span style=color:#f92672>),</span> arg<span style=color:#f92672>))</span>
        <span style=color:#75715e>//自我中断，用来传递线程在获取锁的过程中被中断的状态
</span><span style=color:#75715e></span>        selfInterrupt<span style=color:#f92672>();</span>
<span style=color:#f92672>}</span></code></pre></div><ul><li>注释中提到，这个方法是忽略中断的。也就是说线程在获取锁的过程中，无法通过调用线程的<code>interrupt()</code>方法中断获取锁的行为。</li><li>会至少调用一次<code>tryAcquire()</code>方法，如果获取成功则返回。</li><li>所以说，如果一个线程是第一获取锁的线程，那么它会直接获取成功，并不会创建节点，只有第二个线程来获取，才会创建节点，然后加入等待队列。</li><li>如果失败线程会进入等待队列。</li><li>在队列中获取到锁之后会返回，<ul><li>如果返回true则表示线程在获取锁过程中被调用过中断，则需要调用<code>selfInterrupt()</code>重新中断一下自己，把中断状态传传出来</li><li>如果返回false则表示没有被调用过中断。</li></ul></li></ul><h3 id=addwaiter封装线程为node节点>addWaiter封装线程为Node节点<a hidden class=anchor aria-hidden=true href=#addwaiter封装线程为node节点>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e>  * Creates and enqueues node for current thread and given mode.
</span><span style=color:#75715e>  *
</span><span style=color:#75715e>  * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
</span><span style=color:#75715e>  * @return the new node
</span><span style=color:#75715e>  */</span>
 <span style=color:#66d9ef>private</span> Node <span style=color:#a6e22e>addWaiter</span><span style=color:#f92672>(</span>Node mode<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
     <span style=color:#75715e>//构建新的node节点
</span><span style=color:#75715e></span>     Node node <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>(),</span> mode<span style=color:#f92672>);</span>
     <span style=color:#75715e>// Try the fast path of enq; backup to full enq on failure
</span><span style=color:#75715e></span>     <span style=color:#75715e>//这里进行一次快速入队，而不是直接走完整的入队方法的考虑是
</span><span style=color:#75715e></span>     <span style=color:#75715e>//完整入队操作，是通过死循环，然后调用CAS来实现的。JVM或者操作系统，在处理循环的时候，需要很多额外的资源和开销，
</span><span style=color:#75715e></span>     <span style=color:#75715e>//所以先进行一次单独的CAS操作，如果成功的话，就能节省掉死循环的开销,如果不成功再使用enq，也不会有太大的开销
</span><span style=color:#75715e></span>     Node pred <span style=color:#f92672>=</span> tail<span style=color:#f92672>;</span>
     <span style=color:#75715e>//如果尾节点不为空，把当前节点的前置节点设置为尾节点
</span><span style=color:#75715e></span>     <span style=color:#75715e>//这里入队的时候，先尝试快速入队
</span><span style=color:#75715e></span>     <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>pred <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
         <span style=color:#75715e>//先和前面的节点建立联系，保证从后面遍历的时候，能够遍历到所有的节点
</span><span style=color:#75715e></span>         node<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> pred<span style=color:#f92672>;</span>
         <span style=color:#75715e>//使用CAS设置当前节点为尾节点
</span><span style=color:#75715e></span>         <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>compareAndSetTail<span style=color:#f92672>(</span>pred<span style=color:#f92672>,</span> node<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
             <span style=color:#75715e>//如果设置成功，把前置节点的next指向当前节点
</span><span style=color:#75715e></span>             pred<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> node<span style=color:#f92672>;</span>
             <span style=color:#66d9ef>return</span> node<span style=color:#f92672>;</span>
         <span style=color:#f92672>}</span>
     <span style=color:#f92672>}</span>
     <span style=color:#75715e>//如果CAS失败，或者尾结点为空，则需要进入完整的入队逻辑。
</span><span style=color:#75715e></span>     <span style=color:#75715e>//CAS失败，则说明，有另一个线程进入了队列，并成为了尾结点。
</span><span style=color:#75715e></span>     enq<span style=color:#f92672>(</span>node<span style=color:#f92672>);</span>
     <span style=color:#66d9ef>return</span> node<span style=color:#f92672>;</span>
 <span style=color:#f92672>}</span></code></pre></div><ul><li>首先通过当前线程构建一个Node节点</li><li>然后判断如果尾节点不为空，则尝试一次快速入队(通过单次CAS操作)<ul><li><span style=color:red>这里有一点需要注意，就是快速入队的时候，是先设置的<code>node.prev = pred</code>,然后在设置的<code>pred.next = node</code>，包括enq里面的操作也是，这里是有原因的，下面我们会详细的分析一下</span></li></ul></li><li>如果快速入队失败，则调用<code>enq(node)</code>,执行完整的入队操作</li></ul><h3 id=enq完整入队>enq完整入队<a hidden class=anchor aria-hidden=true href=#enq完整入队>#</a></h3><p>我们说他是一个完整入队逻辑的原因是，它在for循环里，执行CAS操作，直到成功加入队列才会跳出循环</p><p>这种操作也叫做 <code>slow path</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Inserts node into queue, initializing if necessary. See picture above.
</span><span style=color:#75715e> * @param node the node to insert
</span><span style=color:#75715e> * @return node&#39;s predecessor
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>private</span> Node <span style=color:#a6e22e>enq</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> Node node<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
        Node t <span style=color:#f92672>=</span> tail<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>t <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// Must initialize
</span><span style=color:#75715e></span>            <span style=color:#75715e>//走到这里的话说明，说明Node还没有初始化，需要创建一个节点，当做头结点
</span><span style=color:#75715e></span>            <span style=color:#75715e>//初始化的时候，只有一个节点，所以这个节点既是头结点又是尾结点
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>compareAndSetHead<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Node<span style=color:#f92672>()))</span>
                tail <span style=color:#f92672>=</span> head<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>//当初始化完成之后，会继续循环，直到把当前节点设置为尾结点。
</span><span style=color:#75715e></span>            node<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> t<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>compareAndSetTail<span style=color:#f92672>(</span>t<span style=color:#f92672>,</span> node<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
                t<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> node<span style=color:#f92672>;</span>
                <span style=color:#66d9ef>return</span> t<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div><ul><li>如果当前队列为空，或者快速入队失败，则会执行完整的入队逻辑</li><li>完整入队的其实就是循环调用快速入队的逻辑，直到成功。</li><li>如果当前队列为空，这时候需要先把头结点创建出来，然后下次循环的时候，在把真正的节点加入到头结点的后面。</li><li><span style=color:red>所以，头结点是被第二个获取锁的线程，获取锁失败的时候，创建的。</span></li></ul><h3 id=acquirequeued方法>acquireQueued方法<a hidden class=anchor aria-hidden=true href=#acquirequeued方法>#</a></h3><p>这个方法就是线程等待队列中获取锁，在这个方法中，线程会不断的进行<code>尝试获取->挂起->唤醒->尝试获取</code>知道获得锁</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Acquires in exclusive uninterruptible mode for thread already in
</span><span style=color:#75715e> * queue. Used by condition wait methods as well as acquire.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * @param node the node
</span><span style=color:#75715e> * @param arg the acquire argument
</span><span style=color:#75715e> * @return {@code true} if interrupted while waiting 如果在等待过程，被中断过，获取锁之后返回true
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>acquireQueued</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> Node node<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> arg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>boolean</span> failed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>boolean</span> interrupted <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>final</span> Node p <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span><span style=color:#a6e22e>predecessor</span><span style=color:#f92672>();</span>
            <span style=color:#75715e>//如果这个节点的前置节点是头结点，那么则表示这个节点有获取锁的资格。
</span><span style=color:#75715e></span>            <span style=color:#75715e>//顺便说一下，在AQS的队列中个，头结点是一个虚节点，是为了在编程的时候更为方便，或者可以理解为已经获取到锁的节点
</span><span style=color:#75715e></span>            <span style=color:#75715e>//调用tryAcquire()尝试获取锁
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>p <span style=color:#f92672>==</span> head <span style=color:#f92672>&amp;&amp;</span> tryAcquire<span style=color:#f92672>(</span>arg<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
                setHead<span style=color:#f92672>(</span>node<span style=color:#f92672>);</span>
                <span style=color:#75715e>//把之前的头结点踢出等待队列
</span><span style=color:#75715e></span>                p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> <span style=color:#75715e>// help GC
</span><span style=color:#75715e></span>                failed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
                <span style=color:#75715e>//获取锁成功之后，返回中断状态
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span> interrupted<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
            <span style=color:#75715e>//如果没有资格获取锁，或者获取锁失败
</span><span style=color:#75715e></span>            <span style=color:#75715e>//则需要通过shouldParkAfterFailedAcquire()，判断这个线程是否需要挂起
</span><span style=color:#75715e></span>            <span style=color:#75715e>//如果当前节点，是头结点的下一个节点，那么shouldParkAfterFailedAcquire()方法会返回false，直接跳过挂起，再执行上面的逻辑获取一次
</span><span style=color:#75715e></span>            <span style=color:#75715e>//如果需要park，则调用parkAndCheckInterrupt()方法，进行挂起。
</span><span style=color:#75715e></span>            <span style=color:#75715e>//线程在挂起的时候，有两种唤醒的方式，
</span><span style=color:#75715e></span>            <span style=color:#75715e>// 1.使用unpark
</span><span style=color:#75715e></span>            <span style=color:#75715e>// 2.使用线程中断方法
</span><span style=color:#75715e></span>            <span style=color:#75715e>//如果这个线程是被线程中断方法唤醒，那么会把这个interrupted变量置为true
</span><span style=color:#75715e></span>            <span style=color:#75715e>//然后在等到这个线程获取到锁的时候，会把这个中断状态传出去
</span><span style=color:#75715e></span>            <span style=color:#75715e>//这里使用到的一个特性就是，被park挂起的线程，当线程中断的时候不会抛出线程中断异常
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>shouldParkAfterFailedAcquire<span style=color:#f92672>(</span>p<span style=color:#f92672>,</span> node<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span>
                <span style=color:#75715e>//如果返回true，表示是被中断唤醒的
</span><span style=color:#75715e></span>                parkAndCheckInterrupt<span style=color:#f92672>())</span>
                <span style=color:#75715e>//记录中断状态
</span><span style=color:#75715e></span>                interrupted <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>failed<span style=color:#f92672>)</span>
            cancelAcquire<span style=color:#f92672>(</span>node<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div><ul><li>线程被封装成Node节点加入等待队列之后，进入这个方法。</li><li>首先判断这个节点的前置节点是不是头结点，<span style=color:red>也就是说，这个节点是等待队列的第二个节点</span>。</li><li>在AQS中，头结点是虚节点(或者理解为持有锁的节点)，只有第二个节点是有资格去获取锁。</li><li>然后调用<code>tryAcquire</code>尝试获取锁，获取成功后<ul><li>会调用setHeader()</li><li>把当前线程的Node节点设置为头结点</li><li>并踢掉之前的头结点</li><li>并返回线程的中断状态，记录线程在获取锁的过程中，有没有被中断过。</li></ul></li><li>如果不是第二个节点，或者<code>tryAcquire</code>失败，会调用<code>shouldParkAfterFailedAcquire</code>,判断线程是否应该挂起。</li></ul><h3 id=shouldparkafterfailedacquire方法>shouldParkAfterFailedAcquire方法<a hidden class=anchor aria-hidden=true href=#shouldparkafterfailedacquire方法>#</a></h3><p>在这个方法中，会根据节点的状态判断线程是否要被挂起,并在某些情况下修改前置节点状态</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Checks and updates status for a node that failed to acquire.
</span><span style=color:#75715e> * Returns true if thread should block. This is the main signal
</span><span style=color:#75715e> * control in all acquire loops.  Requires that pred == node.prev.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * @param pred node&#39;s predecessor holding status
</span><span style=color:#75715e> * @param node the node
</span><span style=color:#75715e> * @return {@code true} if thread should block
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>//在这个方法判断node节点的线程，是否需要挂起
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>shouldParkAfterFailedAcquire</span><span style=color:#f92672>(</span>Node pred<span style=color:#f92672>,</span> Node node<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>//获取前置节点的waitStatus
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> ws <span style=color:#f92672>=</span> pred<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ws <span style=color:#f92672>==</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>SIGNAL</span><span style=color:#f92672>)</span>
        <span style=color:#75715e>//如果pred节点的waitStatus是SIGNAL，则表示pred节点正在等待别的通知来唤醒
</span><span style=color:#75715e></span>        <span style=color:#75715e>//所以肯定还轮不到node节点来获取锁，直接挂起
</span><span style=color:#75715e></span>        <span style=color:#75715e>//这个节点已经设置了请求释放资源的时候来通知它的状态，所以可以安全的挂起
</span><span style=color:#75715e></span>        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * This node has already set status asking a release
</span><span style=color:#75715e>         * to signal it, so it can safely park.
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ws <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * Predecessor was cancelled. Skip over predecessors and
</span><span style=color:#75715e>         * indicate retry.
</span><span style=color:#75715e>         */</span>

        <span style=color:#75715e>//waitStatus &gt; 0 只有可能是canceled，那么则踢出pred节点
</span><span style=color:#75715e></span>        <span style=color:#75715e>//让node的prev指向 pred节点的prev，就相当于跳过了pred节点。
</span><span style=color:#75715e></span>        <span style=color:#75715e>//这里是一个循环操作，表示会把前面所有的连续的cancel状态的节点都踢出队列
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
            node<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> pred <span style=color:#f92672>=</span> pred<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>pred<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>);</span>
        pred<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> node<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>/*
</span><span style=color:#75715e>         * waitStatus must be 0 or PROPAGATE.  Indicate that we
</span><span style=color:#75715e>         * need a signal, but don&#39;t park yet.  Caller will need to
</span><span style=color:#75715e>         * retry to make sure it cannot acquire before parking.
</span><span style=color:#75715e>         */</span>
        <span style=color:#75715e>//执行到这里的话，waitStatus只能是0 或者 PROPAGATE。
</span><span style=color:#75715e></span>        <span style=color:#75715e>//这时候会把前置节点的waitStatus 状态修改为signal，这样在下次循环的时候，当前节点就会执行挂起操作了
</span><span style=color:#75715e></span>        <span style=color:#75715e>//每个节点的waitStatus都是由他的下一个节点来修改的
</span><span style=color:#75715e></span>        compareAndSetWaitStatus<span style=color:#f92672>(</span>pred<span style=color:#f92672>,</span> ws<span style=color:#f92672>,</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>SIGNAL</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span></code></pre></div><ul><li>首先拿到当前节点的前置节点的<code>waitStatus</code>,然后开始判断</li><li>如果<code>waitStatus</code>是<code>SIGNAL</code>状态,则返回true，<code>表示新加入的节点已经告诉了他的前置节点，当前置节点释放的时候唤醒他，他可以放心的挂起了;</code>下面的逻辑都会返回false，表示不会挂起。</li><li>如果<code>waitStatus</code>大于0，也就是<code>CANCELLED</code>状态，表示当前节点的前置节点已经被取消了，那么将这个前置节点踢出等待队列</li><li>并会把前面所有的连续的<code>CANCELLED</code>状态的节点都踢出队列</li><li>如果<code>waitStatus</code>不大于0，那么则<code>waitStatus</code>是0,或者<code>PROPAGATE</code>，那么就把它设置为<code>SIGNAL</code>状态，这样会再次尝试获取一次,如果仍然没有获取到，则会在下次判断<code>shouldParkAfterFailedAcquire</code>的时候，因为前置节点是<code>SIGNAL</code>而挂起。</li></ul><p>这里的重点是对于<code>SIGNAL</code>状态的理解，我们再来看一下Java的解释，Java的解释有三个地方</p><p><img src=/img/signal.png alt></p><p><img src=/img/signal2.png alt></p><p><img src=/img/waitQueue.png alt></p><p>最后一张图片的注释中提到，AQS中使用和CLH相同的策略，在节点中保存一个后置节点的控制信息。当一个节点的前置节点被释放的时候，通知它的后置节点。
<code>只有SIGNAL状态表示的是对后置节点的操作，其他状态都是表示的本身节点的状态</code></p><p>上面提到，一个节点的<code>waitStatus</code>设置为<code>SIGNAL</code>，表示的是这个节点的后置节点正在或者将要被阻塞，也可以理解为这个节点的后置节点等待它前面节点唤醒(这个更符合<code>SIGNAL</code>的定义)。
- 所以说，一个节点的处于<code>SIGNAL</code>状态，表示的是，当这个节点被释放的时候，需要唤醒它的后续节点。
- 那么既然这个状态会指导对后置节点的操作，所以这个状态的变更也应该有后置节点来触发。
- 所以每个节点的初始状态都是0，当有后置节点加入队列的时候，会在后置节点执行<code>shouldParkAfterFailedAcquire</code>的时候，把这个节点的状态修改为<code>SIGNAL</code></p><h3 id=parkandcheckinterrupt挂起并检查中断状态>parkAndCheckInterrupt挂起并检查中断状态<a hidden class=anchor aria-hidden=true href=#parkandcheckinterrupt挂起并检查中断状态>#</a></h3><p>当经过上面的方法判断，线程需要被挂起，就会执行这个方法，使用<code>LockSupport.park()</code>挂起当前线程。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>//当线程被unpark()唤醒，或者被终端的时候返回当前线程的中断状态
</span><span style=color:#75715e>//使用park()挂起的一个特点就是，当调用线程的中断方法时，不会抛出中断异常，同时也会保留线程的中断状态
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>parkAndCheckInterrupt</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>park</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
    <span style=color:#75715e>//这里注意一下，如果是通过调用线程interrupt方法唤醒了挂起的线程。
</span><span style=color:#75715e></span>    <span style=color:#75715e>//这里调用的是 interrupted(),这个方法的作用是，返回当前线程的中断状态，然后清除掉中断状态，
</span><span style=color:#75715e></span>    <span style=color:#75715e>//这里为什么必须要清除中断状态呢？
</span><span style=color:#75715e></span>    <span style=color:#75715e>//因为线程被唤醒之后，需要再次去尝试获取锁，但是并不能保证肯定成功，如果失败了，还需要继续挂起。
</span><span style=color:#75715e></span>    <span style=color:#75715e>//如果这里不清除中断状态，那么下次获取失败，需要再次挂起的时候，因为线程有中断状态，所以LockSuport.park()会失效，则导致线程无法挂起。
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>interrupted</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span></code></pre></div><ul><li>线程被挂起后就会停在这行代码，等待被唤醒后继续向下执行。</li><li>线程被唤醒后，继续执行<code>return Thread.interrupted();</code>,返回当前线程的中断状态，然后清除掉中断状态。</li><li>所以如果线程是被中断方法唤醒的，<code>parkAndCheckInterrupt()</code>方法就会返回true，然后在<code>acquireQueued()</code>方法中就会执行<code>interrupted = true;</code>记录下来中断状态。</li><li>然后在线程成功获得锁之后，将记录的中断状态返回出去。</li></ul><h2 id=释放锁逻辑>释放锁逻辑<a hidden class=anchor aria-hidden=true href=#释放锁逻辑>#</a></h2><h3 id=release方法释放锁>release方法释放锁<a hidden class=anchor aria-hidden=true href=#release方法释放锁>#</a></h3><p>当调用<code>lock.unlock()</code>方法释放锁时，会调用<code>AQS</code>的<code>release()</code>方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Releases in exclusive mode.  Implemented by unblocking one or
</span><span style=color:#75715e> * more threads if {@link #tryRelease} returns true.
</span><span style=color:#75715e> * This method can be used to implement method {@link Lock#unlock}.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * @param arg the release argument.  This value is conveyed to
</span><span style=color:#75715e> *        {@link #tryRelease} but is otherwise uninterpreted and
</span><span style=color:#75715e> *        can represent anything you like.
</span><span style=color:#75715e> * @return the value returned from {@link #tryRelease}
</span><span style=color:#75715e> *
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>release</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> arg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>//tryRelease，尝试释放
</span><span style=color:#75715e></span>    <span style=color:#75715e>//这里如果返回false，则表示发生了锁重入，这里只是释放了里层的，外层仍然还在持有锁
</span><span style=color:#75715e></span>    <span style=color:#75715e>//如果返回true，则表示所有的重入都已经被释放了，可以唤醒下面的等待线程了
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>tryRelease<span style=color:#f92672>(</span>arg<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
        Node h <span style=color:#f92672>=</span> head<span style=color:#f92672>;</span>
        <span style=color:#75715e>//如果有head不为null，则表示至少有一个线程进入过等待队列，因为head节点是在后面线程进入等待队列的时候初始化的
</span><span style=color:#75715e></span>        <span style=color:#75715e>//h.waitStatus != 0,为什么要加这个判断呢?
</span><span style=color:#75715e></span>        <span style=color:#75715e>//因为waitStatus=0，是一个节点的初始状态，如果头结点处于这个状态，说明要么后面加入的线程还在执行中，没有执行到 shouldParkAfterFailedAcquire方法中的compareAndSetWaitStatus
</span><span style=color:#75715e></span>        <span style=color:#75715e>//要么就是后面的线程在执行到 shouldParkAfterFailedAcquire()方法之前，已经超时了
</span><span style=color:#75715e></span>        <span style=color:#75715e>//这两种情况都不需要唤醒
</span><span style=color:#75715e></span>        <span style=color:#75715e>//第一种线程正在执行的情况，后面的线程会在第二次循环的时候tryAcquire(),能够拿到锁
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>h <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> h<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span>
            unparkSuccessor<span style=color:#f92672>(</span>h<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span></code></pre></div><p>1.首先调用<code>Sync.tryRelease()</code>方法，尝试释放锁</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>//尝试释放锁
</span><span style=color:#75715e></span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryRelease</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> releases<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> getState<span style=color:#f92672>()</span> <span style=color:#f92672>-</span> releases<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>()</span> <span style=color:#f92672>!=</span> getExclusiveOwnerThread<span style=color:#f92672>())</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalMonitorStateException<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>boolean</span> free <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
    <span style=color:#75715e>//如通c == 0，表示所有的锁都释放完了
</span><span style=color:#75715e></span>    <span style=color:#75715e>//则设置持有锁线程为null
</span><span style=color:#75715e></span>    <span style=color:#75715e>//返回释放锁成功
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        free <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
        setExclusiveOwnerThread<span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>//如果c != 0 则表示发生了锁重入，只是里层释放了锁
</span><span style=color:#75715e></span>    <span style=color:#75715e>//返回没有完全释放锁
</span><span style=color:#75715e></span>    setState<span style=color:#f92672>(</span>c<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>return</span> free<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span></code></pre></div><p>这里主要处理了一个重入的逻辑，只有所有重入的锁都释放完毕了，才返回true。
<code>值得注意的是，这个tryRelease()方法是写在Sync这个类中的，而不是FairSycn和NonFairSync，也就可以说明公平锁和非公平锁的释放逻辑是完全相同的</code>。</p><p>2.<code>tryRelease()</code>返回true，则需要判断是否需要唤醒后面的节点。</p><p>我们来看这里的判断条件</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Node h <span style=color:#f92672>=</span> head<span style=color:#f92672>;</span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>h <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> h<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span>
    unparkSuccessor<span style=color:#f92672>(</span>h<span style=color:#f92672>);</span>
<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span></code></pre></div><ul><li><code>head!=null</code>,因为head节点是，后续线程获取锁失败后，加入队列时创建的，所以<code>head!=null</code>就表示有后续节点。</li><li><code>h.waitStatus != 0</code>一个节点的初始状态是0，在后置节点第一次判断是否应该挂起的时候，会把他的前置节点状态修改为<code>SIGNAL</code>也就是1。所以<code>h.waitStatus=0</code>就可以理解为<ul><li>后置节点正在执行中，还没有挂起，所以不需要唤醒</li><li>后置节点调用的是带有超时的<code>acquire()</code>方法，已经等待所超时了</li><li>这几种情况都不需要唤醒。</li></ul></li></ul><h3 id=unparksuccessor唤醒后置节点>unparkSuccessor唤醒后置节点<a hidden class=anchor aria-hidden=true href=#unparksuccessor唤醒后置节点>#</a></h3><p>当一个线程释放了锁，并且确定有线程需要唤醒的时候，会调用<code>unparkSuccessor()</code>唤醒后面的节点。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Wakes up node&#39;s successor, if one exists.
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * @param node the node
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unparkSuccessor</span><span style=color:#f92672>(</span>Node node<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * If status is negative (i.e., possibly needing signal) try
</span><span style=color:#75715e>     * to clear in anticipation of signalling.  It is OK if this
</span><span style=color:#75715e>     * fails or if status is changed by waiting thread.
</span><span style=color:#75715e>     */</span>
     <span style=color:#75715e>// 这里传入的是头结点，头结点已经完成了唤醒后面节点的操作，那么则可以把这个状态改回默认值了
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> ws <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ws <span style=color:#f92672>&lt;</span> 0<span style=color:#f92672>)</span>
        compareAndSetWaitStatus<span style=color:#f92672>(</span>node<span style=color:#f92672>,</span> ws<span style=color:#f92672>,</span> 0<span style=color:#f92672>);</span>

    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Thread to unpark is held in successor, which is normally
</span><span style=color:#75715e>     * just the next node.  But if cancelled or apparently null,
</span><span style=color:#75715e>     * traverse backwards from tail to find the actual
</span><span style=color:#75715e>     * non-cancelled successor.
</span><span style=color:#75715e>     */</span>
    <span style=color:#75715e>/**
</span><span style=color:#75715e>     这里从后向前遍历的原因是，在新节点node入队的时候，都是先设置
</span><span style=color:#75715e>     node.prev = p（之前的tail节点）(也就是说从后向前可以遍历整个队里了)
</span><span style=color:#75715e>     然后通过cas，把node节点设置为tail
</span><span style=color:#75715e>     如果cas成功，才设置 p.next = node (这时候从head节点向后才能遍历整个队列)
</span><span style=color:#75715e>
</span><span style=color:#75715e>     以为cas成功，和 设置 p.next = node 这两个步骤并不是原子的
</span><span style=color:#75715e>     所以如果cas成功之后，在执行 p.next = node之前，unparkSuccessor()被调用。
</span><span style=color:#75715e>     线程开始从前往后遍历，这时候 p.next 还是为null的，所以就不能遍历队列所有的节点了。
</span><span style=color:#75715e>     **/</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * 因为Node是一个双向队列
</span><span style=color:#75715e>     * 在插入新节点的时候，总是会先把新节点和前面的节点(也就是之前的尾结点)建立联系。node.prev = p;
</span><span style=color:#75715e>     * 然后当新节点成功的成为尾结点之后，才会把 前面的节点和新节点建立联系 p.next = node;
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * 这是可以理解，也是必须的。
</span><span style=color:#75715e>     * 因为 p(之前的尾结点)，已经是队列中确定的一个节点，如果在node节点确定加入队列之前就修改了p节点的next属性，如果node能在紧接着的
</span><span style=color:#75715e>     * cas操作成功还好，如果cas失败，那就是让p.next指向了一个队列外的节点。这肯定是不行的。
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * 所以说要么把入队和与p.next = node 这两个操作搞成一个原子操作(但是这样肯定会影响性能)，要么想出一个方案，在节点已经入队(已经成为了尾结点)，但是前面节点p还没和node节点建立联系的情况下，也能顺利的遍历所有的节点。
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * 先执行node.prev = p，就是解决这个问题的办法。
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * 所以导致了这里必须采用从队尾开始遍历的方案
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     */</span>

    <span style=color:#75715e>//拿到头结点的下一个节点
</span><span style=color:#75715e></span>    Node s <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>;</span>
    <span style=color:#75715e>//如果为空，或者状态是已取消，则从尾结点开始找到一个非canceled状态的节点，然后唤醒它
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>s <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        s <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Node t <span style=color:#f92672>=</span> tail<span style=color:#f92672>;</span> t <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> t <span style=color:#f92672>!=</span> node<span style=color:#f92672>;</span> t <span style=color:#f92672>=</span> t<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span><span style=color:#f92672>)</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>t<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>&lt;=</span> 0<span style=color:#f92672>)</span>
                s <span style=color:#f92672>=</span> t<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>//如果找到了合适的节点，则使用unpark()方法唤醒
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>s <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
        LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>unpark</span><span style=color:#f92672>(</span>s<span style=color:#f92672>.</span><span style=color:#a6e22e>thread</span><span style=color:#f92672>);</span>
<span style=color:#f92672>}</span></code></pre></div><ul><li>首先拿到头结点的后置节点，如果为空或者状态是<code>CANCELLED</code>则从队列中寻找一个可用的节点</li><li><span style=color:red>这里有一个关键就是从队尾开始寻找</span></li><li>如果找到了，则使用<code>LockSupport.unpark(s.thread)</code>唤醒指定的线程。</li><li>我们上面说过了，线程挂起之后就会停在 <code>parkAndCheckInterrupt()</code>方法的<code>LockSupport.park()</code>这里，被唤醒后会继续向下执行，就会继续在<code>acquireQueued()</code>方法中尝试获取锁</li><li>不断的循环<code>尝试获取->失败->挂起->唤醒->尝试获取</code>这个过程，直到成功获取。</li></ul><h2 id=condition>Condition<a hidden class=anchor aria-hidden=true href=#condition>#</a></h2><p>在详细分析<code>Condition</code>代码之前，先说一下我对<code>Condition</code>的理解</p><p><span style=color:red>如果说<code>Lock</code>和<code>synchronized</code>相对应，那么<code>Conditon</code>就是和<code>wait()</code>,<code>notify</code>相对应</span></p><p>Condition为Lock提供了条件等待的功能，即<code>一个线程达到某个条件时暂停执行，直到另一个线程通知它再次执行</code>。因为这个条件需要在不同的线程中被访问，所以对Conditon对象的操作必须受到<code>Lock</code>的保护，也就是必要获得<code>Lock</code>，才能执行。</p><h3 id=condition原理>Condition原理<a hidden class=anchor aria-hidden=true href=#condition原理>#</a></h3><ul><li>当一个线程A获取了lock锁，调用了<code>condition.await()</code>,会释放锁，并构建一个Node对象(和AQS中的一样)节点状态为<code>CONDITION,-2</code>，加入到Condition的条件队列中。</li><li>然后让当前线程挂起，等待唤醒，或者挂起一段时间自己唤醒</li><li>当另一个线程B获取了lock锁，调用了<code>condition.signal()</code>,会找到<code>condition</code>条件队列中的第一个节点，把它加入到AQS的同步队列中，然后唤醒Node中的线程。</li><li>线程A被唤醒后，会调用<code>acquireQueued</code>再次尝试获取锁</li></ul><p><code>Condition</code>的原理其实和JVM对于<code>wait</code>和<code>notify</code>的实现很类似。我们对比着来说明一下。</p><p><code>wait</code>和<code>notify</code>执行大致流程</p><ul><li>线程A在同步代码块中，调用<code>wait()</code>方法，释放锁，并把A线程加入到<code>waitSet</code>中</li><li>线程挂起，等待唤醒，或者挂起一段时间自己唤醒</li><li>线程B，在同步代码块中，调用<code>notify</code>方法，会唤醒<code>waitSet</code>队列中的第一个节点，然后把这个节点加入到<code>cxq</code>队列中</li><li>线程A就在cxq队列中等待再次获取锁。</li></ul><p>我们看到Condition和<code>wait</code>于<code>notify</code>的流程基本完全相同</p><ul><li><code>Condition队列</code>对应着<code>waitSet</code></li><li><code>同步队列</code>对应着<code>cxq</code></li><li>另外他们对于中断的处理也是很相似的。因为线程的挂起可以被中断方法唤醒，所以他们在被唤醒之后，都需要检查自己是不是被中断唤醒的</li><li>如果是被中断唤醒，需要有对应的处理，<ul><li><code>wait</code>是直接抛出<code>中断异常</code></li><li>condition可以根据一定的策略，可以选择<code>抛出中断异常</code>和<code>自我中断</code></li></ul></li></ul><p>有了这些概念，下面我们来进入代码分析</p><h3 id=代码分析>代码分析<a hidden class=anchor aria-hidden=true href=#代码分析>#</a></h3><h4 id=await>await()<a hidden class=anchor aria-hidden=true href=#await>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>// Condition中的操作实际上是，先把自己加入到一个 Condition队列中。
</span><span style=color:#75715e>// 然后释放掉获取的AQS锁，然后通过LockSupport挂起，等待其他线程唤醒，唤醒后在继续获取锁
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>await</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>interrupted</span><span style=color:#f92672>())</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InterruptedException<span style=color:#f92672>();</span>
    <span style=color:#75715e>//加入一个新节点到，condition队列中
</span><span style=color:#75715e></span>    Node node <span style=color:#f92672>=</span> addConditionWaiter<span style=color:#f92672>();</span>
    <span style=color:#75715e>//释放锁，想一下wait和notify，别人在唤醒你的时候，也需要获得锁，如果你不释放别人怎么唤醒你呢，所以这里要释放锁
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> savedState <span style=color:#f92672>=</span> fullyRelease<span style=color:#f92672>(</span>node<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>int</span> interruptMode <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
    <span style=color:#75715e>//在调用signal的时候会把节点加入到同步队列中，
</span><span style=color:#75715e></span>    <span style=color:#75715e>//如果已经在队列中了，那说明已经有人唤醒了它，把它加入到了队列中，那么直接获取锁就可以了。
</span><span style=color:#75715e></span>    <span style=color:#75715e>//如果还没有加入队列，则需要挂起，等待唤醒的时候被加入到队列中。
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>isOnSyncQueue<span style=color:#f92672>(</span>node<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
        LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>park</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>interruptMode <span style=color:#f92672>=</span> checkInterruptWhileWaiting<span style=color:#f92672>(</span>node<span style=color:#f92672>))</span> <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span>
            <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>//然后在进入等待队列中获取锁
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>acquireQueued<span style=color:#f92672>(</span>node<span style=color:#f92672>,</span> savedState<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span> interruptMode <span style=color:#f92672>!=</span> THROW_IE<span style=color:#f92672>)</span>
        interruptMode <span style=color:#f92672>=</span> REINTERRUPT<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>node<span style=color:#f92672>.</span><span style=color:#a6e22e>nextWaiter</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#75715e>// clean up if cancelled
</span><span style=color:#75715e></span>        unlinkCancelledWaiters<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>interruptMode <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span>
        <span style=color:#75715e>//根据interruptMode执行抛出异常或者自我中断
</span><span style=color:#75715e></span>        reportInterruptAfterWait<span style=color:#f92672>(</span>interruptMode<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span></code></pre></div><h4 id=addconditionwaiter>addConditionWaiter<a hidden class=anchor aria-hidden=true href=#addconditionwaiter>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Adds a new waiter to wait queue.
</span><span style=color:#75715e> * @return its new wait node
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>//这里之所以在向队列中添加节点的时候，没有采用AQS中的那种 形式
</span><span style=color:#75715e>//是因为在调用 condition.await()的时候，需要先通过 lock.lock()获取到锁，所以在这一步不会存在竞争
</span><span style=color:#75715e>//Condition队列是一个全新的队列
</span><span style=color:#75715e>//这里因为没有并发问题，所以写起来就明朗多了，不用各种的CAS操作来保证并发安全了
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> Node <span style=color:#a6e22e>addConditionWaiter</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Node t <span style=color:#f92672>=</span> lastWaiter<span style=color:#f92672>;</span>
    <span style=color:#75715e>// If lastWaiter is cancelled, clean out.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>t <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> t<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>!=</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>CONDITION</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//删除所有cancelled状态的节点
</span><span style=color:#75715e></span>        unlinkCancelledWaiters<span style=color:#f92672>();</span>
        t <span style=color:#f92672>=</span> lastWaiter<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>//构建节点，初始即为Condition状态。
</span><span style=color:#75715e></span>    <span style=color:#75715e>//如果当前队列为空，就设置为头结点
</span><span style=color:#75715e></span>    <span style=color:#75715e>//如果不为空，就设置为当前tail的next
</span><span style=color:#75715e></span>    <span style=color:#75715e>//最后设置当前节点为尾节点
</span><span style=color:#75715e></span>    Node node <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>(),</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>CONDITION</span><span style=color:#f92672>);</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>t <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
        firstWaiter <span style=color:#f92672>=</span> node<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>else</span>
        t<span style=color:#f92672>.</span><span style=color:#a6e22e>nextWaiter</span> <span style=color:#f92672>=</span> node<span style=color:#f92672>;</span>
    lastWaiter <span style=color:#f92672>=</span> node<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>return</span> node<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span></code></pre></div><h4 id=fullyrelease>fullyRelease<a hidden class=anchor aria-hidden=true href=#fullyrelease>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>//这里的fully的意思是，不管发生了几次重入，全部一次性释放
</span><span style=color:#75715e>//所以这里是直接拿到当前的state，然后一次性release
</span><span style=color:#75715e>//并唤醒同步队列中的一个节点
</span><span style=color:#75715e></span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fullyRelease</span><span style=color:#f92672>(</span>Node node<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>boolean</span> failed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>int</span> savedState <span style=color:#f92672>=</span> getState<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>release<span style=color:#f92672>(</span>savedState<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
            failed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
            <span style=color:#66d9ef>return</span> savedState<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalMonitorStateException<span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>failed<span style=color:#f92672>)</span>
            node<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>=</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>CANCELLED</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div><h4 id=checkinterruptwhilewaiting>checkInterruptWhileWaiting<a hidden class=anchor aria-hidden=true href=#checkinterruptwhilewaiting>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Checks for interrupt, returning THROW_IE if interrupted
</span><span style=color:#75715e> * before signalled, REINTERRUPT if after signalled, or
</span><span style=color:#75715e> * 0 if not interrupted.
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 在唤醒钱被中断，则返回 throw_ie,唤醒后中断则返回 REINTERRUPT
</span><span style=color:#75715e> * 没有中断，返回0
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>checkInterruptWhileWaiting</span><span style=color:#f92672>(</span>Node node<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>interrupted</span><span style=color:#f92672>()</span> <span style=color:#f92672>?</span>
        <span style=color:#f92672>(</span>transferAfterCancelledWait<span style=color:#f92672>(</span>node<span style=color:#f92672>)</span> <span style=color:#f92672>?</span> THROW_IE <span style=color:#f92672>:</span> REINTERRUPT<span style=color:#f92672>)</span> <span style=color:#f92672>:</span>
        0<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span></code></pre></div><h4 id=signal>signal<a hidden class=anchor aria-hidden=true href=#signal>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signal</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>//首先判断是不是持有锁，如果没有持有锁，则抛出监视器状态异常
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>isHeldExclusively<span style=color:#f92672>())</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalMonitorStateException<span style=color:#f92672>();</span>
    <span style=color:#75715e>//唤醒Condition队列的第一个节点
</span><span style=color:#75715e></span>    Node first <span style=color:#f92672>=</span> firstWaiter<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>first <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
        doSignal<span style=color:#f92672>(</span>first<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>//唤醒wait队列上的第一个节点
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSignal</span><span style=color:#f92672>(</span>Node first<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//判断是否队列上只有一个节点，如果是，就将lastWaiter 设置为null
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span> <span style=color:#f92672>(</span>firstWaiter <span style=color:#f92672>=</span> first<span style=color:#f92672>.</span><span style=color:#a6e22e>nextWaiter</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
            lastWaiter <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
        <span style=color:#75715e>//既然要唤醒第一个节点，唤醒后，直接将第一个节点从队列上移除。
</span><span style=color:#75715e></span>        first<span style=color:#f92672>.</span><span style=color:#a6e22e>nextWaiter</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
        <span style=color:#75715e>//通过transferForSignal将节点加入到同步队列中。如果加入失败了，则重新取出wait队列的第一个节点并唤醒。
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>transferForSignal<span style=color:#f92672>(</span>first<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span>
            <span style=color:#f92672>(</span>first <span style=color:#f92672>=</span> firstWaiter<span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
<span style=color:#f92672>}</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>//将wait节点放入到同步队列中
</span><span style=color:#75715e></span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>transferForSignal</span><span style=color:#f92672>(</span>Node node<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * If cannot change waitStatus, the node has been cancelled.
</span><span style=color:#75715e>     */</span>
     <span style=color:#75715e>//这里如果CAS失败，说明当前节点的状态已经不是CONDITION，说明已经被其他线程唤醒了。
</span><span style=color:#75715e></span>     <span style=color:#75715e>//返回false之后，外层是一个循环，会继续取出wait队列的第一个节点，继续执行唤醒操作
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>compareAndSetWaitStatus<span style=color:#f92672>(</span>node<span style=color:#f92672>,</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>CONDITION</span><span style=color:#f92672>,</span> 0<span style=color:#f92672>))</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Splice onto queue and try to set waitStatus of predecessor to
</span><span style=color:#75715e>     * indicate that thread is (probably) waiting. If cancelled or
</span><span style=color:#75715e>     * attempt to set waitStatus fails, wake up to resync (in which
</span><span style=color:#75715e>     * case the waitStatus can be transiently and harmlessly wrong).
</span><span style=color:#75715e>     */</span>
     <span style=color:#75715e>//将当前节点加入到同步队列，注意，这里enq返回值返回的是假如队列节点的前一个节点，也就是原队尾节点。
</span><span style=color:#75715e></span>    Node p <span style=color:#f92672>=</span> enq<span style=color:#f92672>(</span>node<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>int</span> ws <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span><span style=color:#f92672>;</span>
    <span style=color:#75715e>//这里的判断非常巧妙，我们知道，我们把Node节点从wait移动到同步队列，如果我们把节点线程唤醒，是没有问题的。
</span><span style=color:#75715e></span>    <span style=color:#75715e>//因为唤醒后执行到await中的acquireQueued的时候，会被重新挂起，但是这样比较耗费性能，是没有必要的。
</span><span style=color:#75715e></span>    <span style=color:#75715e>//所以这里进行了判断，如果移入到同步队列后，发现原尾节点的状态大于0，或者将尾节点的状态改为SIGNAL的时候失败了，才会唤醒。并在acquireQueued中重新整理同步队列并重新挂起。
</span><span style=color:#75715e></span>    <span style=color:#75715e>//这里不挂起是没有问题的，因为在acquireQueued挂起前判断，如果当前节点是第一个节点，会直接获取锁。如果中断唤醒了，或继续从await挂起的地方继续执行，会继续在acquireQueued的地方重新挂起。
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ws <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>compareAndSetWaitStatus<span style=color:#f92672>(</span>p<span style=color:#f92672>,</span> ws<span style=color:#f92672>,</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>SIGNAL</span><span style=color:#f92672>))</span>
        LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>unpark</span><span style=color:#f92672>(</span>node<span style=color:#f92672>.</span><span style=color:#a6e22e>thread</span><span style=color:#f92672>);</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span></code></pre></div><h4 id=signalall>signalAll<a hidden class=anchor aria-hidden=true href=#signalall>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signalAll</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>isHeldExclusively<span style=color:#f92672>())</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalMonitorStateException<span style=color:#f92672>();</span>
    <span style=color:#75715e>//拿到wait队列，执行doSignalAll
</span><span style=color:#75715e></span>    Node first <span style=color:#f92672>=</span> firstWaiter<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>first <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
        doSignalAll<span style=color:#f92672>(</span>first<span style=color:#f92672>);</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>//理解了signal，理解这里的doSignalAll就很简单了。
</span><span style=color:#75715e>//就是遍历wait队列上的节点逐个顺序取出放入到同步队列中。
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSignalAll</span><span style=color:#f92672>(</span>Node first<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    lastWaiter <span style=color:#f92672>=</span> firstWaiter <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
        Node next <span style=color:#f92672>=</span> first<span style=color:#f92672>.</span><span style=color:#a6e22e>nextWaiter</span><span style=color:#f92672>;</span>
        first<span style=color:#f92672>.</span><span style=color:#a6e22e>nextWaiter</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
        transferForSignal<span style=color:#f92672>(</span>first<span style=color:#f92672>);</span>
        first <span style=color:#f92672>=</span> next<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>first <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
<span style=color:#f92672>}</span></code></pre></div><h2 id=重点问题总结>重点问题总结<a hidden class=anchor aria-hidden=true href=#重点问题总结>#</a></h2><p>下面的一些重点问题，其实在上面方法的部分中已经提到了，这里专门整理出来，也是为了更方便的查看，AQS中的细节很多，如果全部都去了解需要耗费太多的精力。</p><h3 id=为什么线程被唤醒之后要调用thread-interrupted-清除中断状态>为什么线程被唤醒之后要调用Thread.interrupted()清除中断状态<a hidden class=anchor aria-hidden=true href=#为什么线程被唤醒之后要调用thread-interrupted-清除中断状态>#</a></h3><p><a href=/blog/aqs/#parkandcheckinterrupt%e6%8c%82%e8%b5%b7%e5%b9%b6%e6%a3%80%e6%9f%a5%e4%b8%ad%e6%96%ad%e7%8a%b6%e6%80%81>parkAndCheckInterrupt挂起并检查中断状态</a>
我们在上面的这个标题中个，讨论了这个问题。
主要原因就是线程在被中断唤醒之后，去获取锁不一定会成功，如果失败了，还需要继续挂起，如果不清除中断状态，就会无法挂起了，所以这里必须要清除</p><h3 id=为什么需要调用selfinterrupt进行自我中断>为什么需要调用selfInterrupt进行自我中断<a hidden class=anchor aria-hidden=true href=#为什么需要调用selfinterrupt进行自我中断>#</a></h3><p>上面我们说到，线程在等待锁的状态下，被调用了中断。
- 在执行parkAndCheckInterrupt()方法后，会被清除掉线程的中断状态。
- 但是会在<code>acquireQueued</code>方法中记录下来被调用了中断的这个事情<code>interrupted = true;</code>
- 线程在获取到锁之后，会返回中断状态
- 如果这时候返回的是true，表示线程在这段时间内被中断过，但是线程的中断状态已经被清除了
- 所以需要调用<code>selfInterrupt</code>自我中断一下，设置中断状态，一遍后面的代码可能会有用到中断状态的地方。
- <span style=color:red>AQS在这里秉持的一个原则就是，我可以不响应中断，但是我不能报中断状态吞掉</span></p><h3 id=唤醒后置节点的时候为什么从tail开始遍历>唤醒后置节点的时候为什么从Tail开始遍历<a hidden class=anchor aria-hidden=true href=#唤醒后置节点的时候为什么从tail开始遍历>#</a></h3><p>这个问题我们在<a href=/blog/aqs/#unparksuccessor%e5%94%a4%e9%86%92%e5%90%8e%e7%bd%ae%e8%8a%82%e7%82%b9>unparksuccessor</a>的代码注释中有详细的说明。</p><h3 id=fast-path和slow-path>fast path和slow path<a hidden class=anchor aria-hidden=true href=#fast-path和slow-path>#</a></h3><p>在查看<code>synchronized</code>原码的时候就很多次看到<code>fast path</code>和<code>slow path</code>这两个词。这次又在AQS的代码中看到相关的概念，稍微有一点想法，尝试着解释一下。</p><p><code>fast path</code></p><ul><li>我忍为可以理解为一种，使用一种相对比较轻量级的方式来达成目标，但是不能保证一定成功。比如在AQS中这里的<code>fast path</code>指的就是一次CAS操作。</li></ul><p><code>slow path</code></p><p>-相对的slow path，就是指的一种重量级的方式，可以确保一定会成功。在AQS中，<code>slow path</code>指的就是循环调用CAS操作。操作系统在执行循环操作的时候，会需要一些额外的资源。</p><p>一般在编写过程中，可以先尝试使用一次<code>fast path</code>
- 如果成功了则节省了很多资源
- 如果失败了那么在调用<code>slow path</code>，比直接调用<code>slow path</code>只多出了一次<code>fast path</code>操作，消耗也可以接受。</p><h3 id=canceled节点>CANCELED节点<a hidden class=anchor aria-hidden=true href=#canceled节点>#</a></h3><p>这里我们讨论一下CANCELED状态节点的问题。</p><h4 id=canceled节点何时产生>CANCELED节点何时产生<a hidden class=anchor aria-hidden=true href=#canceled节点何时产生>#</a></h4><p>在代码里我们看到<code>CANCELED</code>被直接用到的地方只有两处代码
<img src=/img/canceled.png alt>
第二处调用的方法<code>fullyRelease</code>是Condition相关的，我们先不看，主要看第一个方法<code>cancelAcquire</code>。</p><p>我们看这个方法的名字就很清晰，表示取消获取锁，它在什么时候被调用呢?</p><p><img src=/img/cancelacquire.png alt>
我们看到它被调用的地方都很统一，就是在各种各样的获取锁方法中被调用。代码的逻辑也都很一致。
- 在方法中定义一个局部变量 fail = true；
- 在获取锁成功的时候设置 fail = false;
- 在finally代码块中判断fail，如果为true，则执行<code>cancelAcquire</code>方法。
这就表示，在获取锁的过程中，只要发生了任何意外情况导致获取锁失败了，像执行出现异常、获取锁超时、获取锁被中断(不响应中断的获取锁除外)都会执行到这个方法。</p><p>下面就来看一下这个方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancelAcquire</span><span style=color:#f92672>(</span>Node node<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>// Ignore if node doesn&#39;t exist
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>node <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
    <span style=color:#75715e>//将节点中的线程设置为null
</span><span style=color:#75715e></span>    <span style=color:#75715e>//设置该节点不关联任何线程，也就是虚节点
</span><span style=color:#75715e></span>    node<span style=color:#f92672>.</span><span style=color:#a6e22e>thread</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>

    <span style=color:#75715e>// Skip cancelled predecessors
</span><span style=color:#75715e></span>    <span style=color:#75715e>//跳过前面节点中状态为cancel的节点，把这个节点的前置节点引用指向一个不是cancel状态的节点(0,或者SIGNAL)
</span><span style=color:#75715e></span>    Node pred <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>pred<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span>
        node<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> pred <span style=color:#f92672>=</span> pred<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span><span style=color:#f92672>;</span>

    <span style=color:#75715e>// predNext is the apparent node to unsplice. CASes below will
</span><span style=color:#75715e></span>    <span style=color:#75715e>// fail if not, in which case, we lost race vs another cancel
</span><span style=color:#75715e></span>    <span style=color:#75715e>// or signal, so no further action is necessary.
</span><span style=color:#75715e></span>    Node predNext <span style=color:#f92672>=</span> pred<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>;</span>

    <span style=color:#75715e>// Can use unconditional write instead of CAS here.
</span><span style=color:#75715e></span>    <span style=color:#75715e>// After this atomic step, other Nodes can skip past us.
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Before, we are free of interference from other threads.
</span><span style=color:#75715e></span>    <span style=color:#75715e>//把当前节点的状态设置为取消
</span><span style=color:#75715e></span>    node<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>=</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>CANCELLED</span><span style=color:#f92672>;</span>

    <span style=color:#75715e>// If we are the tail, remove ourselves.
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 如果当前节点是尾结点，则修改当前节点的前置节点为新的尾结点
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>node <span style=color:#f92672>==</span> tail <span style=color:#f92672>&amp;&amp;</span> compareAndSetTail<span style=color:#f92672>(</span>node<span style=color:#f92672>,</span> pred<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//如果修改成功，然后把前置节点的next 设置为null,这时候前置节点已经是尾结点了，所以它没有next节点了
</span><span style=color:#75715e></span>        <span style=color:#75715e>//这一步成功失败，并不重要，如果失败，表示节点已经为null了，或者有新的节点加入，成为了它的next
</span><span style=color:#75715e></span>        compareAndSetNext<span style=color:#f92672>(</span>pred<span style=color:#f92672>,</span> predNext<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// If successor needs signal, try to set pred&#39;s next-link
</span><span style=color:#75715e></span>        <span style=color:#75715e>// so it will get one. Otherwise wake it up to propagate.
</span><span style=color:#75715e></span>        <span style=color:#75715e>//如果走到这里，说明要么当前节点不是tail节点
</span><span style=color:#75715e></span>        <span style=color:#75715e>//或者，在cas的时候node不是尾结点了，有新的线程加入成为了新的尾结点。
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> ws<span style=color:#f92672>;</span>
        <span style=color:#75715e>//首先判断node节点的前置节点是不是head,如果是则直接走else逻辑
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>pred <span style=color:#f92672>!=</span> head <span style=color:#f92672>&amp;&amp;</span>
            <span style=color:#75715e>//如果node的前置节点不是head
</span><span style=color:#75715e></span>            <span style=color:#75715e>//则判断waitStatus是不是signal
</span><span style=color:#75715e></span>                <span style=color:#75715e>//如果不是signal，则判断是不是非cancelled状态，如果是则cas把状态设置为signal
</span><span style=color:#75715e></span>            <span style=color:#75715e>//判断pred的线程不能为null
</span><span style=color:#75715e></span>            <span style=color:#f92672>((</span>ws <span style=color:#f92672>=</span> pred<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>SIGNAL</span> <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>ws <span style=color:#f92672>&lt;=</span> 0 <span style=color:#f92672>&amp;&amp;</span> compareAndSetWaitStatus<span style=color:#f92672>(</span>pred<span style=color:#f92672>,</span> ws<span style=color:#f92672>,</span> Node<span style=color:#f92672>.</span><span style=color:#a6e22e>SIGNAL</span><span style=color:#f92672>)))</span>
                <span style=color:#f92672>&amp;&amp;</span> pred<span style=color:#f92672>.</span><span style=color:#a6e22e>thread</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>//接下来的操作，我理解就是把node的前置节点和node的next节点，连接起来
</span><span style=color:#75715e></span>            Node next <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>;</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>next <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> next<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>&lt;=</span> 0<span style=color:#f92672>)</span>
                compareAndSetNext<span style=color:#f92672>(</span>pred<span style=color:#f92672>,</span> predNext<span style=color:#f92672>,</span> next<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>//如果是head的话那么现在队列的情况是   head -&gt; node -&gt; node1 -&gt; tail
</span><span style=color:#75715e></span>            <span style=color:#75715e>//这时候 node节点是cancel状态，那么就需要唤醒 node1节点
</span><span style=color:#75715e></span>            <span style=color:#75715e>//唤醒node1 需要传入的是node1的前置节点也就是node，所以 unparkSuccessor(node);
</span><span style=color:#75715e></span>            unparkSuccessor<span style=color:#f92672>(</span>node<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>

        <span style=color:#75715e>//为什么不是=null呢？
</span><span style=color:#75715e></span>        node<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> node<span style=color:#f92672>;</span> <span style=color:#75715e>// help GC
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div><ul><li>设置Node的thread为null</li><li>把当前节点的挂到一个非<code>CANCELLED</code>状态的节点上，并没有清除,因为这这里并没有设置<code>pred.next = node</code></li><li>设置当前Node状态为<code>CANCELLED</code></li><li>拿到前置节点的后置节点，一般来说正常情况下，就是Node节点</li><li>判断当前节点是不是尾节点</li><li>如果是尾节点，就把当前节点的前置节点设为尾节点<ul><li>如果设置成功，把前置节点(也就是当前的尾节点)的next设置为null(这一步失败了也没有关系)</li></ul></li><li>如果不是尾节点，或者设置尾节点失败(表示有新节点加入成为了新的尾节点)。执行else逻辑</li></ul><p>else中的逻辑判断比较复杂，我们单独来看一下</p><ul><li><p>首先如果Node节点的前置节点是Head节点,也就是下面这种情况，其中Node表示当前节点，Node节点为<code>CANCELLED</code>状态。本来正常情况下Node节点是下次被唤醒的节点，但是它取消了，那么就应该唤醒它的后置节点node1了。
唤醒它的后置节点后，后置节点会尝试获取锁，这时候如果之前持有锁的线程还没有释放，他会获取失败，然后在<code>shouldParkAfterFailedAcquire</code>方法中，把处于<code>CANCELLED</code>状态的节点移除队列
如果获取成功了，那么前面的节点肯定也会被排除队列了</p><pre><code>Head -&gt; cancelledNode -&gt; node1</code></pre></li><li><p>如果前置节点不是头结点，并且前置节点的状态不是<code>CANCELLED</code>,后面这些判断条件看看前置节点是不是<code>SIGNAL</code>状态，或者能不能设置为<code>SIGNAL</code>状态</p></li><li><p>如果可以，就把<code>CANCELLED</code>状态节点的后置节点和他的前置节点连接上。相当于把自己踢出队列</p><pre><code>Head -&gt; node1-&gt; cancelledNode -&gt; node2

Head -&gt; node1-&gt; node2</code></pre></li></ul><h4 id=cancelled节点何时被踢出>CANCELLED节点何时被踢出<a hidden class=anchor aria-hidden=true href=#cancelled节点何时被踢出>#</a></h4><p>大部分的踢出<code>CANCELLED</code>节点的操作都在<code>shouldParkAfterFailedAcquire</code>方法中完成。也就是这部分代码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ws <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Predecessor was cancelled. Skip over predecessors and
</span><span style=color:#75715e>     * indicate retry.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
        node<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> pred <span style=color:#f92672>=</span> pred<span style=color:#f92672>.</span><span style=color:#a6e22e>prev</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>pred<span style=color:#f92672>.</span><span style=color:#a6e22e>waitStatus</span> <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>);</span>
    pred<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> node<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span></code></pre></div><p>在JDK原码中有很多这种写法，看的有点蒙蒙的，我们把它拆解一下</p><pre><code>pred = pred.prev;
node.prev = pred;</code></pre><p>就是pred，往前挪一个节点，然后node.prev指向新的pred节点。
下面用图来表示一下，tail表示 node节点</p><p><img src=/img/kickcancel.png alt></p><ul><li>初始状态，pred指向node3，node.prev指向node3，</li><li>因为node3状态为 <code>cancelled</code>,所以pred向前挪一个,指向node2，同时node.prev指向node2</li><li>因为node2状态为 <code>cancelled</code>,所以pred向前挪一个,指向node1，同时node.prev指向node1</li><li>node1状态为<code>SIGNAL</code>,跳出循环，设置node1.next = node,把node2和node3排除队列</li></ul><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><p><a href=https://juejin.cn/post/6844903839062032398>java并发编程系列：牛逼的AQS（上）</a></p><p><a href=https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html>从ReentrantLock的实现看AQS的原理及应用</a></p><p><a href=https://juejin.cn/post/6844903985745231886>公平锁与非公平锁的对比</a></p><p><a href=https://blog.csdn.net/b_x_p/article/details/105168224>ReentrantLock Condition源码分析</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://balvboy.github.io/tags/aqs/>AQS</a></li><li><a href=https://balvboy.github.io/tags/reentranlock/>ReentranLock</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(六)- AQS on twitter" href="https://twitter.com/intent/tweet/?text=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%85%ad%29-%20AQS&url=https%3a%2f%2fbalvboy.github.io%2fblog%2faqs%2f&hashtags=AQS%2cReentranLock"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(六)- AQS on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbalvboy.github.io%2fblog%2faqs%2f&title=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%85%ad%29-%20AQS&summary=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%85%ad%29-%20AQS&source=https%3a%2f%2fbalvboy.github.io%2fblog%2faqs%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(六)- AQS on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbalvboy.github.io%2fblog%2faqs%2f&title=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%85%ad%29-%20AQS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(六)- AQS on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbalvboy.github.io%2fblog%2faqs%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(六)- AQS on whatsapp" href="https://api.whatsapp.com/send?text=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%85%ad%29-%20AQS%20-%20https%3a%2f%2fbalvboy.github.io%2fblog%2faqs%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(六)- AQS on telegram" href="https://telegram.me/share/url?text=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%85%ad%29-%20AQS&url=https%3a%2f%2fbalvboy.github.io%2fblog%2faqs%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//balvboy.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href=https://balvboy.github.io>ZhouYang's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button>
</a><link rel=stylesheet type=text/css href=/css/table.css><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script><script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>