<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java同步机制(四)-LockSupport | ZhouYang's Blog</title><meta name=keywords content="LockSupport,park,unpark,AQS"><meta name=description content="LockSupport"><meta name=author content="    &#34;zhouyang&#34;"><link rel=canonical href=https://balvboy.github.io/blog/locksupport/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.3f6a79d84dce1064322991082a04723d5157c86c73768c45927919cf00b4462f.css integrity="sha256-P2p52E3OEGQyKZEIKgRyPVFXyGxzdoxFknkZzwC0Ri8=" rel="preload stylesheet" as=style><link rel=icon href=https://balvboy.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://balvboy.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://balvboy.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://balvboy.github.io/img/favicon.ico><link rel=mask-icon href=https://balvboy.github.io/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-146899866-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Java同步机制(四)-LockSupport"><meta property="og:description" content="LockSupport"><meta property="og:type" content="article"><meta property="og:url" content="https://balvboy.github.io/blog/locksupport/"><meta property="og:image" content="https://balvboy.github.io/img/z.png"><meta property="article:published_time" content="2021-06-15T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-15T00:00:00+00:00"><meta property="og:site_name" content="Life is Fantastic"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://balvboy.github.io/img/z.png"><meta name=twitter:title content="Java同步机制(四)-LockSupport"><meta name=twitter:description content="LockSupport"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java同步机制(四)-LockSupport","name":"Java同步机制(四)-LockSupport","description":"LockSupport LockSupport是Java中实现同步的一个重要方式，LockSupport提供了阻塞线程和唤醒线程的功能。\nLockSupport中的方法 LockSupport中提供了一系列的park，unpark方法供我们进行挂起和唤醒。\npark和unpark 我们看到6个park方法，可以分为了3类分别是\n park() …","keywords":["LockSupport","park","unpark","AQS"],"articleBody":" LockSupport LockSupport是Java中实现同步的一个重要方式，LockSupport提供了阻塞线程和唤醒线程的功能。\nLockSupport中的方法 LockSupport中提供了一系列的park，unpark方法供我们进行挂起和唤醒。\npark和unpark 我们看到6个park方法，可以分为了3类分别是\n park() 一直阻塞 parkNanos() 阻塞指定的纳秒数 parkUntil() 阻塞到指定的时间，是时间的毫秒值  还有1个unpark方法\n unpark(Thread) 唤醒指定线程  Blocker 然后每一类方法，都有一个带有Object参数的版本。比如park(Object)方法。\n 获得了当前线程， 然后把传入的对象，通过Unsafe把对象设置到Thread中的parkObject属性。   然后会调用Unsafe的park方法挂起当前线程。 然后待线程被唤醒后，设置blocker为null  那设置和不设置的区别是什么呢? 这个Blocker对象是用来记录线程被阻塞时被谁阻塞的，主要用于线程监控和分析工具来定位原因的。\nLockSupport的使用 先用代码来展示一下LockSupport最简单的使用方式。\n@Test public void testPark() throws InterruptedException { Object parkObject = \"I am parkObject\"; Thread t1 = new Thread(() - { System.out.println(\"t1调用park\"); LockSupport.park(parkObject); System.out.println(\"t1被唤醒了\"); }); t1.start(); Thread.sleep(1000); Thread t2 = new Thread(() - { System.out.println( LockSupport.getBlocker(t1)); System.out.println(\"t2调用unpark\"); LockSupport.unpark(t1); }); t2.start(); } 执行结果是\nt1调用park t2调用unpark t1被唤醒了,阻塞了1003ms OK,其实上面的代码就能够展示出LockSupport的绝大部分场景的用法了。一个线程因为某些原因调用park方法阻塞，然后另一个线程在达到某些条件的时候，通过unpark唤醒这个线程。\n在LockSupport的注释中有这么一句话\n/** Additionally, {@code park} will return if the caller's thread was interrupted, and timeout versions are supported. The {@code park} method may also return at any other time, for \"no reason\", so in general must be invoked within a loop that rechecks conditions upon return. **/  意思是，park()方法会在调用线程被终端的时候返回。 park()方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法。\n这就意味着，当我们使用了LockSupport.park(),进行阻塞。当这个方法突然返回的时候，有可能并不是我们调用了unpark()方法导致的。 所以我们需要在循环代码中是否符合业务逻辑，只有确认了是我们自己调用了unpark()触发的才可以。\n所以我们看到AQS中对于LockSupport.park()的使用，都是在循环中使用的。\n简单理解LockSupport阻塞的原理 下面来简单的理解一下LockSupport的原理。\n每一个线程内部都有一个permit,许可证的概念 线程在初始化的时候，permit为0。 当在线程中调用LockSupport.park()方法的时候，会消耗掉一个permit。\n 如果此时线程中permit为0，线程就会挂起 如果此时permit为1，则park()方法会立刻返回，并消耗一个permit，线程内的permit变为0  调用LockSupport.unpark()方法的时候，会生产一个permit。如果该线程因为调用了park()方法而挂起，同时也会唤醒该线程。\n 不管调用多少次unpark,线程中permit的数量最多就是1。  通过上面描述，我们发现LockSupport的工作原理，很像一个信号量为1的Semaphore。 park为加锁，unpark为解锁。\nLockSupport和线程中断 除了unpark能唤醒park挂起的线程外，调用线程的interrupt()方法也能唤醒线程。 对于interrupt()方法，我们了解，\n 当一个线程处于sleep，或者wait的阻塞状态的时候。如果这个时候调用线程的interrupt方法，线程会抛出InterruptedException，并清除掉线程的中断状态。 如果线程处于运行状态，那么调用线程的interrupt()方法，则不会发生任何异常，只会把线程的中断状态设置为true。 如果使用interrupt()打断一个，通过park挂起的线程，线程会被唤醒，但是不会抛出异常，并且保留线程的中断状态。  而且如果一个线程的中断状态为true，就算没有permit，park()方法也会失效。 我们通过下面的代码来说明一下。\n@Test public void testInterruptAndPark() throws InterruptedException { Thread thread = new Thread(() - { System.out.println(\"自己中断\"); Thread.currentThread().interrupt(); System.out.println(\"打印线程中断状态：\" + Thread.currentThread().isInterrupted()); System.out.println(\"开始park\"); long st = System.currentTimeMillis(); LockSupport.park(); System.out.println(\"park结束,持续时间:\" + (System.currentTimeMillis() - st)); st = System.currentTimeMillis(); LockSupport.park(); System.out.println(\"park结束,持续时间:\" + (System.currentTimeMillis() - st)); }); thread.start(); Thread.sleep(100000); } 执行结果\n自己中断 打印线程中断状态：true 开始park park结束,持续时间:1 park结束,持续时间:0 我们在一个线程中，让它自己调用了interrupt方法，然后调用了两次park()方法，然后两次park()方法都失效了。 所以说线程的中断状态，会影响park()的挂起，下面我我们会从源码上来找一下原因。\n源码分析 park和unpark源码 LockSupport.park()方法调用的是本地方法。在JVM中最终调用的是Parker类的park方法，这个方法针对不同平台有不同的实现，这里我们主要看一下Linux平台下的实现。\n// thread.hpp class Thread { // OS data associated with the thread  OSThread* _osthread; // Platform-specific thread information  ParkEvent * _ParkEvent; // for synchronized(), wait  ParkEvent * _SleepEvent; // for Thread.sleep  // JSR166 per-thread parker  Parker* _parker; // for LockSupport::park  //... }; class JavaThread: public Thread { // 指向Java Thread实例, oop是HotSpot里指向一个Java level的实例, 一个gc对象.  oop _threadObj; // The Java level thread ,  JavaFrameAnchor _anchor; // Encapsulation of current java frame and it state  CompiledMethod* _deopt_nmethod; // CompiledMethod that is currently being deoptimized  //  volatile JavaThreadState _thread_state; //... }; 我们先来看一下JVM中Thread的定义,Thread 类里有两个 ParkEvent 和一个 Parker, 其实 ParkEvent 和 Parker 实现和功能十分类似。\n _ParkEvent 是实现 synchronized 关键字，wait，notify 用的， _SleepEvent 是给 Thread.sleep 用的。 _parker 是用来实现 J.U.C 的 LockSupport的park/unpark (阻塞 / 唤醒)。\npublic: Parker() : PlatformParker() { _counter = 0 ; FreeNext = NULL ; AssociatedWith = NULL ; }  我们再来看一下Parker的结构。 我们主要看_counter这个字段，这个其实就是我们上面说到的permit。\n// src/hotspot/os/posix/os_posix.cpp //isAbsolute 表示后面的时间是绝对时间还是相对时间 void Parker::park(bool isAbsolute, jlong time) { // 设置_counter为0，并且判断原值  // 如果别的线程已经unpark了我.  // 这里没有使用锁机制，需要Atomic::xchg和barrier保证lock-free代码的正确.  // We depend on Atomic::xchg() having full barrier semantics  // since we are doing a lock-free update to _counter.  if (Atomic::xchg(0, \u0026_counter)  0) return; Thread* thread = Thread::current(); assert(thread-is_Java_thread(), \"Must be JavaThread\"); JavaThread *jt = (JavaThread *)thread; // 如果线程被中断，直接返回  if (Thread::is_interrupted(thread, false)) { return; } // safepoint region相关, 我对细节不详.  // safepoint region大致的了解, 见RednaxelaFX的回答https://www.zhihu.com/question/29268019  ThreadBlockInVM tbivm(jt); // 再次判断线程是否被中断，如果没有被中断，尝试获得互斥锁，如果获取失败，直接返回  // 如果别的线程正在unpark我, 而持有了mutex, 我先返回了,没有必要在_mutex上等  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) { return; } // 如果别的线程已经unblock了我, no wait needed  // 已经拿到了mutex, 所以不需要和前面一样Atomic::xchg了.因为已经拿到了锁  int status; if (_counter  0) { _counter = 0; status = pthread_mutex_unlock(_mutex); OrderAccess::fence(); return; } // 记录线程的状态  OSThreadWaitState osts(thread-osthread(), false /* not Object.wait() */); jt-set_suspend_equivalent(); // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()  // 这一坨, 就是block自己这个线程了.(Java层当前执行的线程)  if (time == 0) { _cur_index = REL_INDEX; // arbitrary choice when not timed  status = pthread_cond_wait(\u0026_cond[_cur_index], _mutex); } else { _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX; status = pthread_cond_timedwait(\u0026_cond[_cur_index], _mutex, \u0026absTime); } _cur_index = -1; // 已经从block住状态中恢复返回了, 把_counter设0.  _counter = 0; status = pthread_mutex_unlock(_mutex); // 要保证多线程的正确性要十二分小心  // 这里的memory fence 是一个lock addl 指令, 加上compiler_barrier  // 保证_counter = 0 是对调用unlock线程是可见的.  // Paranoia to ensure our locked and lock-free paths interact  // correctly with each other and Java-level accesses.  OrderAccess::fence(); // 已经醒过来, 但如果有别人在suspend我,那么继续suspend自己.  // If externally suspended while waiting, re-suspend  if (jt-handle_special_suspend_equivalent_condition()) { jt-java_suspend_self(); } }// src/hotspot/os/posix/os_linux.cpp void Parker::unpark() { int status = pthread_mutex_lock(_mutex); assert_status(status == 0, status, \"invariant\"); const int s = _counter; _counter = 1; // must capture correct index before unlocking  int index = _cur_index; status = pthread_mutex_unlock(_mutex); assert_status(status == 0, status, \"invariant\"); // s记录的是unpark之前的_counter数，如果s  if (s  1 \u0026\u0026 index != -1) { // 发信号唤醒线程  status = pthread_cond_signal(\u0026_cond[index]); assert_status(status == 0, status, \"invariant\"); } } 简单总结一下这两个流程，(不会分析每一行代码的作用)\npark\n 首先把_counter设置为0，并判断如果之前为1的话直接返回 检查线程的中断状态，如果处于中断状态，则直接返回 设置线程状态 调用pthread相关函数阻塞线程（线程进入阻塞状态，等待阻塞超时或者被唤醒） 阻塞超时结束，或者被唤醒之后，设置_counter为0  unpark\n 把_counter设置为1 判断_counter原值，如果小于1，则表示有可能有线程在阻塞（这里并不是一定，因为初始的时候_counter为0）  interrupt源码 我们上面说到，interrupt()方法，也能唤醒通过park阻塞的线程，那我们就来看一下interrupt的源码.\n//hotspot\\src\\os\\linux\\vm\\os_linux.cpp void os::interrupt(Thread* thread) { assert(Thread::current() == thread || Threads_lock-owned_by_self(), \"possibility of dangling Thread pointer\"); // 获取  OSThread* osthread = thread-osthread(); if (!osthread-interrupted()) { osthread-set_interrupted(true); // More than one thread can get here with the same value of osthread,  // resulting in multiple notifications. We do, however, want the store  // to interrupted() to be visible to other threads before we execute unpark().  OrderAccess::fence(); ParkEvent * const slp = thread-_SleepEvent ; if (slp != NULL) slp-unpark() ; } // For JSR166. Unpark even if interrupt status already was set  if (thread-is_Java_thread()) ((JavaThread*)thread)-parker()-unpark(); ParkEvent * ev = thread-_ParkEvent ; if (ev != NULL) ev-unpark() ; }  每一个Java线程都与一个osthread一一对应，如果相应的os线程没有被中断，则会设置osthread的interrupt标志位为true。 并唤醒线程的_SleepEvent 随后唤醒线程的parker和ParkEvent。  总结 通过查看源码，我们对LockSupport的实现原理有了进一步的了解。\n 当调用LockSupport.park()的时候，最终调用的是JVM中Thread对象Parker变量的park()方法 在park()方法中，会判断_counter属性（也就是permit）,然后检查线程的中断状态 然后会调用pthread_cond_wait,pthread_cond_timedwait阻塞线程 当调用LockSupport.park(Thread)的时候，最终调用的是JVM中Thread对象Parker变量的unpark()方法 在unpark()方法中，也会判断_counter属性，然后通过pthread_cond_signal来环境阻塞的线程。 当调用了线程的interrupt方法，最终执行的是os::interrupt()(Linux平台) 在os::interrupt()方法中，会设置线程的中断状态，并对JVM线程持有的SleepEvent,Parker,_ParkEvent三个属性，执行unpark()方法  LockSupport和wait、sleep的对比  park、unpark方法和wait、notify()方法有一些相似的地方。都是休眠，然后唤醒。但是wait、notify方法有一个不好的地方，就是我们在编程的时候必须能保证wait方法比notify方法先执行。 如果notify方法比wait方法晚执行的话，就会导致因wait方法进入休眠的线程接收不到唤醒通知的问题。\n 而park、unpark则不会有这个问题，我们可以先调用unpark方法释放一个许可证，这样后面线程调用park方法时，发现已经许可证了，就可以直接获取许可证而不用进入休眠状态了。\n 另外，和wait方法不同，执行park进入休眠后并不会释放持有的锁。\n 对中断的处理，park()方法阻塞的时候，调用终端，会取消阻塞，但是不会抛出中断异常。\n  参考 [并发系列-4] 从AQS到futex(二): HotSpot的JavaThread和Parker\nLockSupport源码分析\nJava Thread 和 Park\nThread.interrupt()相关源码分析\nThread.sleep、Object.wait、LockSupport.park 区别\n","wordCount":"767","inLanguage":"en","datePublished":"2021-06-15T00:00:00Z","dateModified":"2021-06-15T00:00:00Z","author":{"@type":"Person","name":"    \"zhouyang\""},"mainEntityOfPage":{"@type":"WebPage","@id":"https://balvboy.github.io/blog/locksupport/"},"publisher":{"@type":"Organization","name":"ZhouYang's Blog","logo":{"@type":"ImageObject","url":"https://balvboy.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://balvboy.github.io accesskey=h title="Home (Alt + H)"><img src=/img/zhouyang.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://balvboy.github.io/blog/ title=blogs><span>blogs</span></a></li><li><a href=https://balvboy.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://balvboy.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://balvboy.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?a3d79563dfbd078b66e86495caf11120",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script><script src=/js/mermaid.js></script></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Java同步机制(四)-LockSupport</h1><div class=post-description>LockSupport</div><div class=post-meta>June 15, 2021&nbsp;·&nbsp;4 min&nbsp;·&nbsp;    "zhouyang"</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#locksupport aria-label=LockSupport>LockSupport</a><ul><li><a href=#locksupport%e4%b8%ad%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=LockSupport中的方法>LockSupport中的方法</a><ul><li><a href=#park%e5%92%8cunpark aria-label=park和unpark>park和unpark</a></li><li><a href=#blocker aria-label=Blocker>Blocker</a></li></ul></li><li><a href=#locksupport%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=LockSupport的使用>LockSupport的使用</a></li><li><a href=#%e7%ae%80%e5%8d%95%e7%90%86%e8%a7%a3locksupport%e9%98%bb%e5%a1%9e%e7%9a%84%e5%8e%9f%e7%90%86 aria-label=简单理解LockSupport阻塞的原理>简单理解LockSupport阻塞的原理</a></li><li><a href=#locksupport%e5%92%8c%e7%ba%bf%e7%a8%8b%e4%b8%ad%e6%96%ad aria-label=LockSupport和线程中断>LockSupport和线程中断</a><ul><li><a href=#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 aria-label=源码分析>源码分析</a><ul><li><a href=#park%e5%92%8cunpark%e6%ba%90%e7%a0%81 aria-label=park和unpark源码>park和unpark源码</a></li><li><a href=#interrupt%e6%ba%90%e7%a0%81 aria-label=interrupt源码>interrupt源码</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li></ul></li></ul></li><li><a href=#locksupport%e5%92%8cwait-sleep%e7%9a%84%e5%af%b9%e6%af%94 aria-label=LockSupport和wait、sleep的对比>LockSupport和wait、sleep的对比</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><h1 id=locksupport>LockSupport<a hidden class=anchor aria-hidden=true href=#locksupport>#</a></h1><p>LockSupport是Java中实现同步的一个重要方式，LockSupport提供了阻塞线程和唤醒线程的功能。</p><h2 id=locksupport中的方法>LockSupport中的方法<a hidden class=anchor aria-hidden=true href=#locksupport中的方法>#</a></h2><p>LockSupport中提供了一系列的<code>park</code>，<code>unpark</code>方法供我们进行挂起和唤醒。</p><h3 id=park和unpark>park和unpark<a hidden class=anchor aria-hidden=true href=#park和unpark>#</a></h3><p><img src=/img/16184948458475.jpg alt=-w373></p><p>我们看到6个park方法，可以分为了3类分别是</p><ul><li>park() 一直阻塞</li><li>parkNanos() 阻塞指定的纳秒数</li><li>parkUntil() 阻塞到指定的时间，是时间的毫秒值</li></ul><p>还有1个unpark方法</p><ul><li>unpark(Thread) 唤醒指定线程</li></ul><h3 id=blocker>Blocker<a hidden class=anchor aria-hidden=true href=#blocker>#</a></h3><p>然后每一类方法，都有一个带有Object参数的版本。比如park(Object)方法。</p><p><img src=/img/16184951584251.jpg alt></p><ul><li>获得了当前线程，</li><li>然后把传入的对象，通过Unsafe把对象设置到Thread中的parkObject属性。</li></ul><p><img src=/img/16184952664712.jpg alt></p><p><img src=/img/16184956955973.jpg alt></p><ul><li>然后会调用Unsafe的park方法挂起当前线程。</li><li>然后待线程被唤醒后，设置blocker为null</li></ul><p>那设置和不设置的区别是什么呢?
这个Blocker对象是用来记录线程被阻塞时被谁阻塞的，主要用于线程监控和分析工具来定位原因的。</p><p><img src=/img/16184962769943.jpg alt></p><h2 id=locksupport的使用>LockSupport的使用<a hidden class=anchor aria-hidden=true href=#locksupport的使用>#</a></h2><p>先用代码来展示一下LockSupport最简单的使用方式。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Test</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testPark</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
        Object parkObject <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;I am parkObject&#34;</span><span style=color:#f92672>;</span>
        Thread t1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;t1调用park&#34;</span><span style=color:#f92672>);</span>
            LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>park</span><span style=color:#f92672>(</span>parkObject<span style=color:#f92672>);</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;t1被唤醒了&#34;</span><span style=color:#f92672>);</span>
        <span style=color:#f92672>});</span>

        t1<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
        Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span>1000<span style=color:#f92672>);</span>
        Thread t2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span> LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>getBlocker</span><span style=color:#f92672>(</span>t1<span style=color:#f92672>));</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;t2调用unpark&#34;</span><span style=color:#f92672>);</span>
            LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>unpark</span><span style=color:#f92672>(</span>t1<span style=color:#f92672>);</span>
        <span style=color:#f92672>});</span>
        t2<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span></code></pre></div><p>执行结果是</p><pre><code>t1调用park
t2调用unpark
t1被唤醒了,阻塞了1003ms</code></pre><p>OK,其实上面的代码就能够展示出LockSupport的绝大部分场景的用法了。一个线程因为某些原因调用park方法阻塞，然后另一个线程在达到某些条件的时候，通过unpark唤醒这个线程。</p><p>在LockSupport的注释中有这么一句话</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/** 
</span><span style=color:#75715e>  Additionally, {@code park} will return if the caller&#39;s
</span><span style=color:#75715e>  thread was interrupted, and timeout versions are supported. The
</span><span style=color:#75715e>  {@code park} method may also return at any other time, for &#34;no
</span><span style=color:#75715e>  reason&#34;, so in general must be invoked within a loop that rechecks
</span><span style=color:#75715e>  conditions upon return. 
</span><span style=color:#75715e>**/</span> </code></pre></div><p>意思是，park()方法会在调用线程被终端的时候返回。
park()方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法。</p><p>这就意味着，当我们使用了<code>LockSupport.park()</code>,进行阻塞。当这个方法突然返回的时候，有可能并不是我们调用了unpark()方法导致的。
所以我们需要在循环代码中是否符合业务逻辑，只有确认了是我们自己调用了unpark()触发的才可以。</p><p>所以我们看到AQS中对于<code>LockSupport.park()</code>的使用，都是在循环中使用的。</p><h2 id=简单理解locksupport阻塞的原理>简单理解LockSupport阻塞的原理<a hidden class=anchor aria-hidden=true href=#简单理解locksupport阻塞的原理>#</a></h2><p>下面来简单的理解一下LockSupport的原理。</p><p>每一个线程内部都有一个permit,许可证的概念
线程在初始化的时候，permit为0。
当在线程中调用LockSupport.park()方法的时候，会消耗掉一个permit。</p><ul><li>如果此时线程中permit为0，线程就会挂起</li><li>如果此时permit为1，则park()方法会立刻返回，并消耗一个permit，线程内的permit变为0</li></ul><p>调用LockSupport.unpark()方法的时候，会生产一个permit。如果该线程因为调用了park()方法而挂起，同时也会唤醒该线程。</p><ul><li>不管调用多少次unpark,线程中permit的数量最多就是1。</li></ul><p>通过上面描述，我们发现LockSupport的工作原理，很像一个信号量为1的Semaphore。
park为加锁，unpark为解锁。</p><h2 id=locksupport和线程中断>LockSupport和线程中断<a hidden class=anchor aria-hidden=true href=#locksupport和线程中断>#</a></h2><p>除了unpark能唤醒park挂起的线程外，调用线程的<code>interrupt()</code>方法也能唤醒线程。
对于<code>interrupt()</code>方法，我们了解，</p><ul><li>当一个线程处于sleep，或者wait的阻塞状态的时候。如果这个时候调用线程的<code>interrupt</code>方法，线程会抛出<code>InterruptedException</code>，并清除掉线程的中断状态。</li><li>如果线程处于运行状态，那么调用线程的<code>interrupt()</code>方法，则不会发生任何异常，只会把线程的中断状态设置为true。</li><li>如果使用<code>interrupt()</code>打断一个，通过park挂起的线程，线程会被唤醒，但是不会抛出异常，并且保留线程的中断状态。</li></ul><p>而且如果一个线程的中断状态为true，就算没有permit，park()方法也会失效。
我们通过下面的代码来说明一下。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Test</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testInterruptAndPark</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;自己中断&#34;</span><span style=color:#f92672>);</span>
            Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>interrupt</span><span style=color:#f92672>();</span>

            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;打印线程中断状态：&#34;</span> <span style=color:#f92672>+</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>isInterrupted</span><span style=color:#f92672>());</span>

            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;开始park&#34;</span><span style=color:#f92672>);</span>
            <span style=color:#66d9ef>long</span> st <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>();</span>
            LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>park</span><span style=color:#f92672>();</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;park结束,持续时间:&#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>()</span> <span style=color:#f92672>-</span> st<span style=color:#f92672>));</span>

            st <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>();</span>
            LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>park</span><span style=color:#f92672>();</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;park结束,持续时间:&#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>()</span> <span style=color:#f92672>-</span> st<span style=color:#f92672>));</span>
        <span style=color:#f92672>});</span>
        thread<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
        Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span>100000<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span></code></pre></div><p>执行结果</p><pre><code>自己中断
打印线程中断状态：true
开始park
park结束,持续时间:1
park结束,持续时间:0</code></pre><p>我们在一个线程中，让它自己调用了interrupt方法，然后调用了两次park()方法，然后两次park()方法都失效了。
所以说线程的中断状态，会影响park()的挂起，下面我我们会从源码上来找一下原因。</p><h3 id=源码分析>源码分析<a hidden class=anchor aria-hidden=true href=#源码分析>#</a></h3><h4 id=park和unpark源码>park和unpark源码<a hidden class=anchor aria-hidden=true href=#park和unpark源码>#</a></h4><p><code>LockSupport.park()</code>方法调用的是本地方法。在JVM中最终调用的是<code>Parker</code>类的<code>park</code>方法，这个方法针对不同平台有不同的实现，这里我们主要看一下Linux平台下的实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// thread.hpp
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Thread</span> {
  <span style=color:#75715e>// OS data associated with the thread
</span><span style=color:#75715e></span>  OSThread<span style=color:#f92672>*</span> _osthread;  <span style=color:#75715e>// Platform-specific thread information
</span><span style=color:#75715e></span>  ParkEvent <span style=color:#f92672>*</span> _ParkEvent;    <span style=color:#75715e>// for synchronized(), wait
</span><span style=color:#75715e></span>  ParkEvent <span style=color:#f92672>*</span> _SleepEvent;   <span style=color:#75715e>// for Thread.sleep
</span><span style=color:#75715e></span>  <span style=color:#75715e>// JSR166 per-thread parker
</span><span style=color:#75715e></span>  Parker<span style=color:#f92672>*</span>    _parker; <span style=color:#75715e>// for LockSupport::park
</span><span style=color:#75715e></span>  <span style=color:#75715e>//...
</span><span style=color:#75715e></span>};
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JavaThread</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Thread {
  <span style=color:#75715e>// 指向Java Thread实例, oop是HotSpot里指向一个Java level的实例, 一个gc对象.
</span><span style=color:#75715e></span>  oop            _threadObj; <span style=color:#75715e>// The Java level thread ,
</span><span style=color:#75715e></span>  JavaFrameAnchor _anchor;   <span style=color:#75715e>// Encapsulation of current java frame and it state
</span><span style=color:#75715e></span>  CompiledMethod<span style=color:#f92672>*</span>   _deopt_nmethod; <span style=color:#75715e>// CompiledMethod that is currently being deoptimized
</span><span style=color:#75715e></span>  <span style=color:#75715e>//
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>volatile</span> JavaThreadState _thread_state;
  <span style=color:#75715e>//...
</span><span style=color:#75715e></span>};</code></pre></div><p>我们先来看一下JVM中Thread的定义,Thread 类里有两个 ParkEvent 和一个 Parker, 其实 ParkEvent 和 Parker 实现和功能十分类似。</p><ul><li><code>_ParkEvent</code> 是实现 synchronized 关键字，wait，notify 用的，</li><li><code>_SleepEvent</code> 是给 Thread.sleep 用的。</li><li><p><code>_parker</code> 是用来实现 J.U.C 的 LockSupport的park/unpark (阻塞 / 唤醒)。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
Parker() <span style=color:#f92672>:</span> PlatformParker() {
_counter       <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> ;
FreeNext       <span style=color:#f92672>=</span> NULL ;
AssociatedWith <span style=color:#f92672>=</span> NULL ;
}</code></pre></div></li></ul><p>我们再来看一下Parker的结构。
我们主要看<code>_counter</code>这个字段，这个其实就是我们上面说到的permit。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// src/hotspot/os/posix/os_posix.cpp
</span><span style=color:#75715e>//isAbsolute 表示后面的时间是绝对时间还是相对时间
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Parker<span style=color:#f92672>::</span>park(<span style=color:#66d9ef>bool</span> isAbsolute, jlong time) {
  <span style=color:#75715e>// 设置_counter为0，并且判断原值
</span><span style=color:#75715e></span>  <span style=color:#75715e>//  如果别的线程已经unpark了我.  
</span><span style=color:#75715e></span>  <span style=color:#75715e>//  这里没有使用锁机制，需要Atomic::xchg和barrier保证lock-free代码的正确.
</span><span style=color:#75715e></span>  <span style=color:#75715e>// We depend on Atomic::xchg() having full barrier semantics
</span><span style=color:#75715e></span>  <span style=color:#75715e>// since we are doing a lock-free update to _counter.
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (Atomic<span style=color:#f92672>::</span>xchg(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>_counter) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span>;

  Thread<span style=color:#f92672>*</span> <span style=color:#66d9ef>thread</span> <span style=color:#f92672>=</span> Thread<span style=color:#f92672>::</span>current();
  assert(<span style=color:#66d9ef>thread</span><span style=color:#f92672>-&gt;</span>is_Java_thread(), <span style=color:#e6db74>&#34;Must be JavaThread&#34;</span>);
  JavaThread <span style=color:#f92672>*</span>jt <span style=color:#f92672>=</span> (JavaThread <span style=color:#f92672>*</span>)<span style=color:#66d9ef>thread</span>;

    <span style=color:#75715e>// 如果线程被中断，直接返回
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (Thread<span style=color:#f92672>::</span>is_interrupted(<span style=color:#66d9ef>thread</span>, false)) {
    <span style=color:#66d9ef>return</span>;
  }

  <span style=color:#75715e>// safepoint region相关, 我对细节不详.
</span><span style=color:#75715e></span>  <span style=color:#75715e>// safepoint region大致的了解, 见RednaxelaFX的回答https://www.zhihu.com/question/29268019
</span><span style=color:#75715e></span>  ThreadBlockInVM <span style=color:#a6e22e>tbivm</span>(jt);
  <span style=color:#75715e>// 再次判断线程是否被中断，如果没有被中断，尝试获得互斥锁，如果获取失败，直接返回
</span><span style=color:#75715e></span>  <span style=color:#75715e>// 如果别的线程正在unpark我, 而持有了mutex, 我先返回了,没有必要在_mutex上等
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (Thread<span style=color:#f92672>::</span>is_interrupted(<span style=color:#66d9ef>thread</span>, false) <span style=color:#f92672>||</span> pthread_mutex_trylock(_mutex) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
    <span style=color:#66d9ef>return</span>;
  }
  <span style=color:#75715e>// 如果别的线程已经unblock了我, no wait needed
</span><span style=color:#75715e></span>  <span style=color:#75715e>// 已经拿到了mutex, 所以不需要和前面一样Atomic::xchg了.因为已经拿到了锁
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> status;
  <span style=color:#66d9ef>if</span> (_counter <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)  {
    _counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    status <span style=color:#f92672>=</span> pthread_mutex_unlock(_mutex);
    OrderAccess<span style=color:#f92672>::</span>fence();
    <span style=color:#66d9ef>return</span>;
  }
  <span style=color:#75715e>// 记录线程的状态
</span><span style=color:#75715e></span>  OSThreadWaitState <span style=color:#a6e22e>osts</span>(<span style=color:#66d9ef>thread</span><span style=color:#f92672>-&gt;</span>osthread(), false <span style=color:#75715e>/* not Object.wait() */</span>);
  jt<span style=color:#f92672>-&gt;</span>set_suspend_equivalent();
  <span style=color:#75715e>// cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
</span><span style=color:#75715e></span>  <span style=color:#75715e>// 这一坨, 就是block自己这个线程了.(Java层当前执行的线程)
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (time <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    _cur_index <span style=color:#f92672>=</span> REL_INDEX; <span style=color:#75715e>// arbitrary choice when not timed
</span><span style=color:#75715e></span>    status <span style=color:#f92672>=</span> pthread_cond_wait(<span style=color:#f92672>&amp;</span>_cond[_cur_index], _mutex);
  } <span style=color:#66d9ef>else</span> {
    _cur_index <span style=color:#f92672>=</span> isAbsolute <span style=color:#f92672>?</span> ABS_INDEX : REL_INDEX;
    status <span style=color:#f92672>=</span> pthread_cond_timedwait(<span style=color:#f92672>&amp;</span>_cond[_cur_index], _mutex, <span style=color:#f92672>&amp;</span>absTime);
  }
  _cur_index <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
  <span style=color:#75715e>// 已经从block住状态中恢复返回了, 把_counter设0.
</span><span style=color:#75715e></span>  _counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  status <span style=color:#f92672>=</span> pthread_mutex_unlock(_mutex);
  <span style=color:#75715e>// 要保证多线程的正确性要十二分小心
</span><span style=color:#75715e></span>  <span style=color:#75715e>// 这里的memory fence 是一个lock addl 指令, 加上compiler_barrier
</span><span style=color:#75715e></span>  <span style=color:#75715e>// 保证_counter = 0 是对调用unlock线程是可见的.
</span><span style=color:#75715e></span>  <span style=color:#75715e>// Paranoia to ensure our locked and lock-free paths interact
</span><span style=color:#75715e></span>  <span style=color:#75715e>// correctly with each other and Java-level accesses.
</span><span style=color:#75715e></span>  OrderAccess<span style=color:#f92672>::</span>fence();
  <span style=color:#75715e>// 已经醒过来, 但如果有别人在suspend我,那么继续suspend自己.
</span><span style=color:#75715e></span>  <span style=color:#75715e>// If externally suspended while waiting, re-suspend
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (jt<span style=color:#f92672>-&gt;</span>handle_special_suspend_equivalent_condition()) {
    jt<span style=color:#f92672>-&gt;</span>java_suspend_self();
  }
}</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// src/hotspot/os/posix/os_linux.cpp
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Parker<span style=color:#f92672>::</span>unpark() {
  <span style=color:#66d9ef>int</span> status <span style=color:#f92672>=</span> pthread_mutex_lock(_mutex);
  assert_status(status <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>, status, <span style=color:#e6db74>&#34;invariant&#34;</span>);
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> s <span style=color:#f92672>=</span> _counter;
  _counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
  <span style=color:#75715e>// must capture correct index before unlocking
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> _cur_index;
  status <span style=color:#f92672>=</span> pthread_mutex_unlock(_mutex);
  assert_status(status <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>, status, <span style=color:#e6db74>&#34;invariant&#34;</span>);

<span style=color:#75715e>// s记录的是unpark之前的_counter数，如果s &lt; 1，说明有可能该线程在等待状态，需要唤醒。
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> index <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
    <span style=color:#75715e>// 发信号唤醒线程
</span><span style=color:#75715e></span>    status <span style=color:#f92672>=</span> pthread_cond_signal(<span style=color:#f92672>&amp;</span>_cond[index]);
    assert_status(status <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>, status, <span style=color:#e6db74>&#34;invariant&#34;</span>);
  }
}</code></pre></div><p>简单总结一下这两个流程，(不会分析每一行代码的作用)</p><p><strong>park</strong></p><ul><li>首先把<code>_counter</code>设置为0，并判断如果之前为1的话直接返回</li><li>检查线程的中断状态，如果处于中断状态，则直接返回</li><li>设置线程状态</li><li>调用<code>pthread</code>相关函数阻塞线程（线程进入阻塞状态，等待阻塞超时或者被唤醒）</li><li>阻塞超时结束，或者被唤醒之后，设置<code>_counter</code>为0</li></ul><p><strong>unpark</strong></p><ul><li>把<code>_counter</code>设置为1</li><li>判断<code>_counter</code>原值，如果小于1，则表示有可能有线程在阻塞（这里并不是一定，因为初始的时候<code>_counter</code>为0）</li></ul><h4 id=interrupt源码>interrupt源码<a hidden class=anchor aria-hidden=true href=#interrupt源码>#</a></h4><p>我们上面说到，<code>interrupt()</code>方法，也能唤醒通过<code>park</code>阻塞的线程，那我们就来看一下<code>interrupt</code>的源码.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>//hotspot\src\os\linux\vm\os_linux.cpp
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> os<span style=color:#f92672>::</span>interrupt(Thread<span style=color:#f92672>*</span> <span style=color:#66d9ef>thread</span>) {
  assert(Thread<span style=color:#f92672>::</span>current() <span style=color:#f92672>==</span> <span style=color:#66d9ef>thread</span> <span style=color:#f92672>||</span> Threads_lock<span style=color:#f92672>-&gt;</span>owned_by_self(),
    <span style=color:#e6db74>&#34;possibility of dangling Thread pointer&#34;</span>);
  <span style=color:#75715e>// 获取
</span><span style=color:#75715e></span>  OSThread<span style=color:#f92672>*</span> osthread <span style=color:#f92672>=</span> <span style=color:#66d9ef>thread</span><span style=color:#f92672>-&gt;</span>osthread();
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>osthread<span style=color:#f92672>-&gt;</span>interrupted()) {
    osthread<span style=color:#f92672>-&gt;</span>set_interrupted(true);
    <span style=color:#75715e>// More than one thread can get here with the same value of osthread,
</span><span style=color:#75715e></span>    <span style=color:#75715e>// resulting in multiple notifications.  We do, however, want the store
</span><span style=color:#75715e></span>    <span style=color:#75715e>// to interrupted() to be visible to other threads before we execute unpark().
</span><span style=color:#75715e></span>    OrderAccess<span style=color:#f92672>::</span>fence();
    ParkEvent <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> slp <span style=color:#f92672>=</span> <span style=color:#66d9ef>thread</span><span style=color:#f92672>-&gt;</span>_SleepEvent ;
    <span style=color:#66d9ef>if</span> (slp <span style=color:#f92672>!=</span> NULL) slp<span style=color:#f92672>-&gt;</span>unpark() ;
  }
  <span style=color:#75715e>// For JSR166. Unpark even if interrupt status already was set
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>thread</span><span style=color:#f92672>-&gt;</span>is_Java_thread())
    ((JavaThread<span style=color:#f92672>*</span>)<span style=color:#66d9ef>thread</span>)<span style=color:#f92672>-&gt;</span>parker()<span style=color:#f92672>-&gt;</span>unpark();
  ParkEvent <span style=color:#f92672>*</span> ev <span style=color:#f92672>=</span> <span style=color:#66d9ef>thread</span><span style=color:#f92672>-&gt;</span>_ParkEvent ;
  <span style=color:#66d9ef>if</span> (ev <span style=color:#f92672>!=</span> NULL) ev<span style=color:#f92672>-&gt;</span>unpark() ;
}</code></pre></div><ul><li>每一个Java线程都与一个osthread一一对应，如果相应的os线程没有被中断，则会设置osthread的interrupt标志位为true。</li><li>并唤醒线程的<code>_SleepEvent</code> 随后唤醒线程的<code>parker</code>和<code>ParkEvent</code>。</li></ul><h4 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h4><p>通过查看源码，我们对LockSupport的实现原理有了进一步的了解。</p><ul><li>当调用<code>LockSupport.park()</code>的时候，最终调用的是JVM中Thread对象Parker变量的park()方法</li><li>在park()方法中，会判断<code>_counter</code>属性（也就是permit）,然后检查线程的中断状态</li><li>然后会调用<code>pthread_cond_wait</code>,<code>pthread_cond_timedwait</code>阻塞线程</li><li>当调用<code>LockSupport.park(Thread)</code>的时候，最终调用的是JVM中Thread对象Parker变量的unpark()方法</li><li>在unpark()方法中，也会判断<code>_counter</code>属性，然后通过<code>pthread_cond_signal</code>来环境阻塞的线程。</li><li>当调用了线程的<code>interrupt</code>方法，最终执行的是<code>os::interrupt()</code>(Linux平台)</li><li>在<code>os::interrupt()</code>方法中，会设置线程的中断状态，并对JVM线程持有的<code>SleepEvent</code>,<code>Parker</code>,<code>_ParkEvent</code>三个属性，执行<code>unpark()</code>方法</li></ul><h1 id=locksupport和wait-sleep的对比>LockSupport和wait、sleep的对比<a hidden class=anchor aria-hidden=true href=#locksupport和wait-sleep的对比>#</a></h1><p><img src=/img/park.png alt></p><ul><li><p>park、unpark方法和wait、notify()方法有一些相似的地方。都是休眠，然后唤醒。但是wait、notify方法有一个不好的地方，就是我们在编程的时候必须能保证wait方法比notify方法先执行。
如果notify方法比wait方法晚执行的话，就会导致因wait方法进入休眠的线程接收不到唤醒通知的问题。</p></li><li><p>而park、unpark则不会有这个问题，我们可以先调用unpark方法释放一个许可证，这样后面线程调用park方法时，发现已经许可证了，就可以直接获取许可证而不用进入休眠状态了。</p></li><li><p>另外，和wait方法不同，执行park进入休眠后并不会释放持有的锁。</p></li><li><p>对中断的处理，<code>park()</code>方法阻塞的时候，调用终端，会取消阻塞，但是不会抛出中断异常。</p></li></ul><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><p><a href=http://kexianda.info/2017/08/16/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-4-%E4%BB%8EAQS%E5%88%B0futex-%E4%BA%8C-JVM%E7%9A%84Thread%E5%92%8CParker/>[并发系列-4] 从AQS到futex(二): HotSpot的JavaThread和Parker</a></p><p><a href=https://jlice.top/p/8dxvk/>LockSupport源码分析</a></p><p><a href=https://www.beikejiedeliulangmao.top/java/concurrent/thread-park/>Java Thread 和 Park</a></p><p><a href=http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>Thread.interrupt()相关源码分析</a></p><p><a href=https://blog.csdn.net/u013332124/article/details/84647915>Thread.sleep、Object.wait、LockSupport.park 区别</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://balvboy.github.io/tags/locksupport/>LockSupport</a></li><li><a href=https://balvboy.github.io/tags/park/>park</a></li><li><a href=https://balvboy.github.io/tags/unpark/>unpark</a></li><li><a href=https://balvboy.github.io/tags/aqs/>AQS</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(四)-LockSupport on twitter" href="https://twitter.com/intent/tweet/?text=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%9b%9b%29-LockSupport&url=https%3a%2f%2fbalvboy.github.io%2fblog%2flocksupport%2f&hashtags=LockSupport%2cpark%2cunpark%2cAQS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(四)-LockSupport on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbalvboy.github.io%2fblog%2flocksupport%2f&title=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%9b%9b%29-LockSupport&summary=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%9b%9b%29-LockSupport&source=https%3a%2f%2fbalvboy.github.io%2fblog%2flocksupport%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(四)-LockSupport on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbalvboy.github.io%2fblog%2flocksupport%2f&title=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%9b%9b%29-LockSupport"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(四)-LockSupport on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbalvboy.github.io%2fblog%2flocksupport%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(四)-LockSupport on whatsapp" href="https://api.whatsapp.com/send?text=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%9b%9b%29-LockSupport%20-%20https%3a%2f%2fbalvboy.github.io%2fblog%2flocksupport%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java同步机制(四)-LockSupport on telegram" href="https://telegram.me/share/url?text=Java%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%28%e5%9b%9b%29-LockSupport&url=https%3a%2f%2fbalvboy.github.io%2fblog%2flocksupport%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//balvboy.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href=https://balvboy.github.io>ZhouYang's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button>
</a><link rel=stylesheet type=text/css href=/css/table.css><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script><script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>