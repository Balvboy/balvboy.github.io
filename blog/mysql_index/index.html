<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL的索引 | ZhouYang's Blog</title><meta name=keywords content="mysql"><meta name=description content="数据页 是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。所以数据库读写一次最少都要16KB。 InnoDB为了不同的目的而设计"><meta name=author content="    &#34;zhouyang&#34;"><link rel=canonical href=https://balvboy.github.io/blog/mysql_index/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.424159b38ff151d1ee9ecf19fe8b6d97c4ff0fa323453eb3b9c696323642e9c9.css integrity="sha256-QkFZs4/xUdHuns8Z/ottl8T/D6MjRT6zucaWMjZC6ck=" rel="preload stylesheet" as=style><link rel=icon href=https://balvboy.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://balvboy.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://balvboy.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://balvboy.github.io/img/favicon.ico><link rel=mask-icon href=https://balvboy.github.io/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-146899866-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="MySQL的索引"><meta property="og:description" content="数据页 是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。所以数据库读写一次最少都要16KB。 InnoDB为了不同的目的而设计"><meta property="og:type" content="article"><meta property="og:url" content="https://balvboy.github.io/blog/mysql_index/"><meta property="og:image" content="https://balvboy.github.io/img/z.png"><meta property="article:published_time" content="2021-06-25T16:34:37+08:00"><meta property="article:modified_time" content="2021-06-25T16:34:37+08:00"><meta property="og:site_name" content="Life is Fantastic"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://balvboy.github.io/img/z.png"><meta name=twitter:title content="MySQL的索引"><meta name=twitter:description content="数据页 是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。所以数据库读写一次最少都要16KB。 InnoDB为了不同的目的而设计"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL的索引","name":"MySQL的索引","description":"数据页 是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。所以数据库读写一次最少都要16KB。 InnoDB为了不同的目的而设计","keywords":["mysql"],"articleBody":" 数据页 是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。所以数据库读写一次最少都要16KB。\nInnoDB为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE信息的页，存放undo日志信息的页等等等等。\n我们主要需要了解的是存放我们表中记录的页类型，官方称之为索引页，但我们我还是先称之为数据页。\n数据页格式    名称 中文名 占用空间大小 简单描述     File Header 文件头部 38字节 页的一些通用信息   Page Header 页面头部 56字节 数据页专有的一些信息   Infimum + Supremum 最小记录和最大记录 26字节 两个虚拟的行记录   User Records 用户记录 不确定 实际存储的行记录内容   Free Space 空闲空间 不确定 页中尚未使用的空间   Page Directory 页面目录 不确定 页中的某些记录的相对位置,可以理解为为了加快在页面中的搜索速度而实现的针对该数据页记录的目录   File Trailer 文件尾部 8字节 校验页是否完整    数据页如何存储记录 记录会被存储到User Records部分，但是在数据页刚被分配的时候，User Records为空，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了。\n记录行 记录是以记录行的形式添加到 User Records 中的，下面呢我们大概来了解一下记录行的格式\n我们看到有很多我们熟悉的\n 变长字段列表 null值列表  记录允许为null的字段，是否为null，每个字段使用1bit来表示 如果所有字段都不能为null，则在记录行中就没有这个部分 这就是我们经常说的为什么字段设置为null会多占用空间，用1个bit来表示1个nullable字段是否为空 MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0，就算只有1个字段没有设置not null，那么也需要使用1字节来存储null列表 另外需要注意的点是，null值列表中表示的字段顺序和后面记录中字段的顺序是相反的。  记录头信息  这个在数据页结构很重要，下面我们单独来说  隐藏字段  事务id 和 回滚指针。在事务和MVCC中起到重要作用  记录中字段值  这个就是我们自己定义的字段里存储的值   记录头信息    名称 大小bit 描述     预留位1 1 没有使用   预留位2 1 没有使用   delete_mask 1 标记该记录是否被删除   min_rec_mask 1 B+树的每层非叶子节点中的最小记录都会添加该标记(只针对索引类型记录)   n_owned 4 表示当前记录拥有的记录数，每个分组的最后一条记录，用来保存这个分组中有几条记录   heap_no 13 表示当前记录在记录堆的位置信息   record_type 3 表示当前记录的类型，\n0表示普通记录，\n1表示B+树非叶节点记录，也就是索引\n2表示最小记录，\n3表示最大记录   next_record 16 表示下一条记录的相对位置; 就是依靠它，一个数据页中的所有记录行，就串成了一个长长的单向链表    Page Directory(页面目录) 上面我们了解到数据页中存储的就是一条条的记录，每个数据页一般来说有16KB大小，这样的一个数据页根据存储的表数据不同，能够存下几百到上千条记录行。上面我们了解到页中的所有的记录行是一个链表。这样的话如果我们在数据页中查询一条记录，那么就需要遍历整个数据页中的记录行链表，这样的效率十分低下，为了解决这个问题，InnoDB的设计者为每个数据页都建立了一个目录，这个目录就是Page Directory。\n 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。分组规则:  对于最小记录所在的分组只能有 1 条记录 最大记录所在的分组拥有的记录条数只能在 1~8 条之间 剩下的分组中记录的条数范围只能在是 4~8 条之间  每个组的最后一条记录（也就是组内主键最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory，也就是页目录  有个Page Directory之后，我们在来看一下如何查找记录\n 首先我们可以通过二分法先定位到记录所在的分组  二分法，首先要求记录是有序的，先找到中间的一条记录，然后对比，如果小，则在左边继续二分，直到找到对应的记录 首先Page Directory是有序的，并且记录了每个组中最后一条记录的偏移量，所以可以通过偏移量快速的找到组中最后一条记录。 把要查找的记录和组中的最后一条记录对比，最终找到记录所在的组  找到对应的组后，就可以比遍历组中的记录来找对应的记录了，因为每组内记录较少，可以效率很高  在遍历的时候我们需要找到组中最开始的那条记录，但是Page Directory中只记录了最后一条，那怎么处理呢 别忘了我们所有的记录都在一个大的单向链表中。一个组的最后一条的next record指向的就是下一组的第一条了。   Page Header(页面头部) 这一部分用来记录当前数据页的一些状态信息,该部分固定占用56字节，比如\n 本页中已经存储了多少条记录 第一条记录的地址是什么 页目录中存储了多少个槽 本页的Free Space地址 第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用） 本页在B+树中的层级 等等  下面是详细的描述\n   名称 占用空间大小 描述     PAGE_N_DIR_SLOTS 2字节 在页目录中的槽数量   PAGE_HEAP_TOP 2字节 还未使用的空间最小地址，也就是说从该地址之后就是Free Space   PAGE_N_HEAP 2字节 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）   PAGE_FREE 2字节 第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）   PAGE_GARBAGE 2字节 已删除记录占用的字节数   PAGE_LAST_INSERT 2字节 最后插入记录的位置   PAGE_DIRECTION 2字节 记录插入的方向   PAGE_N_DIRECTION 2字节 一个方向连续插入的记录数量   PAGE_N_RECS 2字节 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）   PAGE_MAX_TRX_ID 8字节 修改当前页的最大事务ID，该值仅在二级索引中定义   PAGE_LEVEL 2字节 当前页在B+树中所处的层级   PAGE_INDEX_ID 8字节 索引ID，表示当前页属于哪个索引   PAGE_BTR_SEG_LEAF 10字节 B+树叶子段的头部信息，仅在B+树的Root页定义   PAGE_BTR_SEG_TOP 10字节 B+树非叶子段的头部信息，仅在B+树的Root页定义    File Header(记录) Page Header是专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。\nFile Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁,这个部分占用固定的38个字节，是由下边这些内容组成的：\n   名称 占用空间大小 描述     FIL_PAGE_SPACE_OR_CHKSUM 4字节 页的校验和（checksum值）   FIL_PAGE_OFFSET 4字节 页号   FIL_PAGE_PREV 4字节 上一个页的页号   FIL_PAGE_NEXT 4字节 下一个页的页号   FIL_PAGE_LSN 8字节 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）   FIL_PAGE_TYPE 2字节 该页的类型   FIL_PAGE_FILE_FLUSH_LSN 8字节 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值   FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID 4字节 页属于哪个表空间    这里我们重点关注几个属性\nFIL_PAGE_SPACE_OR_CHKSUM 表示该数据页的校验和，和MD5类似，用来校验数据页数据是否完整。\nFIL_PAGE_OFFSET 每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。\nFIL_PAGE_TYPE 这个代表当前页的类型，我们前边说过，InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：\n   类型名称 十六进制 描述     FIL_PAGE_TYPE_ALLOCATED 0x0000 最新分配，还没使用   FIL_PAGE_UNDO_LOG 0x0002 Undo日志页   FIL_PAGE_INODE 0x0003 段信息节点   FIL_PAGE_IBUF_FREE_LIST 0x0004 Insert Buffer空闲列表   FIL_PAGE_IBUF_BITMAP 0x0005 Insert Buffer位图   FIL_PAGE_TYPE_SYS 0x0006 系统页   FIL_PAGE_TYPE_TRX_SYS 0x0007 事务系统数据   FIL_PAGE_TYPE_FSP_HDR 0x0008 表空间头部信息   FIL_PAGE_TYPE_XDES 0x0009 扩展描述页   FIL_PAGE_TYPE_BLOB 0x000A BLOB页   FIL_PAGE_INDEX 0x45BF 索引页，也就是我们所说的数据页    FIL_PAGE_PREV和FIL_PAGE_NEXT 一个数据页的大小通常为16KB，如果数据量大，那么就需要很多个数据页来共存存储。多个数据页不可能都被分配到连续的物理内存上，所以通过这两个属性把多个数据页连接起来，形成一个双向链表。\nFile Trailer 我们知道数据页是在硬盘和内存之间不断的被读取和写入的。一个数据页的大小为16KB，那如果在写一个数据页时，中间断电了怎么办，这时候一个数据页只被写了一半的数据。这个时候就要用到我们上面提到的 File Header中的校验和与File Trailer了。\nFile Trailer 大小为8字节，有两个部分组成\n 前4个字节代表页的校验和 后4个字节代表页面被最后修改时对应的日志序列位置  这里我们先关注校验和\n 因为FileHeader是在数据页的最上面，所以在写入的时候也是被首先写入的 File Trailer是在数据的尾部，他的写入是最后完成的 在正常情况下他们两个的校验和肯定是保持一致的，但是如果发生了我们上面提到的断电的情况，一个数据页只写入了一半。我们就可以通过判断这两个校验和是否一致来判断这个数据页的写入是否完整的完成了。  数据页结构总结 上面写的内容是为了让大家对数据页有一个基础的了解，下面我试着总结一下\n 首先一张数据库表，可能有一个或者多个数据页来组成 单独的一个数据页在物理空间上是连续的，但是多个数据页就不一定是连续的了，所以这些数据页之间会通过File Header中的 PREV 和 NEXT 指针连接起来，成为一个双向链表 在每个数据页中，都能够存储多条记录行，存储在 User Record,每次插入新的记录行，都会从Free Space分配空间。 数据页中的所有记录行(包括最大记录和最小记录)，会通过记录行结构中记录头的next record连接起来，成为一个单向链表 为了提高在数据页中查询记录的效率，对所有的记录行进行了分组，其中最小记录单独一组，其他记录每4-8条分为一组，最大记录所在的组1-8条。 并把每个分组的最后一条记录的偏移量保存起来，叫做这个页的目录，也就是 Page Directory,通过页目录中的偏移量，可以快速的找到对应的记录，所以就能够通过二分法确定记录所在的组，然在组内遍历找到对应的记录。 数据页中保存了多少条记录，分了多少个组，被删除记录的链表头指针，本数据页在B+数中的层级这些信息，被保存在了Page Header中。 并且为校验数据页在写入过程中是否被中断过，在File Header(数据页头) 和 File Trailer(数据页尾)都添加了校验和，用来校验次数据页是否完整。  我觉的其中中重要的点就是\n 多个数据页之间是双向链表  数据页中的记录行是单向链表  数据页中会对记录行进行分组   在单个数据页中的查找流程 下面在啰嗦一遍在一个数据页中查询记录的过程\n 各个数据页可以组成一个双向链表，\n而每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，\n每个数据页都会为存储在它里边儿的记录生成一个页目录，\n在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，\n然后再遍历该槽对应分组中的记录即可快速找到指定的记录\n MySQL索引数据结构 如果说，上面就是索引的数据结构你会不会惊讶？\n但结果就是这样的，索引数据同样采用和上面一样的数据页结构来存储。\n在上面的数据页结构中，我们分析了在一个数据页中如何找到一条记录。\n但是一张大数据量的表中可能包含成千上万个数据页，我们改如何确定这条记录在哪个数据页中呢？\n 方案一: 从第一个数据页开始遍历，因为多个数据页之间组成了链表，所以能够整个遍历一遍，那么就能找到这条记录了。显然这样的方式性能十分低下 方案二: 我们还记得数据页中的Page Directory页目录吗？，我们也可以为多个数据页建立类似的目录结构。 这样我们就能同样使用二分法来确定记录所在的数据页了。  是的，其实这就是索引的作用，帮我们快速找到对应记录所在的数据页\nInnoDB的索引方案 我们对索引的需求是，能够使用二分法快速定位到对应的数据页上，所以我们在索引的结构里需要存储\n 数据页的序号(在上面的File Header中提到过，通过它可以快速定位到数据页) 该数据页主键索引的最大值或者最小值  这里InnoDB采用的最小值 这里我猜测可能的原因可能是，如果保存最大值，那么表示，每往数据页加入一条新纪录(主键自增的情况)，这个值就需要更新一次。 如果是最小值，在主键自增的情况下，只有第一次想数据页中加入数据时需要改一次，后续往数据页中插入新的数据都不需要变化。   那么把这两个数据存在什么位置呢？ 还记得我们上面说到记录行的记录头信息中有一个record_type字段\n 0表示普通记录 1表示B+树非叶节点记录 2表示最小记录 3表示最大记录  InnoDB就是采用record_type=1的记录行来记录索引信息\n然后把数据页的序号和数据页中最小的主键值存储到记录行的列信息部分。\n然后把这些索引类型的记录行，放到和上面结构一样的数据页中。\n这样我们就完美是，使用同一套数据页格式，既存储了索引数据，有存储了真正的表数据。\n索引记录和普通记录的区别  索引记录的record_type值是1，而普通用户记录的record_type值是0。 索引记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列 记录头中min_rec_mask的区别，如果该记录是索引类型记录，并且该记录是数据页中主键最小的记录，min_rec_mask值为1，其他情况都为0  除了上述几点外，这两者就没啥差别了， - 它们用的是一样的数据页。 - 数据页的组成结构也是一样一样的（上面介绍的7个部分）， - 都会为数据页中的记录生成Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。\n索引结构B+树 我们来看一下，添加了索引数据页之后的结构\n我们看到索引数据页中有多条记录行，每条记录行都指向一个用户记录数据页，并保存着指向的这个数据页的最小的主键。\n数据页的大小同样都为16KB，但是存储索引记录的数据页只需要保存2个字段即可，所以一个数据页保存的索引记录的数量要大于保存普通记录的数量。\n在不断向表中添加数据的情况下，肯定会出现一个索引数据页无法保存所有的索引记录，这时候就需要重新分配新的索引数据页。\n如果我们继续想表中添加数据，就会生成更多的索引数据页,当索引数据页足够多的时候，如何主键位于哪个索引数据页就同样成为问题。所以我们同样需要为索引数据页建立目录，那么接下来就出现了这样的多层的树状结构\n这样的话，只要们知道根节点的位置，就能够从根节点开始按照上面流程，一层层的找到对应的记录数据页，然后找到对应的记录。\n这个树就是B+树。\nB+数的层数 我们上面说到当索引数据页数量足够多的时候，会出现多层B+数的情况，那么这个层数会很高吗，一般数据量级的表会有几层呢？\n我们来计算一下，因为索引数据页存储的字段少，索引一个数据页能存储的行数肯定比普通数据页多，我们假设一个索引数据页能存数1000条索引行，一个记录数据页能够存储100条记录行\n 1层的B+树 2层的B+树 能够容纳 1000 * 100 = 10W 条数据 3层的B+树 能够容纳 10W * 1000 = 1亿 条数据 4层的B+树，能够容纳 1亿 * 1000 = 1000亿 条数据  当然一个普通记录数据页，根据存储的内容不同，存储的行数肯定也会不一样在几十条到几百条都有可能。 但是总的来说 4层的B+树，肯定能够满足我们绝大多数的需求了。\n索引B+树的生成过程  每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中， 而根节点便升级为存储目录项记录的页。 一个B+树索引的根节点自诞生之日起，便不会再移动，他会被存储到数据字典中，每当需要使用索引的时候，就会从数据字典中找到根节点的位置，然后使用索引来查找记录  总结一下就是。 - 首先创建一个根页面，然后向根页面插入数据，这时候不需要索引，因为只有一个数据页 - 当根数据页满了之后，就需要增加一个数据页，当数据页的数量超过1个，就需要创建对应的索引数据页 - 因为根数据页的位置不能动，所以会按照上面的流程\n为什么实用B+数  多叉树，可以保证树的层数比较低，减少IO的次数  一般千万级别的数据的索引，使用3到4层即可  叶子节点有序 每个节点可以存储多条数据，每个节点可以存储degree -1 条数据 -  B+树的特点 索引优化  回表 覆盖索引 最左匹配 索引下推  建立索引的注意事项  建立索引的字段不宜太长  字段短的话，则在一个数据页中可以存储更多的索引，从而可以减少IO的次数 当然业务优先  表的主键最好使用自增、  在自增的情况下，添加新的数据，只会影响最后面的数据页。 而不自增的id，会导致页分裂 比如身份证表中，身份证号是唯一的，但是不适合用来当主键，因为主键是聚簇索引，如果聚簇索引的大小是随机的，会导致很多务必要的数据行移动 最好添加一列额外的id当做自增主键，哪怕用不到   索引失效条件 覆盖索引 索引合并 索引下推 explain 字段解释 如果判断实用哪个索引 key length的计算方法 possible key 有但是 key 没有的情况 索引中null的问题，null会不会被加入到索引中？ MySQL执行过程 MySQL中IS NULL、IS NOT NULL、!=不能用索引\n","wordCount":"7111","inLanguage":"en","datePublished":"2021-06-25T16:34:37+08:00","dateModified":"2021-06-25T16:34:37+08:00","author":{"@type":"Person","name":"    \"zhouyang\""},"mainEntityOfPage":{"@type":"WebPage","@id":"https://balvboy.github.io/blog/mysql_index/"},"publisher":{"@type":"Organization","name":"ZhouYang's Blog","logo":{"@type":"ImageObject","url":"https://balvboy.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://balvboy.github.io accesskey=h title="Home (Alt + H)"><img src=/img/zhouyang.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://balvboy.github.io/blog/ title=blogs><span>blogs</span></a></li><li><a href=https://balvboy.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://balvboy.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://balvboy.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?a3d79563dfbd078b66e86495caf11120",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script><script src=/js/mermaid.js></script></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>MySQL的索引<div class=entry-isdraft><sup>&nbsp;&nbsp;[draft]</sup></div></h1><div class=post-description></div><div class=post-meta>June 25, 2021&nbsp;·&nbsp;15 min&nbsp;·&nbsp;    "zhouyang"</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e6%95%b0%e6%8d%ae%e9%a1%b5 aria-label=数据页>数据页</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e9%a1%b5%e6%a0%bc%e5%bc%8f aria-label=数据页格式>数据页格式</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e9%a1%b5%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8%e8%ae%b0%e5%bd%95 aria-label=数据页如何存储记录>数据页如何存储记录</a><ul><li><a href=#%e8%ae%b0%e5%bd%95%e8%a1%8c aria-label=记录行>记录行</a></li><li><a href=#%e8%ae%b0%e5%bd%95%e5%a4%b4%e4%bf%a1%e6%81%af aria-label=记录头信息>记录头信息</a></li></ul></li><li><a href=#page-directory-%e9%a1%b5%e9%9d%a2%e7%9b%ae%e5%bd%95 aria-label="Page Directory(页面目录)">Page Directory(页面目录)</a></li><li><a href=#page-header-%e9%a1%b5%e9%9d%a2%e5%a4%b4%e9%83%a8 aria-label="Page Header(页面头部)">Page Header(页面头部)</a></li><li><a href=#file-header-%e8%ae%b0%e5%bd%95 aria-label="File Header(记录)">File Header(记录)</a><ul><li><a href=#fil-page-space-or-chksum aria-label=FIL_PAGE_SPACE_OR_CHKSUM>FIL_PAGE_SPACE_OR_CHKSUM</a></li><li><a href=#fil-page-offset aria-label=FIL_PAGE_OFFSET>FIL_PAGE_OFFSET</a></li><li><a href=#fil-page-type aria-label=FIL_PAGE_TYPE>FIL_PAGE_TYPE</a></li><li><a href=#fil-page-prev%e5%92%8cfil-page-next aria-label=FIL_PAGE_PREV和FIL_PAGE_NEXT>FIL_PAGE_PREV和FIL_PAGE_NEXT</a></li></ul></li><li><a href=#file-trailer aria-label="File Trailer">File Trailer</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e9%a1%b5%e7%bb%93%e6%9e%84%e6%80%bb%e7%bb%93 aria-label=数据页结构总结>数据页结构总结</a><ul><li><a href=#%e5%9c%a8%e5%8d%95%e4%b8%aa%e6%95%b0%e6%8d%ae%e9%a1%b5%e4%b8%ad%e7%9a%84%e6%9f%a5%e6%89%be%e6%b5%81%e7%a8%8b aria-label=在单个数据页中的查找流程>在单个数据页中的查找流程</a></li></ul></li></ul></li><li><a href=#mysql%e7%b4%a2%e5%bc%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=MySQL索引数据结构>MySQL索引数据结构</a><ul><li><a href=#innodb%e7%9a%84%e7%b4%a2%e5%bc%95%e6%96%b9%e6%a1%88 aria-label=InnoDB的索引方案>InnoDB的索引方案</a><ul><li><a href=#%e7%b4%a2%e5%bc%95%e8%ae%b0%e5%bd%95%e5%92%8c%e6%99%ae%e9%80%9a%e8%ae%b0%e5%bd%95%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=索引记录和普通记录的区别>索引记录和普通记录的区别</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e7%bb%93%e6%9e%84b-%e6%a0%91 aria-label=索引结构B+树>索引结构B+树</a></li><li><a href=#b-%e6%95%b0%e7%9a%84%e5%b1%82%e6%95%b0 aria-label=B+数的层数>B+数的层数</a></li><li><a href=#%e7%b4%a2%e5%bc%95b-%e6%a0%91%e7%9a%84%e7%94%9f%e6%88%90%e8%bf%87%e7%a8%8b aria-label=索引B+树的生成过程>索引B+树的生成过程</a></li></ul></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%ae%9e%e7%94%a8b-%e6%95%b0 aria-label=为什么实用B+数>为什么实用B+数</a></li><li><a href=#b-%e6%a0%91%e7%9a%84%e7%89%b9%e7%82%b9 aria-label=B+树的特点>B+树的特点</a></li></ul></li><li><a href=#%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96 aria-label=索引优化>索引优化</a><ul><li><a href=#%e5%bb%ba%e7%ab%8b%e7%b4%a2%e5%bc%95%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label=建立索引的注意事项>建立索引的注意事项</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e6%9d%a1%e4%bb%b6 aria-label=索引失效条件>索引失效条件</a></li><li><a href=#%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95 aria-label=覆盖索引>覆盖索引</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e5%90%88%e5%b9%b6 aria-label=索引合并>索引合并</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8 aria-label=索引下推>索引下推</a></li><li><a href=#explain aria-label=explain>explain</a><ul><li><a href=#%e5%ad%97%e6%ae%b5%e8%a7%a3%e9%87%8a aria-label=字段解释>字段解释</a></li><li><a href=#%e5%a6%82%e6%9e%9c%e5%88%a4%e6%96%ad%e5%ae%9e%e7%94%a8%e5%93%aa%e4%b8%aa%e7%b4%a2%e5%bc%95 aria-label=如果判断实用哪个索引>如果判断实用哪个索引</a></li><li><a href=#key-length%e7%9a%84%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95 aria-label="key length的计算方法">key length的计算方法</a></li><li><a href=#possible-key-%e6%9c%89%e4%bd%86%e6%98%af-key-%e6%b2%a1%e6%9c%89%e7%9a%84%e6%83%85%e5%86%b5 aria-label="possible key 有但是 key 没有的情况">possible key 有但是 key 没有的情况</a></li></ul></li><li><a href=#%e7%b4%a2%e5%bc%95%e4%b8%adnull%e7%9a%84%e9%97%ae%e9%a2%98-null%e4%bc%9a%e4%b8%8d%e4%bc%9a%e8%a2%ab%e5%8a%a0%e5%85%a5%e5%88%b0%e7%b4%a2%e5%bc%95%e4%b8%ad aria-label=索引中null的问题，null会不会被加入到索引中？>索引中null的问题，null会不会被加入到索引中？</a></li></ul></li><li><a href=#mysql%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b aria-label=MySQL执行过程>MySQL执行过程</a></li></ul></div></details></div><div class=post-content><h1 id=数据页>数据页<a hidden class=anchor aria-hidden=true href=#数据页>#</a></h1><p>是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。所以数据库读写一次最少都要16KB。</p><p>InnoDB为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE信息的页，存放undo日志信息的页等等等等。</p><p>我们主要需要了解的是存放我们表中记录的页类型，官方称之为索引页，但我们我还是先称之为数据页。</p><h2 id=数据页格式>数据页格式<a hidden class=anchor aria-hidden=true href=#数据页格式>#</a></h2><p><img src=/img/datapage.png alt></p><table><thead><tr><th align=center>名称</th><th align=center>中文名</th><th align=center>占用空间大小</th><th align=left>简单描述</th></tr></thead><tbody><tr><td align=center><code>File Header</code></td><td align=center>文件头部</td><td align=center><code>38</code>字节</td><td align=left>页的一些通用信息</td></tr><tr><td align=center><code>Page Header</code></td><td align=center>页面头部</td><td align=center><code>56</code>字节</td><td align=left>数据页专有的一些信息</td></tr><tr><td align=center><code>Infimum + Supremum</code></td><td align=center>最小记录和最大记录</td><td align=center><code>26</code>字节</td><td align=left>两个虚拟的行记录</td></tr><tr><td align=center><code>User Records</code></td><td align=center>用户记录</td><td align=center>不确定</td><td align=left>实际存储的行记录内容</td></tr><tr><td align=center><code>Free Space</code></td><td align=center>空闲空间</td><td align=center>不确定</td><td align=left>页中尚未使用的空间</td></tr><tr><td align=center><code>Page Directory</code></td><td align=center>页面目录</td><td align=center>不确定</td><td align=left>页中的某些记录的相对位置,可以理解为为了加快在页面中的搜索速度而实现的针对该数据页记录的目录</td></tr><tr><td align=center><code>File Trailer</code></td><td align=center>文件尾部</td><td align=center><code>8</code>字节</td><td align=left>校验页是否完整</td></tr></tbody></table><h2 id=数据页如何存储记录>数据页如何存储记录<a hidden class=anchor aria-hidden=true href=#数据页如何存储记录>#</a></h2><p>记录会被存储到<code>User Records</code>部分，但是在数据页刚被分配的时候，User Records为空，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了。</p><h3 id=记录行>记录行<a hidden class=anchor aria-hidden=true href=#记录行>#</a></h3><p>记录是以记录行的形式添加到 User Records 中的，下面呢我们大概来了解一下记录行的格式</p><p><img src=/img/recorddata.png alt></p><p>我们看到有很多我们熟悉的</p><ul><li>变长字段列表</li><li>null值列表<ul><li>记录允许为null的字段，是否为null，每个字段使用1bit来表示</li><li>如果所有字段都不能为null，则在记录行中就没有这个部分</li><li>这就是我们经常说的为什么字段设置为null会多占用空间，用1个bit来表示1个nullable字段是否为空</li><li>MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0，就算只有1个字段没有设置not null，那么也需要使用1字节来存储null列表</li><li>另外需要注意的点是，null值列表中表示的字段顺序和后面记录中字段的顺序是相反的。</li></ul></li><li>记录头信息<ul><li>这个在数据页结构很重要，下面我们单独来说</li></ul></li><li>隐藏字段<ul><li>事务id 和 回滚指针。在事务和MVCC中起到重要作用</li></ul></li><li>记录中字段值<ul><li>这个就是我们自己定义的字段里存储的值</li></ul></li></ul><h3 id=记录头信息>记录头信息<a hidden class=anchor aria-hidden=true href=#记录头信息>#</a></h3><table><thead><tr><th align=center>名称</th><th align=center>大小bit</th><th align=center>描述</th></tr></thead><tbody><tr><td align=center><code>预留位1</code></td><td align=center><code>1</code></td><td align=center>没有使用</td></tr><tr><td align=center><code>预留位2</code></td><td align=center><code>1</code></td><td align=center>没有使用</td></tr><tr><td align=center><code>delete_mask</code></td><td align=center><code>1</code></td><td align=center>标记该记录是否被删除</td></tr><tr><td align=center><code>min_rec_mask</code></td><td align=center><code>1</code></td><td align=center>B+树的每层非叶子节点中的最小记录都会添加该标记(只针对索引类型记录)</td></tr><tr><td align=center><code>n_owned</code></td><td align=center><code>4</code></td><td align=center><span style=color:red>表示当前记录拥有的记录数，每个分组的最后一条记录，用来保存这个分组中有几条记录</span></td></tr><tr><td align=center><code>heap_no</code></td><td align=center><code>13</code></td><td align=center>表示当前记录在记录堆的位置信息</td></tr><tr><td align=center><code>record_type</code></td><td align=center><code>3</code></td><td align=center><span style=color:red>表示当前记录的类型，<br><code>0</code>表示普通记录，<br><code>1</code>表示B+树非叶节点记录，也就是索引<br><code>2</code>表示最小记录，<br><code>3</code>表示最大记录</span></td></tr><tr><td align=center><code>next_record</code></td><td align=center><code>16</code></td><td align=center><span style=color:red>表示下一条记录的相对位置; 就是依靠它，一个数据页中的所有记录行，就串成了一个长长的单向链表</span></td></tr></tbody></table><h2 id=page-directory-页面目录>Page Directory(页面目录)<a hidden class=anchor aria-hidden=true href=#page-directory-页面目录>#</a></h2><p>上面我们了解到数据页中存储的就是一条条的记录，每个数据页一般来说有16KB大小，这样的一个数据页根据存储的表数据不同，能够存下几百到上千条记录行。上面我们了解到页中的所有的记录行是一个链表。这样的话如果我们在数据页中查询一条记录，那么就需要遍历整个数据页中的记录行链表，这样的效率十分低下，为了解决这个问题，InnoDB的设计者为每个数据页都建立了一个目录，这个目录就是Page Directory。</p><ul><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。<span style=color:red>分组规则:</span><ul><li>对于最小记录所在的分组只能有 1 条记录</li><li>最大记录所在的分组拥有的记录条数只能在 1~8 条之间</li><li>剩下的分组中记录的条数范围只能在是 4~8 条之间</li></ul></li><li>每个组的最后一条记录（也就是组内主键最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li><li><span style=color:red>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方</span>，这个地方就是所谓的Page Directory，也就是页目录</li></ul><p><img src=/img/pageDirectory.png alt></p><p>有个<code>Page Directory</code>之后，我们在来看一下如何查找记录</p><ul><li>首先我们可以通过二分法先定位到记录所在的分组<ul><li>二分法，首先要求记录是有序的，先找到中间的一条记录，然后对比，如果小，则在左边继续二分，直到找到对应的记录</li><li>首先<code>Page Directory</code>是有序的，并且记录了每个组中最后一条记录的偏移量，所以可以通过偏移量快速的找到组中最后一条记录。</li><li>把要查找的记录和组中的最后一条记录对比，最终找到记录所在的组</li></ul></li><li>找到对应的组后，就可以比遍历组中的记录来找对应的记录了，因为每组内记录较少，可以效率很高<ul><li>在遍历的时候我们需要找到组中最开始的那条记录，但是<code>Page Directory</code>中只记录了最后一条，那怎么处理呢</li><li>别忘了我们所有的记录都在一个大的单向链表中。一个组的最后一条的<code>next record</code>指向的就是下一组的第一条了。</li></ul></li></ul><h2 id=page-header-页面头部>Page Header(页面头部)<a hidden class=anchor aria-hidden=true href=#page-header-页面头部>#</a></h2><p>这一部分用来记录当前数据页的一些状态信息,该部分固定占用56字节，比如</p><ul><li>本页中已经存储了多少条记录</li><li>第一条记录的地址是什么</li><li>页目录中存储了多少个槽</li><li>本页的Free Space地址</li><li><span style=color:red>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</span></li><li>本页在B+树中的层级 等等</li></ul><p>下面是详细的描述</p><table><thead><tr><th align=center>名称</th><th align=center>占用空间大小</th><th align=center>描述</th></tr></thead><tbody><tr><td align=center><code>PAGE_N_DIR_SLOTS</code></td><td align=center><code>2</code>字节</td><td align=center>在页目录中的槽数量</td></tr><tr><td align=center><code>PAGE_HEAP_TOP</code></td><td align=center><code>2</code>字节</td><td align=center>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr><td align=center><code>PAGE_N_HEAP</code></td><td align=center><code>2</code>字节</td><td align=center>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td align=center><code>PAGE_FREE</code></td><td align=center><code>2</code>字节</td><td align=center>第一个已经标记为删除的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td align=center><code>PAGE_GARBAGE</code></td><td align=center><code>2</code>字节</td><td align=center>已删除记录占用的字节数</td></tr><tr><td align=center><code>PAGE_LAST_INSERT</code></td><td align=center><code>2</code>字节</td><td align=center>最后插入记录的位置</td></tr><tr><td align=center><code>PAGE_DIRECTION</code></td><td align=center><code>2</code>字节</td><td align=center>记录插入的方向</td></tr><tr><td align=center><code>PAGE_N_DIRECTION</code></td><td align=center><code>2</code>字节</td><td align=center>一个方向连续插入的记录数量</td></tr><tr><td align=center><code>PAGE_N_RECS</code></td><td align=center><code>2</code>字节</td><td align=center>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td align=center><code>PAGE_MAX_TRX_ID</code></td><td align=center><code>8</code>字节</td><td align=center>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td align=center><code>PAGE_LEVEL</code></td><td align=center><code>2</code>字节</td><td align=center>当前页在B+树中所处的层级</td></tr><tr><td align=center><code>PAGE_INDEX_ID</code></td><td align=center><code>8</code>字节</td><td align=center>索引ID，表示当前页属于哪个索引</td></tr><tr><td align=center><code>PAGE_BTR_SEG_LEAF</code></td><td align=center><code>10</code>字节</td><td align=center>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td align=center><code>PAGE_BTR_SEG_TOP</code></td><td align=center><code>10</code>字节</td><td align=center>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h2 id=file-header-记录>File Header(记录)<a hidden class=anchor aria-hidden=true href=#file-header-记录>#</a></h2><p><span style=color:red>Page Header是专门针对数据页记录的各种状态信息</span>，比方说页里头有多少个记录了呀，有多少个槽了呀。</p><p><span style=color:red>File Header针对各种类型的页都通用，</span>也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁,这个部分占用固定的38个字节，是由下边这些内容组成的：</p><table><thead><tr><th align=center>名称</th><th align=center>占用空间大小</th><th align=center>描述</th></tr></thead><tbody><tr><td align=center><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td align=center><code>4</code>字节</td><td align=center>页的校验和（checksum值）</td></tr><tr><td align=center><code>FIL_PAGE_OFFSET</code></td><td align=center><code>4</code>字节</td><td align=center>页号</td></tr><tr><td align=center><code>FIL_PAGE_PREV</code></td><td align=center><code>4</code>字节</td><td align=center>上一个页的页号</td></tr><tr><td align=center><code>FIL_PAGE_NEXT</code></td><td align=center><code>4</code>字节</td><td align=center>下一个页的页号</td></tr><tr><td align=center><code>FIL_PAGE_LSN</code></td><td align=center><code>8</code>字节</td><td align=center>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td align=center><code>FIL_PAGE_TYPE</code></td><td align=center><code>2</code>字节</td><td align=center>该页的类型</td></tr><tr><td align=center><code>FIL_PAGE_FILE_FLUSH_LSN</code></td><td align=center><code>8</code>字节</td><td align=center>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td align=center><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td align=center><code>4</code>字节</td><td align=center>页属于哪个表空间</td></tr></tbody></table><p>这里我们重点关注几个属性</p><h3 id=fil-page-space-or-chksum>FIL_PAGE_SPACE_OR_CHKSUM<a hidden class=anchor aria-hidden=true href=#fil-page-space-or-chksum>#</a></h3><p>表示该数据页的校验和，和MD5类似，用来校验数据页数据是否完整。</p><h3 id=fil-page-offset>FIL_PAGE_OFFSET<a hidden class=anchor aria-hidden=true href=#fil-page-offset>#</a></h3><p>每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。</p><h3 id=fil-page-type>FIL_PAGE_TYPE<a hidden class=anchor aria-hidden=true href=#fil-page-type>#</a></h3><p>这个代表当前页的类型，我们前边说过，InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p><table><thead><tr><th align=center>类型名称</th><th align=center>十六进制</th><th align=center>描述</th></tr></thead><tbody><tr><td align=center><code>FIL_PAGE_TYPE_ALLOCATED</code></td><td align=center>0x0000</td><td align=center>最新分配，还没使用</td></tr><tr><td align=center><code>FIL_PAGE_UNDO_LOG</code></td><td align=center>0x0002</td><td align=center>Undo日志页</td></tr><tr><td align=center><code>FIL_PAGE_INODE</code></td><td align=center>0x0003</td><td align=center>段信息节点</td></tr><tr><td align=center><code>FIL_PAGE_IBUF_FREE_LIST</code></td><td align=center>0x0004</td><td align=center>Insert Buffer空闲列表</td></tr><tr><td align=center><code>FIL_PAGE_IBUF_BITMAP</code></td><td align=center>0x0005</td><td align=center>Insert Buffer位图</td></tr><tr><td align=center><code>FIL_PAGE_TYPE_SYS</code></td><td align=center>0x0006</td><td align=center>系统页</td></tr><tr><td align=center><code>FIL_PAGE_TYPE_TRX_SYS</code></td><td align=center>0x0007</td><td align=center>事务系统数据</td></tr><tr><td align=center><code>FIL_PAGE_TYPE_FSP_HDR</code></td><td align=center>0x0008</td><td align=center>表空间头部信息</td></tr><tr><td align=center><code>FIL_PAGE_TYPE_XDES</code></td><td align=center>0x0009</td><td align=center>扩展描述页</td></tr><tr><td align=center><code>FIL_PAGE_TYPE_BLOB</code></td><td align=center>0x000A</td><td align=center>BLOB页</td></tr><tr><td align=center><code>FIL_PAGE_INDEX</code></td><td align=center>0x45BF</td><td align=center>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><h3 id=fil-page-prev和fil-page-next>FIL_PAGE_PREV和FIL_PAGE_NEXT<a hidden class=anchor aria-hidden=true href=#fil-page-prev和fil-page-next>#</a></h3><p>一个数据页的大小通常为16KB，如果数据量大，那么就需要很多个数据页来共存存储。多个数据页不可能都被分配到连续的物理内存上，所以通过这两个属性把多个数据页连接起来，形成一个双向链表。</p><p><img src=/img/fileHeader.png alt></p><h2 id=file-trailer>File Trailer<a hidden class=anchor aria-hidden=true href=#file-trailer>#</a></h2><p>我们知道数据页是在硬盘和内存之间不断的被读取和写入的。一个数据页的大小为16KB，那如果在写一个数据页时，中间断电了怎么办，这时候一个数据页只被写了一半的数据。这个时候就要用到我们上面提到的 File Header中的校验和与File Trailer了。</p><p>File Trailer 大小为8字节，有两个部分组成</p><ul><li>前4个字节代表页的校验和</li><li>后4个字节代表页面被最后修改时对应的日志序列位置</li></ul><p>这里我们先关注校验和</p><ul><li>因为FileHeader是在数据页的最上面，所以在写入的时候也是被首先写入的</li><li>File Trailer是在数据的尾部，他的写入是最后完成的</li><li>在正常情况下他们两个的校验和肯定是保持一致的，但是如果发生了我们上面提到的断电的情况，一个数据页只写入了一半。我们就可以通过判断这两个校验和是否一致来判断这个数据页的写入是否完整的完成了。</li></ul><h2 id=数据页结构总结>数据页结构总结<a hidden class=anchor aria-hidden=true href=#数据页结构总结>#</a></h2><p>上面写的内容是为了让大家对数据页有一个基础的了解，下面我试着总结一下</p><ul><li>首先一张数据库表，可能有一个或者多个数据页来组成</li><li>单独的一个数据页在物理空间上是连续的，但是多个数据页就不一定是连续的了，所以这些数据页之间会通过<code>File Header</code>中的 PREV 和 NEXT 指针连接起来，成为一个双向链表</li><li>在每个数据页中，都能够存储多条记录行，存储在 <code>User Record</code>,每次插入新的记录行，都会从<code>Free Space</code>分配空间。</li><li>数据页中的所有记录行(包括最大记录和最小记录)，会通过记录行结构中记录头的<code>next record</code>连接起来，成为一个单向链表</li><li>为了提高在数据页中查询记录的效率，对所有的记录行进行了分组，其中最小记录单独一组，其他记录每4-8条分为一组，最大记录所在的组1-8条。</li><li>并把每个分组的最后一条记录的偏移量保存起来，叫做这个页的目录，也就是 <code>Page Directory</code>,通过页目录中的偏移量，可以快速的找到对应的记录，所以就能够通过二分法确定记录所在的组，然在组内遍历找到对应的记录。</li><li>数据页中保存了多少条记录，分了多少个组，被删除记录的链表头指针，本数据页在B+数中的层级这些信息，被保存在了<code>Page Header</code>中。</li><li>并且为校验数据页在写入过程中是否被中断过，在File Header(数据页头) 和 File Trailer(数据页尾)都添加了校验和，用来校验次数据页是否完整。</li></ul><p>我觉的其中中重要的点就是</p><ul><li><span style=color:red>多个数据页之间是双向链表</span></li><li><span style=color:red>数据页中的记录行是单向链表</span></li><li><span style=color:red>数据页中会对记录行进行分组</span></li></ul><p><img src=/img/dataPage1.png alt></p><h3 id=在单个数据页中的查找流程>在单个数据页中的查找流程<a hidden class=anchor aria-hidden=true href=#在单个数据页中的查找流程>#</a></h3><p>下面在啰嗦一遍在<span style=color:red>一个数据页中查询记录的过程</span></p><blockquote><p>各个数据页可以组成一个双向链表，</p><p>而每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，</p><p>每个数据页都会为存储在它里边儿的记录生成一个页目录，</p><p>在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，</p><p>然后再遍历该槽对应分组中的记录即可快速找到指定的记录</p></blockquote><h1 id=mysql索引数据结构>MySQL索引数据结构<a hidden class=anchor aria-hidden=true href=#mysql索引数据结构>#</a></h1><p>如果说，上面就是索引的数据结构你会不会惊讶？</p><p>但结果就是这样的，索引数据同样采用和上面一样的数据页结构来存储。</p><p>在上面的数据页结构中，我们分析了在一个数据页中如何找到一条记录。</p><p>但是一张大数据量的表中可能包含成千上万个数据页，我们改如何确定这条记录在哪个数据页中呢？</p><ul><li>方案一: 从第一个数据页开始遍历，因为多个数据页之间组成了链表，所以能够整个遍历一遍，那么就能找到这条记录了。显然这样的方式性能十分低下</li><li>方案二: 我们还记得数据页中的<code>Page Directory页目录</code>吗？，我们也可以为多个数据页建立类似的目录结构。 这样我们就能同样使用二分法来确定记录所在的数据页了。</li></ul><p><span style=color:red>是的，其实这就是索引的作用，帮我们快速找到对应记录所在的数据页</span></p><h2 id=innodb的索引方案>InnoDB的索引方案<a hidden class=anchor aria-hidden=true href=#innodb的索引方案>#</a></h2><p>我们对索引的需求是，能够使用二分法快速定位到对应的数据页上，所以我们在索引的结构里需要存储</p><ul><li>数据页的序号(在上面的File Header中提到过，通过它可以快速定位到数据页)</li><li>该数据页主键索引的最大值或者最小值<ul><li>这里InnoDB采用的最小值</li><li><span style=color:red>这里我猜测可能的原因可能是，如果保存最大值，那么表示，每往数据页加入一条新纪录(主键自增的情况)，这个值就需要更新一次。</span></li><li><span style=color:red>如果是最小值，在主键自增的情况下，只有第一次想数据页中加入数据时需要改一次，后续往数据页中插入新的数据都不需要变化。</li></ul></li></ul><p>那么把这两个数据存在什么位置呢？
还记得我们上面说到记录行的记录头信息中有一个<code>record_type</code>字段</p><ul><li>0表示普通记录</li><li>1表示B+树非叶节点记录</li><li>2表示最小记录</li><li>3表示最大记录</li></ul><p>InnoDB就是采用<code>record_type=1</code>的记录行来记录索引信息</p><p>然后把数据页的序号和数据页中最小的主键值存储到记录行的列信息部分。</p><p>然后把这些索引类型的记录行，放到和上面结构一样的数据页中。</p><p>这样我们就完美是，使用同一套数据页格式，既存储了索引数据，有存储了真正的表数据。</p><h3 id=索引记录和普通记录的区别>索引记录和普通记录的区别<a hidden class=anchor aria-hidden=true href=#索引记录和普通记录的区别>#</a></h3><ul><li>索引记录的record_type值是1，而普通用户记录的record_type值是0。</li><li>索引记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列</li><li>记录头中<code>min_rec_mask</code>的区别，如果该记录是索引类型记录，并且该记录是数据页中主键最小的记录，<code>min_rec_mask</code>值为1，其他情况都为0</li></ul><p>除了上述几点外，这两者就没啥差别了，
- 它们用的是一样的数据页。
- 数据页的组成结构也是一样一样的（上面介绍的7个部分），
- 都会为数据页中的记录生成Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p><h3 id=索引结构b-树>索引结构B+树<a hidden class=anchor aria-hidden=true href=#索引结构b-树>#</a></h3><p>我们来看一下，添加了索引数据页之后的结构</p><p><img src=/img/index1.png alt></p><p>我们看到<code>索引数据页</code>中有多条记录行，每条记录行都指向一个<code>用户记录数据页</code>，并保存着指向的这个数据页的最小的主键。</p><p>数据页的大小同样都为16KB，但是存储索引记录的数据页只需要保存2个字段即可，所以一个数据页保存的索引记录的数量要大于保存普通记录的数量。</p><p>在不断向表中添加数据的情况下，肯定会出现一个索引数据页无法保存所有的索引记录，这时候就需要重新分配新的索引数据页。</p><p><img src=/img/index2.png alt></p><p>如果我们继续想表中添加数据，就会生成更多的索引数据页,当索引数据页足够多的时候，如何主键位于哪个索引数据页就同样成为问题。所以我们同样需要为索引数据页建立目录，那么接下来就出现了这样的多层的树状结构</p><p><img src=/img/index3.png alt></p><p>这样的话，只要们知道根节点的位置，就能够从根节点开始按照上面流程，一层层的找到对应的记录数据页，然后找到对应的记录。</p><p>这个树就是B+树。</p><h3 id=b-数的层数>B+数的层数<a hidden class=anchor aria-hidden=true href=#b-数的层数>#</a></h3><p>我们上面说到当索引数据页数量足够多的时候，会出现多层B+数的情况，那么这个层数会很高吗，一般数据量级的表会有几层呢？</p><p>我们来计算一下，因为索引数据页存储的字段少，索引一个数据页能存储的行数肯定比普通数据页多，我们假设一个索引数据页能存数1000条索引行，一个记录数据页能够存储100条记录行</p><ul><li>1层的B+树</li><li>2层的B+树 能够容纳 1000 * 100 = 10W 条数据</li><li>3层的B+树 能够容纳 10W * 1000 = 1亿 条数据</li><li>4层的B+树，能够容纳 1亿 * 1000 = 1000亿 条数据</li></ul><p>当然一个普通记录数据页，根据存储的内容不同，存储的行数肯定也会不一样在几十条到几百条都有可能。
但是总的来说 4层的B+树，肯定能够满足我们绝大多数的需求了。</p><h3 id=索引b-树的生成过程>索引B+树的生成过程<a hidden class=anchor aria-hidden=true href=#索引b-树的生成过程>#</a></h3><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个根节点中。</li><li>当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中，</li><li>而根节点便升级为存储目录项记录的页。</li><li><span style=color:red>一个B+树索引的根节点自诞生之日起，便不会再移动，他会被存储到数据字典中，每当需要使用索引的时候，就会从数据字典中找到根节点的位置，然后使用索引来查找记录</span></li></ul><p>总结一下就是。
- 首先创建一个根页面，然后向根页面插入数据，这时候不需要索引，因为只有一个数据页
- 当根数据页满了之后，就需要增加一个数据页，当数据页的数量超过1个，就需要创建对应的索引数据页
- 因为根数据页的位置不能动，所以会按照上面的流程</p><h2 id=为什么实用b-数>为什么实用B+数<a hidden class=anchor aria-hidden=true href=#为什么实用b-数>#</a></h2><ul><li>多叉树，可以保证树的层数比较低，减少IO的次数<ul><li>一般千万级别的数据的索引，使用3到4层即可</li></ul></li><li>叶子节点有序</li><li>每个节点可以存储多条数据，每个节点可以存储degree -1 条数据
-</li></ul><h2 id=b-树的特点>B+树的特点<a hidden class=anchor aria-hidden=true href=#b-树的特点>#</a></h2><h1 id=索引优化>索引优化<a hidden class=anchor aria-hidden=true href=#索引优化>#</a></h1><ul><li>回表</li><li>覆盖索引</li><li>最左匹配</li><li>索引下推</li></ul><h2 id=建立索引的注意事项>建立索引的注意事项<a hidden class=anchor aria-hidden=true href=#建立索引的注意事项>#</a></h2><ul><li>建立索引的字段不宜太长<ul><li>字段短的话，则在一个数据页中可以存储更多的索引，从而可以减少IO的次数</li><li>当然业务优先</li></ul></li><li>表的主键最好使用自增、<ul><li>在自增的情况下，添加新的数据，只会影响最后面的数据页。</li><li>而不自增的id，会导致页分裂</li><li>比如身份证表中，身份证号是唯一的，但是不适合用来当主键，因为主键是聚簇索引，如果聚簇索引的大小是随机的，会导致很多务必要的数据行移动</li><li>最好添加一列额外的id当做自增主键，哪怕用不到</li></ul></li></ul><h2 id=索引失效条件>索引失效条件<a hidden class=anchor aria-hidden=true href=#索引失效条件>#</a></h2><h2 id=覆盖索引>覆盖索引<a hidden class=anchor aria-hidden=true href=#覆盖索引>#</a></h2><h2 id=索引合并>索引合并<a hidden class=anchor aria-hidden=true href=#索引合并>#</a></h2><h2 id=索引下推>索引下推<a hidden class=anchor aria-hidden=true href=#索引下推>#</a></h2><h2 id=explain>explain<a hidden class=anchor aria-hidden=true href=#explain>#</a></h2><h3 id=字段解释>字段解释<a hidden class=anchor aria-hidden=true href=#字段解释>#</a></h3><h3 id=如果判断实用哪个索引>如果判断实用哪个索引<a hidden class=anchor aria-hidden=true href=#如果判断实用哪个索引>#</a></h3><h3 id=key-length的计算方法>key length的计算方法<a hidden class=anchor aria-hidden=true href=#key-length的计算方法>#</a></h3><h3 id=possible-key-有但是-key-没有的情况>possible key 有但是 key 没有的情况<a hidden class=anchor aria-hidden=true href=#possible-key-有但是-key-没有的情况>#</a></h3><h2 id=索引中null的问题-null会不会被加入到索引中>索引中null的问题，null会不会被加入到索引中？<a hidden class=anchor aria-hidden=true href=#索引中null的问题-null会不会被加入到索引中>#</a></h2><h1 id=mysql执行过程>MySQL执行过程<a hidden class=anchor aria-hidden=true href=#mysql执行过程>#</a></h1><p><a href=https://juejin.cn/post/6844903921450745863>MySQL中IS NULL、IS NOT NULL、!=不能用索引</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://balvboy.github.io/tags/mysql/>mysql</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share MySQL的索引 on twitter" href="https://twitter.com/intent/tweet/?text=MySQL%e7%9a%84%e7%b4%a2%e5%bc%95&url=https%3a%2f%2fbalvboy.github.io%2fblog%2fmysql_index%2f&hashtags=mysql"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL的索引 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbalvboy.github.io%2fblog%2fmysql_index%2f&title=MySQL%e7%9a%84%e7%b4%a2%e5%bc%95&summary=MySQL%e7%9a%84%e7%b4%a2%e5%bc%95&source=https%3a%2f%2fbalvboy.github.io%2fblog%2fmysql_index%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL的索引 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbalvboy.github.io%2fblog%2fmysql_index%2f&title=MySQL%e7%9a%84%e7%b4%a2%e5%bc%95"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL的索引 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbalvboy.github.io%2fblog%2fmysql_index%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL的索引 on whatsapp" href="https://api.whatsapp.com/send?text=MySQL%e7%9a%84%e7%b4%a2%e5%bc%95%20-%20https%3a%2f%2fbalvboy.github.io%2fblog%2fmysql_index%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL的索引 on telegram" href="https://telegram.me/share/url?text=MySQL%e7%9a%84%e7%b4%a2%e5%bc%95&url=https%3a%2f%2fbalvboy.github.io%2fblog%2fmysql_index%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//balvboy.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href=https://balvboy.github.io>ZhouYang's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button>
</a><link rel=stylesheet type=text/css href=/css/table.css><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script><script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>