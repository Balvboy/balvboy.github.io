<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>HTTPS详解 | ZhouYang's Blog</title><meta name=keywords content="https,证书"><meta name=description content="HTTPS详解"><meta name=author content="zhouyang"><link rel=canonical href=https://balvboy.github.io/blog/https%E8%AF%A6%E8%A7%A3/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.3f6a79d84dce1064322991082a04723d5157c86c73768c45927919cf00b4462f.css integrity="sha256-P2p52E3OEGQyKZEIKgRyPVFXyGxzdoxFknkZzwC0Ri8=" rel="preload stylesheet" as=style><link rel=icon href=https://balvboy.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://balvboy.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://balvboy.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://balvboy.github.io/img/favicon.ico><link rel=mask-icon href=https://balvboy.github.io/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-146899866-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="HTTPS详解 "><meta property="og:description" content="HTTPS详解"><meta property="og:type" content="article"><meta property="og:url" content="https://balvboy.github.io/blog/https%E8%AF%A6%E8%A7%A3/"><meta property="og:image" content="https://balvboy.github.io/img/z.jpg"><meta property="article:published_time" content="2021-01-26T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-26T00:00:00+00:00"><meta property="og:site_name" content="Life is Fantastic"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://balvboy.github.io/img/z.jpg"><meta name=twitter:title content="HTTPS详解 "><meta name=twitter:description content="HTTPS详解"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"HTTPS详解 ","name":"HTTPS详解 ","description":"什么是HTTPS HTTPS简单的说就是安全版的HTTP。 因为HTTP协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，为了安全传输敏感数据，网景公司设计了SSL（Secure Socket Layer），在HTTP的基础上添加了一个安全传输层，对所有的数据都加密后再进行传输，客户端和服务器端收到加密数据后按照之前约定好的秘钥解密。 …","keywords":["https","证书"],"articleBody":" 什么是HTTPS HTTPS简单的说就是安全版的HTTP。 因为HTTP协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，为了安全传输敏感数据，网景公司设计了SSL（Secure Socket Layer），在HTTP的基础上添加了一个安全传输层，对所有的数据都加密后再进行传输，客户端和服务器端收到加密数据后按照之前约定好的秘钥解密。\nHTTPS是如何保证安全的 HTTPS的安全性是建立在密码学的基础之上的，有很多算法起到了至关重要的作用。\nHTTPS的交互过程 通过上面的描述，我们已经能大概知道HTTPS是使用加密算法在浏览器和服务器之前传递秘钥，然后再使用秘钥完成信息的加解密。所以这个秘钥是如何生成的，还有秘钥是如何在浏览器和服务器之间传递的就成了HTTPS的关键，下面我们来详细的了解一下这个过程。\n1.交互流程  Client Hello 客户端（通常是浏览器）先向服务器发出加密通信的请求,请求大概中包括下面内容  支持的协议版本，比如TLS 1.0版。 一个客户端生成的随机数 Random Number-RNc，稍后用于生成”对话密钥”。 支持的加解密方法，比如对称加密支持AES，秘钥交换算法支持RSA、DH，签名算法支持sha256等。(在更高版本的TLS协议中，交换的是密码学套件，所谓的套件就是一整套的加解密，秘钥交换方案)。 支持的压缩方法。  服务器收到请求,然后响应  确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 一个服务器生成的随机数Random Number-RNs，稍后用于生成”对话密钥”。 确认使用的加密方法、秘钥交换算法、签名算法等等。 把服务器证书发送给客户端。 服务器要求验证客户端(浏览器)的证书(可选，大部分的服务器都不会要求)。  客户端收到服务器证书之后，会检查证书的有效性，如果服务器证书并不是经过CA机构认证的，浏览器就会在这个时候给用户提出警告。 客户端收到服务器验证客户端证书的请求，会将自己证书发送给服务器。客户端如果没有证书，则需要发送一个不包含证的证书消息。如果服务器需要客户端身份验证才能继续握手，则可能会使用致命的握手失败警报进行响应。(双向认证一般只存在于银行等一些安全性要求比较高的场景中，像早些时候我们使用的网银，里面存储的就是证书，用来在交易的时候和服务器端进行双向认证，保证安全) 服务器收到客户端证书，校验客户端证书是否有效 客户端把把上面流程中发送的所有消息(除了Client Hello)，使用客户端的私钥进行签名，然后发送给服务器。 服务器也保存着之前客户端发送的消息，然后用客户端发送过来的公钥，进行验签。 客户端生成一个Pre-Master-Secret随机数，然后使用服务器证书中的公钥加密，发送给服务器端。 服务器端收到Pre-Master-Secret的加密数据，因为是使用它的公钥加密的，所以可以使用私钥解密得到Pre-Master-Secret。 这时候客户端和服务端都同时知道了，RNc、RNs、Pre-Master-Secret这三个随机数，然后客户端和服务器端使用相同的PRF算法计算得到一个Master-Secret。然后可以从Master-Secret中再生成作为最终客户端和服务器端消息对称加密的秘钥，和对消息进行认证的MAC秘钥。  参考:TLS协议 TLS RFC\n2.Pre-Master-Secret Pre-Master-Secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。 所以，服务端需要对密文中解密出来对的Pre-Master-Secret中的版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被篡改，则立即停止发送任何消息。\n参考：pre-master secret \n3.Master-Secret 客户端和服务端在生成Master-Secret的之后，会把Master-Secret作为PRF的参数，继续运算，最终得到下面6个秘钥，分别用于MAC算法和加解密算法。\n   秘钥名称 秘钥作用     client write MAC key 客户端对发送数据进行MAC计算使用的秘钥，服务端使用同样的秘钥确认数据的完整性   server write MAC key 服务端对返回数据进行MAC计算使用的秘钥，客户端使用同一个秘钥验证完整性   client write key 对称加密key，客户端数据加密，服务端解密   server write key 服务端加密，客户端解密   client write IV 初始化向量，运用于分组对称加密   server write IV 初始化向量，运用于分组对称加密    参考: TLS 中的密钥计算\n4.PRF算法 PRF表示（Pseudo-random Function）伪随机函数\nMaster-secret和最终的6个秘钥都是依靠PRF来生成的。\nPRF是利用hash函数来实现，然后依赖递归可以生成无限长度的序列。具体使用哪种hash算吗，在TLS1.2之后需要的密码学套件中指定。\n然后master-secret和6个秘钥只需要PRF生成满足他们所需要的长度即可。\n比如Master-Secret的长度一直都是48位。\n参考: TLS 中的密钥计算\n5.双向认证 其实我们日常访问的绝大多数网站，都是单向认证的(也就是说并没有上面流程中的3、4、5、6步骤)，这里为例展示HTTPS的完整交互流程，所以分析的是双向认证。 服务器可以选择是否要真正客户端的证书。这里以使用NGINX配置HTTPS为例。 如果我们在NGINX的HTTPS相关配置中添加了下面这个配置，就表示需要验证客户端的证书。\nssl_verify_client on; 6.密码学套件 密码学套件是TLS发展了一段时间积累了很多密码学使用的经验之后提出的一整套的解决方案。一个套件中包含了应用于整个握手和传输使用到的所有非对称加密，对称加密和哈希算法，甚至包括证书的类型。\n密码学套件是SSLv3开始提出的概念，从此，零散的密码学选择问题变成了一个整体的密码学套件选择的问题。后续的版本在升级的时候会产生新的安全强度更高的密码学套件，同时抛弃比较弱的密码学套件\n密码套件分为三大部分：密钥交换算法，数据加密算法，消息验证算法。\n下面来分析一个密码学套件的名称，来解释一下它包含的意思\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA226 * WITH前面表示使用的非对称加密算法，WITH后面表示使用的对称加密和完整性校验算法\n TLS:表示TLS协议，如果未来TLS改名，这个名字可能会变，否则会一直是这个名字 DHE_RSA:这里又两个算法，表示第一个是约定密钥交换的算法，第二个是约定证书的验证算法。如果只有一个，表示这两中操作都是用同一个算法。 AES_256_CBC:指的是AES这种对称加密算法的256位算法的CBC模式，AES本身是一类对称加密算法的统称，实际的使用时要指定位数和计算模式，CBC就是一种基于块的计算模式。 SHA:表示用来校验数据完整性生成MAC，使用的算法，在TLS1.2之后也表示PRF算法使用的算法。  除了这种比较好理解的密码学套件，还有见到一些比较奇怪的，比如 ALL:!EXPORT:!LOW:!aNULL:!SSLv2 我来解释一下，上面出现的字段，更为详细的大家可以去查看下面的文章。 * ALL:表示所有除了明文(eNULL)传递意外的密码学套件 * !EXPORT:EXPORT表示有出口限制的密码学算法，前面加上!,就表示排除掉包含这些算法的密码学套件。 * !LOW:表示排除掉标记为密码强度比较低的算法。 * !aNULL:表示排除不提供身份验证算法的套件。 * !SSLv2:表示排除所有SSLv2的套件。\n大家可以使用openssl ciphers xxx命令查看套件表达式，所包含的密码学套件\n参考: 密码学套件 密码学套件表达式\nHTTPS中的算法 除了了解HTTPS的交互流程，HTTPS中使用的算法及算法的作用，也是我们必须要了解的一部分。 下面会按照算法的作用进行分类，并简单的介绍其中比较常见算法的作用，单并不会对算法的原理做过多的说明(主要是我也弄不明白)，会把相关的讲解原理的文章链接提供出来，大家有兴趣的可以自行去了解。\nHTTPS中算法，根据算法的用途可以分为几大类 * 加密算法 - 加密传递的信息，包括对称加密和非对称加密 * 秘钥传递算法 - 在客户端和服务器端传递加密使用的key，当然通过上面的流程我们知道并不是直接传递加密的key * 信息摘要/签名算法 - 对传递的信息摘要，确保信息在传递过程中不会被篡改\n1.加密算法 加密算法基本可以分为两种 对称加密和非对称加密\n对称加密 顾名思义就是加密和解密都是用一个同样的秘钥，它的优点就行加解密的速度很快，缺点就是尤其需要注意秘钥的传输，不能泄露。 包含的算法有 AES DES RC4等，常用的是AES\n非对称加密-RSA 非对称加密有一对秘钥公钥和私钥。使用公钥加密，然后使用私钥解密。公钥可以公开的发送给任何人。使用公钥加密的内容，只有私钥可以解开。安全性比对称加密大大提高。缺点是和对称加密相比速度较慢，加解密耗费的计算资源较多。\n这里我们先只需要了解RSA之所以安全的原因是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。\n所以这个大整数越大，RSA被破解的难度也就越高。\n具体的算法可以了解下面的两篇文章。\nRSA算法原理1 RSA算法原理2\n2.秘钥交换算法 常见的秘钥交换算法有下面几种： * RSA：算法实现简单，诞生于 1977 年，历史悠久，经过了长时间的破解测试，安全性高。缺点就是需要比较大的素数（目前常用的是 2048 位）来保证安全强度，很消耗 CPU 运算资源。RSA 是目前唯一一个既能用于密钥交换又能用于证书签名的算法。\n DH：diffie-hellman 密钥交换算法，诞生时间比较早（1977 年），但是 1999 年才公开。缺点是比较消耗 CPU 性能。\n ECDHE：使用椭圆曲线（ECC）的 DH 算法，优点是能用较小的素数（256 位）实现 RSA 相同的安全等级。缺点是算法实现复杂，用于密钥交换的历史不长，没有经过长时间的安全攻击测试。\n ECDH：不支持 PFS，安全性低，同时无法实现 false start。\n DHE：不支持 ECC。非常消耗 CPU 资源 。\n  因为这些算法都用到了数论的一些知识，我自己也是似懂非懂。但是他们有一个共同点就是都是运用了质数和模运算相关的数学原理和公式，感觉他们之间应该也是有一定的关联和关系。(后悔没有好好学数学呀)\n参考： RSA和DH算法 ECDHE-wiki DH-wiki Nginx SSL 性能优化\n3.摘要/签名算法 HTTPS中常见的有MD5、SHA256、MAC、HMAC等，下面主要说明一下这些算法的区别和联系。\n1. MD5 是一种消息摘要算法(Message-Digest Algorithm),一种被广泛使用的密码散列函数(Hash Function)，针对任意长度的输入，可以产生出一个定长128位（16字节）的散列值。\n2. SHA SHA表示安全哈希算法(Secure Hash Algorithm)，经过了很长时间的发展SHA算法已经发展成了一个拥有众多算法的SHA家族。常见的有SHA0、SHA1、SHA2(包含SHA224、SHA256等)、SHA3。0，1，2，3表示SHA算法大的版本，每个大版本中又根据输出字节长度的不同分为和不同的算法。比如SHA256 使用的是SHA2，输出的是256字节。更详细的大家可以看下面wiki百科中的内容，很详细。\nSHA称作安全哈希算法的原因是，它相比MD5算法，需要更多的计算次数，最终的输出长度也要长，(SHA0和SHA1是160字节。SHA256是256字节)。如果想要破解需要付出比MD5高的多的计算次数。\n经过长时间的发展，MD5和SHA0、SHA1已经被认为不安全，已经不再建议使用。 SHA2是目前被最常使用的算法，目前还没有针对SHA2的有效攻击。 SHA3是2015年才发布的，还没有大规模的取代SHA2。\n参考 SHA算法家族\n3. MAC 和 HMAC 相对于上面的MD5和SHA，这两种算法对于我算是比较陌生的。\nMAC是消息认证码(Message Authentication Code)的简称。它和上面两种算法的区别是MAC的计算需要一个Key(上面HTTPS流程中就生了计算MAC的KEY)。只有知道了KEY才能正确的计算出对应的MAC。\nHMAC的全称是密钥散列消息认证码(Keyed-hash message authentication code)。是指用秘钥并使用Hash散列算法生成认证码的一类算法的总称。\n那么MAC算法和HMAC算法是什么关系呢？\n我觉得可以这么理解。 MAC只是定义了一个概念—使用一个key，给一段消息生成一个授权码；但是生成这个授权码的算法它并没有定义。所以如果你使用SHA256这种Hash散列算法来生成授权码，那么这种算法就可以被称为HMAC-SHA256。 所以HMAC是MAC的一类实现方式，就像快排是排序算法中的一种实现方式一样。\n参考： MAC-Wiki Difference between MAC and HMAC?\n4. Salted Hash 和 HMAC 加盐Hash和HMAC在某种程度上很相似，但是在使用场景上还是有很大的区别。目前还有没找到解释的比较好的文章，后面再进行补充 * [ ] todo\nHTTPS证书 现在HTTPS基本已经成为了一个网站的标配。想要给一个网站添加对HTTPS的支持，就需要针对这个网站的域名申请证书。\nHTTPS证书类型 这里顺便说明一下目前的HTTPS证书大概分为3类。 * 域名型HTTPS 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站； * 企业型HTTPS 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高； * 增强型HTTPS 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。\n我们看到越是高等级的证书，审核的严格程度也就越高。并在浏览器中会有一定程度的展示，也会给用户一种更为安全的感觉，当然价格也是更加昂贵。\nHTTPS证书内容和结构  Certificate  Version Number（证书版本） Serial Number(序列号) Signature Algorithm ID（该和客户端使用的签名算法） Issuer Name(证书签发者 DN) Validity period(有效期)  Not Before(生效开始时间) Not After(有效结束时间)  Subject name(证书使用者) Subject Public Key Info(证书)  Public Key Algorithm(公钥算法) Subject Public Key(证书公钥)  Issuer Unique Identifier (optional)(签发者唯一身份信息，可选) Subject Unique Identifier (optional)(使用者唯一身份信息，可选) Extensions (optional)(扩展字段)  …  Signature(CA机构对证书的签名)   参考 X.509 wiki X.509 数字证书的基本原理及应用 X.509证书的读取与解释\n如何获得HTTPS证书 简单来说获的HTTPS证书有两种方式 * 在有CA认证的机构申请 * 自己生成\n1.通过CA机构申请 申请CA机构认证的证书大致需要以下步骤\n1.1 生成CSR(Certificate Signing Request)文件 主要方式有两种，本地生成和在线生成\n 通过openssl命令本地生成CSR\nopenssl req -new -nodes -sha256 -newkey rsa:2048 -keyout myprivate.key -out mydomain.csr -new 指定生成一个新的CSR， nodes指定私钥文件不被加密, sha256 指定摘要算法， keyout生成私钥, newkey rsa:2048 指定私钥类型和长度， 最终生成CSR文件mydomain.csr。 通过线上网站生成，一般需要填写下面的内容。   线上的工具会把公钥加入到CSR文件中，并同时生成私钥。\n参考:在线CSR申请\n1.2 CA机构对证书签名 接下来就需要按照CA机构的要求，和想要申请的证书类型，提交相关材料。\nCA收到CSR并验证相关材料，并审核通过之后。需要进行的很重要的一个步骤就是:使用CA机构的私钥对提供证书中的内容进行签名，并把签名的结果存放在证书的数字签名部分。\nCA机构签名完，并发送给我们之后，我们就能够把证书部署在我们的服务器中了。\n2.自己生成证书 参考 自己生成HTTPS证书\n大家可以参考上面的文章自己创建一个证书试试。 自己创建的证书同样可以完成上面的步骤。只不过有一点就是，因为自己生成的证书没有得到CA机构的私钥签名，所以当浏览器通过HTTPS握手获得服务器证书的时候，没有办法确定这个证书是否就是来自请求的服务器。 这个时候浏览器就会给出该网站不安全的提示。\n如果客户端不能确认证书是安全，但是却贸然使用，就会有受到中间人攻击的风险。\n中间人攻击 具体的概念大家可以去下面的文章中了解一下，我们这里直接举例说明一下。\n这种中间人攻击的方式，常见于公共的未加密的WIFI。 * A想和B通讯，建立连接，并请求了B的证书。 * C通过提供公共WIFI的方式，监听了A和B的通讯，拦截了B发送给A的证书，并把证书替换成自己的。 * 如果A没有证书检验机制的话，那么A并不能发现证书已经被替换了。 * A还是以为在和B通讯。就会使用已经被替换了的证书中的公钥(也就是C的公钥)进行加密。 * C拦截到消息，使用自己的私钥解密，获得原始的请求数据。然后就能随意篡改，然后使用B的公钥加密，在发送给B，达到了攻击的目的。\n中间人攻击还有另外一种方式，危害性更大。 如果有恶意程序在我们的手机或者浏览器中安装了一个证书，并且诱导我们把这书设置为信任证书。 那么如果有其他恶意程序，在和我们的终端进行HTTPS握手的时候，发送给我们使用上面的证书签名的证书，那么我们的终端将无法识别这个恶意证书。导致中间人攻击的发生。\n要抵御中间人攻击的一个有效方式就是，充分利用证书的认证机制，还有对于证书的安装和信任要各位谨慎。\n参考：中间人攻击-Wiki\n证书认证链 上面的HTTPS流程中提到，客户端收到服务端证书之后，会进行验证。HTTPS证书的认证是链状的，每一个证书都需要它上级的证书来验证是否有效。\n链式结构 目前我们常见的证书链中一般分为3级。不过中间证书这部分，也有可能又分为多级。但是也是保持这样的链式结构。\n 根证书(Root CA)  中介(中间)证书(Intermediates)  终端实体证书(End-user)    终端证书的签发者是中间证书。 中间证书的签发者是上级中间或者根证书。 根证书的签发者是他自己。\nHTTPS的证书链，是一个自顶向下的信任链，每一个证书都需要它的上级证书来验证有效。所以根证书的作用就尤为重要，如果系统根证书被篡改，系统的安全性就受到威胁。\n根证书一般是通过系统，或者浏览器内置到我们的电脑的中的。系统更新或者浏览器更新的时候，也有可能会添加新的根证书。\n所以不要轻易的信任根证书，除非你是开发者，了解自己的所作所为。\n参考: 数字证书\n验证证书 我们以wiki百科的证书链来举例 当我们和wiki的服务器建立HTTPS连接的时候，会获得wiki的(End-User)证书(后面简称为WK证书)。\n服务器获得WK证书后，会用下面的几个方式来验证证书。\n1.证书有效性时间验证 CA在颁发证书时，都为每个证书设定了有效期，包括开始时间与结束时间。系统当前时间不在证书起止时间的话，都认为证书是无效的。\n2.证书完整性验证 上面证书链的时候说到每个证书需要他的上级证书来确保证书的有效性。这个确保的方式就是数字签名。\n所以我们只需要，使用CA证书中的公钥和对应的签名算法来验证一下签名，就能够确认证书的有效性。\n那么现在有一个问题就是，如何获取WK证书的上一级证书呢？ 这里两种可能 1. 这个证书已经存在于你的电脑中了，直接使用就可以 2. 你的电脑中还没有这个证书，需要下载(这里有个疑问就是，根据什么区下载这个证书，很有可能是签发者的DN，但是查了很多资料，并没有找到证据)\n拿到CA证书之后，就能够使用CA证书中的公钥对WK证书验签了。\n一样的道理，CA证书的有效性需要CA的上级证书，也就是Root证书来证明。验证的过程是基本一致的。\n参考: HTTPS 精读之 TLS 证书校验 证书有效性验证、根证书\n3.IP/域名验证 在申请域名的时候，都会指定证书所针对的域名。所以这里就是验证，当前请求的域名，是否在这个证书所包含的域名列表中。\n证书里面的域名范围通常使用通配符来表示。 但是以*.example.com的二级域名范围就不能包含a.b.example.com这个三级域名。\n4.证书吊销验证 浏览器获取到服务器证书后，需要判断该证书是不是已经被CA机构吊销。如果已经吊销需要浏览器给出提示。\n这里只大概说一下证书的吊销校验主要分2种 1. 通过CRL(Certificate Revocation List) 证书吊销列表 需要定时的去更新CA机构提供的CRL文件，这个里面记录了改CA机构下所有被吊销的证书。CRL目前正在被OCSP取代，因为CRL不及时，并且每个CRL文件，比较大，影响用户体验。 2. 通过OCSP(Online Certificate Status Protocol) 在线证书状态协议 这是一个实时的通过证书的序列号去查询证书状态的协议，但是这个有一个问题是，因为每次建立HTTPS链接都需要请求这个接口，所以如果这个接口响应慢的话，十分影响用户的体验。所以需要浏览器这边有一个策略，就是如果在一定时间内OCSP没有响应，那怎么处理。 如果强依赖OCSP的话，会容易引起OCSP的单点故障。\n详细的胡啊 参考： 你不在意的证书吊销机制 PKI体系中的证书吊销\n总结 HTTPS的相关总结就先到这里，不知道有没有解决大家的疑问。如果有疑问或者问题，欢迎大家在评论区继续沟通。\n参考 HTTPS 基本过程\nTLS 协议\n数字证书\n你不在意的证书吊销机制\nPKI体系中的证书吊销\nHTTPS 精读之 TLS 证书校验\n证书有效性验证、根证书\n数字证书\n中间人攻击-Wiki\n自己生成HTTPS证书\n在线CSR申请\nX.509 wiki\nX.509 数字证书的基本原理及应用\nX.509证书的读取与解释\nMAC-Wiki\nDifference between MAC and HMAC?\nSHA算法家族\nRSA和DH算法\nECDHE-wiki\nDH-wiki\nRSA算法原理1\nRSA算法原理2\n密码学套件\n密码学套件表达式\nTLS 中的密钥计算\npre-master secret \nTLS协议\nTLS RFC\nNginx SSL 性能优化\n","wordCount":"494","inLanguage":"en","datePublished":"2021-01-26T00:00:00Z","dateModified":"2021-01-26T00:00:00Z","author":{"@type":"Person","name":"zhouyang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://balvboy.github.io/blog/https%E8%AF%A6%E8%A7%A3/"},"publisher":{"@type":"Organization","name":"ZhouYang's Blog","logo":{"@type":"ImageObject","url":"https://balvboy.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://balvboy.github.io accesskey=h title="Home (Alt + H)"><img src=/img/zhouyang.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://balvboy.github.io/blog/ title=blogs><span>blogs</span></a></li><li><a href=https://balvboy.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://balvboy.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://balvboy.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?a3d79563dfbd078b66e86495caf11120",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script><script src=/js/mermaid.js></script></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>HTTPS详解</h1><div class=post-description>HTTPS详解</div><div class=post-meta>January 26, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhouyang</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afhttps aria-label=什么是HTTPS>什么是HTTPS</a></li><li><a href=#https%e6%98%af%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%ae%89%e5%85%a8%e7%9a%84 aria-label=HTTPS是如何保证安全的>HTTPS是如何保证安全的</a><ul><li><a href=#https%e7%9a%84%e4%ba%a4%e4%ba%92%e8%bf%87%e7%a8%8b aria-label=HTTPS的交互过程>HTTPS的交互过程</a><ul><li><a href=#1-%e4%ba%a4%e4%ba%92%e6%b5%81%e7%a8%8b aria-label=1.交互流程>1.交互流程</a></li><li><a href=#2-pre-master-secret aria-label=2.Pre-Master-Secret>2.Pre-Master-Secret</a></li><li><a href=#3-master-secret aria-label=3.Master-Secret>3.Master-Secret</a></li><li><a href=#4-prf%e7%ae%97%e6%b3%95 aria-label=4.PRF算法>4.PRF算法</a></li><li><a href=#5-%e5%8f%8c%e5%90%91%e8%ae%a4%e8%af%81 aria-label=5.双向认证>5.双向认证</a></li><li><a href=#6-%e5%af%86%e7%a0%81%e5%ad%a6%e5%a5%97%e4%bb%b6 aria-label=6.密码学套件>6.密码学套件</a></li></ul></li><li><a href=#https%e4%b8%ad%e7%9a%84%e7%ae%97%e6%b3%95 aria-label=HTTPS中的算法>HTTPS中的算法</a><ul><li><a href=#1-%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95 aria-label=1.加密算法>1.加密算法</a><ul><li><a href=#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86 aria-label=对称加密>对称加密</a></li><li><a href=#%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86-rsa aria-label=非对称加密-RSA>非对称加密-RSA</a></li></ul></li><li><a href=#2-%e7%a7%98%e9%92%a5%e4%ba%a4%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=2.秘钥交换算法>2.秘钥交换算法</a></li><li><a href=#3-%e6%91%98%e8%a6%81-%e7%ad%be%e5%90%8d%e7%ae%97%e6%b3%95 aria-label=3.摘要/签名算法>3.摘要/签名算法</a><ul><li><a href=#1-md5 aria-label="1. MD5">1. MD5</a></li><li><a href=#2-sha aria-label="2. SHA">2. SHA</a></li><li><a href=#3-mac-%e5%92%8c-hmac aria-label="3. MAC 和 HMAC">3. MAC 和 HMAC</a></li><li><a href=#4-salted-hash-%e5%92%8c-hmac aria-label="4. Salted Hash 和 HMAC">4. Salted Hash 和 HMAC</a></li></ul></li></ul></li></ul></li><li><a href=#https%e8%af%81%e4%b9%a6 aria-label=HTTPS证书>HTTPS证书</a><ul><li><a href=#https%e8%af%81%e4%b9%a6%e7%b1%bb%e5%9e%8b aria-label=HTTPS证书类型>HTTPS证书类型</a></li><li><a href=#https%e8%af%81%e4%b9%a6%e5%86%85%e5%ae%b9%e5%92%8c%e7%bb%93%e6%9e%84 aria-label=HTTPS证书内容和结构>HTTPS证书内容和结构</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%8e%b7%e5%be%97https%e8%af%81%e4%b9%a6 aria-label=如何获得HTTPS证书>如何获得HTTPS证书</a><ul><li><a href=#1-%e9%80%9a%e8%bf%87ca%e6%9c%ba%e6%9e%84%e7%94%b3%e8%af%b7 aria-label=1.通过CA机构申请>1.通过CA机构申请</a><ul><li><a href=#1-1-%e7%94%9f%e6%88%90csr-certificate-signing-request-%e6%96%87%e4%bb%b6 aria-label="1.1 生成CSR(Certificate Signing Request)文件">1.1 生成CSR(Certificate Signing Request)文件</a></li><li><a href=#1-2-ca%e6%9c%ba%e6%9e%84%e5%af%b9%e8%af%81%e4%b9%a6%e7%ad%be%e5%90%8d aria-label="1.2 CA机构对证书签名">1.2 CA机构对证书签名</a></li></ul></li><li><a href=#2-%e8%87%aa%e5%b7%b1%e7%94%9f%e6%88%90%e8%af%81%e4%b9%a6 aria-label=2.自己生成证书>2.自己生成证书</a></li></ul></li><li><a href=#%e4%b8%ad%e9%97%b4%e4%ba%ba%e6%94%bb%e5%87%bb aria-label=中间人攻击>中间人攻击</a></li><li><a href=#%e8%af%81%e4%b9%a6%e8%ae%a4%e8%af%81%e9%93%be aria-label=证书认证链>证书认证链</a><ul><li><a href=#%e9%93%be%e5%bc%8f%e7%bb%93%e6%9e%84 aria-label=链式结构>链式结构</a></li><li><a href=#%e9%aa%8c%e8%af%81%e8%af%81%e4%b9%a6 aria-label=验证证书>验证证书</a><ul><li><a href=#1-%e8%af%81%e4%b9%a6%e6%9c%89%e6%95%88%e6%80%a7%e6%97%b6%e9%97%b4%e9%aa%8c%e8%af%81 aria-label=1.证书有效性时间验证>1.证书有效性时间验证</a></li><li><a href=#2-%e8%af%81%e4%b9%a6%e5%ae%8c%e6%95%b4%e6%80%a7%e9%aa%8c%e8%af%81 aria-label=2.证书完整性验证>2.证书完整性验证</a></li><li><a href=#3-ip-%e5%9f%9f%e5%90%8d%e9%aa%8c%e8%af%81 aria-label=3.IP/域名验证>3.IP/域名验证</a></li><li><a href=#4-%e8%af%81%e4%b9%a6%e5%90%8a%e9%94%80%e9%aa%8c%e8%af%81 aria-label=4.证书吊销验证>4.证书吊销验证</a></li></ul></li></ul></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><h1 id=什么是https>什么是HTTPS<a hidden class=anchor aria-hidden=true href=#什么是https>#</a></h1><p>HTTPS简单的说就是安全版的HTTP。
因为HTTP协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，为了安全传输敏感数据，网景公司设计了SSL（Secure Socket Layer），在HTTP的基础上添加了一个安全传输层，对所有的数据都加密后再进行传输，客户端和服务器端收到加密数据后按照之前约定好的秘钥解密。</p><h1 id=https是如何保证安全的>HTTPS是如何保证安全的<a hidden class=anchor aria-hidden=true href=#https是如何保证安全的>#</a></h1><p>HTTPS的安全性是建立在密码学的基础之上的，有很多算法起到了至关重要的作用。</p><h2 id=https的交互过程>HTTPS的交互过程<a hidden class=anchor aria-hidden=true href=#https的交互过程>#</a></h2><p>通过上面的描述，我们已经能大概知道HTTPS是使用加密算法在浏览器和服务器之前传递秘钥，然后再使用秘钥完成信息的加解密。所以这个秘钥是如何生成的，还有秘钥是如何在浏览器和服务器之间传递的就成了HTTPS的关键，下面我们来详细的了解一下这个过程。</p><p><img src=/img/Ssl_handshake_with_two_way_authentication_with_certificates.png#center alt=客户端与服务端交互></p><h3 id=1-交互流程>1.交互流程<a hidden class=anchor aria-hidden=true href=#1-交互流程>#</a></h3><ol><li>Client Hello 客户端（通常是浏览器）先向服务器发出加密通信的请求,请求大概中包括下面内容<ul><li>支持的协议版本，比如TLS 1.0版。</li><li>一个客户端生成的随机数 Random Number-RNc，稍后用于生成&rdquo;对话密钥&rdquo;。</li><li>支持的加解密方法，比如对称加密支持AES，秘钥交换算法支持RSA、DH，签名算法支持sha256等。(在更高版本的TLS协议中，交换的是密码学套件，所谓的套件就是一整套的加解密，秘钥交换方案)。</li><li>支持的压缩方法。</li></ul></li><li>服务器收到请求,然后响应<ul><li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li><li>一个服务器生成的随机数Random Number-RNs，稍后用于生成&rdquo;对话密钥&rdquo;。</li><li>确认使用的加密方法、秘钥交换算法、签名算法等等。</li><li>把服务器证书发送给客户端。</li><li>服务器要求验证客户端(浏览器)的证书(可选，大部分的服务器都不会要求)。</li></ul></li><li>客户端收到服务器证书之后，会检查证书的有效性，如果服务器证书并不是经过CA机构认证的，浏览器就会在这个时候给用户提出警告。</li><li>客户端收到服务器验证客户端证书的请求，会将自己证书发送给服务器。客户端如果没有证书，则需要发送一个不包含证的证书消息。如果服务器需要客户端身份验证才能继续握手，则可能会使用致命的握手失败警报进行响应。(双向认证一般只存在于银行等一些安全性要求比较高的场景中，像早些时候我们使用的网银，里面存储的就是证书，用来在交易的时候和服务器端进行双向认证，保证安全)</li><li>服务器收到客户端证书，校验客户端证书是否有效</li><li>客户端把把上面流程中发送的所有消息(除了Client Hello)，使用客户端的私钥进行签名，然后发送给服务器。</li><li>服务器也保存着之前客户端发送的消息，然后用客户端发送过来的公钥，进行验签。</li><li>客户端生成一个Pre-Master-Secret随机数，然后使用服务器证书中的公钥加密，发送给服务器端。</li><li>服务器端收到Pre-Master-Secret的加密数据，因为是使用它的公钥加密的，所以可以使用私钥解密得到Pre-Master-Secret。</li><li>这时候客户端和服务端都同时知道了，RNc、RNs、Pre-Master-Secret这三个随机数，然后客户端和服务器端使用相同的PRF算法计算得到一个Master-Secret。然后可以从Master-Secret中再生成作为最终客户端和服务器端消息对称加密的秘钥，和对消息进行认证的MAC秘钥。</li></ol><p>参考:<a href=https://zhangbuhuai.com/post/tls.html>TLS协议</a>
<a href=https://tools.ietf.org/html/rfc5246>TLS RFC</a></p><h3 id=2-pre-master-secret>2.Pre-Master-Secret<a hidden class=anchor aria-hidden=true href=#2-pre-master-secret>#</a></h3><p>Pre-Master-Secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。
所以，服务端需要对密文中解密出来对的Pre-Master-Secret中的版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被篡改，则立即停止发送任何消息。</p><p>参考：<a href=http://www.linuxidc.com/Linux/2016-05/131147.htm>pre-master secret</a></p><h3 id=3-master-secret>3.Master-Secret<a hidden class=anchor aria-hidden=true href=#3-master-secret>#</a></h3><p>客户端和服务端在生成Master-Secret的之后，会把Master-Secret作为PRF的参数，继续运算，最终得到下面6个秘钥，分别用于MAC算法和加解密算法。</p><table><thead><tr><th>秘钥名称</th><th>秘钥作用</th></tr></thead><tbody><tr><td>client write MAC key</td><td>客户端对发送数据进行MAC计算使用的秘钥，服务端使用同样的秘钥确认数据的完整性</td></tr><tr><td>server write MAC key</td><td>服务端对返回数据进行MAC计算使用的秘钥，客户端使用同一个秘钥验证完整性</td></tr><tr><td>client write key</td><td>对称加密key，客户端数据加密，服务端解密</td></tr><tr><td>server write key</td><td>服务端加密，客户端解密</td></tr><tr><td>client write IV</td><td>初始化向量，运用于分组对称加密</td></tr><tr><td>server write IV</td><td>初始化向量，运用于分组对称加密</td></tr></tbody></table><p>参考: <a href=https://halfrost.com/https-key-cipher/>TLS 中的密钥计算</a></p><h3 id=4-prf算法>4.PRF算法<a hidden class=anchor aria-hidden=true href=#4-prf算法>#</a></h3><p>PRF表示（Pseudo-random Function）伪随机函数</p><p>Master-secret和最终的6个秘钥都是依靠PRF来生成的。</p><p>PRF是利用hash函数来实现，然后依赖递归可以生成无限长度的序列。具体使用哪种hash算吗，在TLS1.2之后需要的密码学套件中指定。</p><p>然后master-secret和6个秘钥只需要PRF生成满足他们所需要的长度即可。</p><p>比如Master-Secret的长度一直都是48位。</p><p>参考: <a href=https://halfrost.com/https-key-cipher/>TLS 中的密钥计算</a></p><h3 id=5-双向认证>5.双向认证<a hidden class=anchor aria-hidden=true href=#5-双向认证>#</a></h3><p>其实我们日常访问的绝大多数网站，都是单向认证的(也就是说并没有上面流程中的3、4、5、6步骤)，这里为例展示HTTPS的完整交互流程，所以分析的是双向认证。
服务器可以选择是否要真正客户端的证书。这里以使用NGINX配置HTTPS为例。
如果我们在NGINX的HTTPS相关配置中添加了下面这个配置，就表示需要验证客户端的证书。</p><pre><code>ssl_verify_client on;</code></pre><h3 id=6-密码学套件>6.密码学套件<a hidden class=anchor aria-hidden=true href=#6-密码学套件>#</a></h3><p>密码学套件是TLS发展了一段时间积累了很多密码学使用的经验之后提出的一整套的解决方案。一个套件中包含了应用于整个握手和传输使用到的所有非对称加密，对称加密和哈希算法，甚至包括证书的类型。</p><p>密码学套件是SSLv3开始提出的概念，从此，零散的密码学选择问题变成了一个整体的密码学套件选择的问题。后续的版本在升级的时候会产生新的安全强度更高的密码学套件，同时抛弃比较弱的密码学套件</p><p>密码套件分为三大部分：密钥交换算法，数据加密算法，消息验证算法。</p><p>下面来分析一个密码学套件的名称，来解释一下它包含的意思</p><p><img src=/img/15898756214901.jpg#center alt=15898756214901.jpg></p><p><code>TLS_DHE_RSA_WITH_AES_256_CBC_SHA226</code>
* WITH前面表示使用的非对称加密算法，WITH后面表示使用的对称加密和完整性校验算法</p><ol><li>TLS:表示TLS协议，如果未来TLS改名，这个名字可能会变，否则会一直是这个名字</li><li>DHE_RSA:这里又两个算法，表示第一个是约定密钥交换的算法，第二个是约定证书的验证算法。如果只有一个，表示这两中操作都是用同一个算法。</li><li>AES_256_CBC:指的是AES这种对称加密算法的256位算法的CBC模式，AES本身是一类对称加密算法的统称，实际的使用时要指定位数和计算模式，CBC就是一种基于块的计算模式。</li><li>SHA:表示用来校验数据完整性生成MAC，使用的算法，在TLS1.2之后也表示PRF算法使用的算法。</li></ol><p>除了这种比较好理解的密码学套件，还有见到一些比较奇怪的，比如
<code>ALL:!EXPORT:!LOW:!aNULL:!SSLv2</code>
我来解释一下，上面出现的字段，更为详细的大家可以去查看下面的文章。
* ALL:表示所有除了明文(eNULL)传递意外的密码学套件
* !EXPORT:EXPORT表示有出口限制的密码学算法，前面加上!,就表示排除掉包含这些算法的密码学套件。
* !LOW:表示排除掉标记为密码强度比较低的算法。
* !aNULL:表示排除不提供身份验证算法的套件。
* !SSLv2:表示排除所有SSLv2的套件。</p><p>大家可以使用<code>openssl ciphers xxx</code>命令查看套件表达式，所包含的密码学套件</p><p><img src=/img/15898713164120.jpg#center alt=15898713164120.jpg></p><p>参考:
<a href=https://zhuanlan.zhihu.com/p/37239435>密码学套件</a>
<a href=https://www.openssl.org/docs/man1.0.2/man1/ciphers.html>密码学套件表达式</a></p><h2 id=https中的算法>HTTPS中的算法<a hidden class=anchor aria-hidden=true href=#https中的算法>#</a></h2><p>除了了解HTTPS的交互流程，HTTPS中使用的算法及算法的作用，也是我们必须要了解的一部分。
下面会按照算法的作用进行分类，并简单的介绍其中比较常见算法的作用，单并不会对算法的原理做过多的说明(主要是我也弄不明白)，会把相关的讲解原理的文章链接提供出来，大家有兴趣的可以自行去了解。</p><p>HTTPS中算法，根据算法的用途可以分为几大类
* 加密算法 - 加密传递的信息，包括对称加密和非对称加密
* 秘钥传递算法 - 在客户端和服务器端传递加密使用的key，当然通过上面的流程我们知道并不是直接传递加密的key
* 信息摘要/签名算法 - 对传递的信息摘要，确保信息在传递过程中不会被篡改</p><h3 id=1-加密算法>1.加密算法<a hidden class=anchor aria-hidden=true href=#1-加密算法>#</a></h3><p>加密算法基本可以分为两种 对称加密和非对称加密</p><h4 id=对称加密>对称加密<a hidden class=anchor aria-hidden=true href=#对称加密>#</a></h4><p>顾名思义就是加密和解密都是用一个同样的秘钥，它的优点就行加解密的速度很快，缺点就是尤其需要注意秘钥的传输，不能泄露。
包含的算法有 AES DES RC4等，常用的是AES</p><h4 id=非对称加密-rsa>非对称加密-RSA<a hidden class=anchor aria-hidden=true href=#非对称加密-rsa>#</a></h4><p>非对称加密有一对秘钥公钥和私钥。使用公钥加密，然后使用私钥解密。公钥可以公开的发送给任何人。使用公钥加密的内容，只有私钥可以解开。安全性比对称加密大大提高。缺点是和对称加密相比速度较慢，加解密耗费的计算资源较多。</p><p>这里我们先只需要了解RSA之所以安全的原因是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。</p><p>所以这个大整数越大，RSA被破解的难度也就越高。</p><p>具体的算法可以了解下面的两篇文章。</p><p><a href=https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html>RSA算法原理1</a>
<a href=http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html>RSA算法原理2</a></p><h3 id=2-秘钥交换算法>2.秘钥交换算法<a hidden class=anchor aria-hidden=true href=#2-秘钥交换算法>#</a></h3><p>常见的秘钥交换算法有下面几种：
* RSA：算法实现简单，诞生于 1977 年，历史悠久，经过了长时间的破解测试，安全性高。缺点就是需要比较大的素数（目前常用的是 2048 位）来保证安全强度，很消耗 CPU 运算资源。RSA 是目前唯一一个既能用于密钥交换又能用于证书签名的算法。</p><ul><li><p>DH：diffie-hellman 密钥交换算法，诞生时间比较早（1977 年），但是 1999 年才公开。缺点是比较消耗 CPU 性能。</p></li><li><p>ECDHE：使用椭圆曲线（ECC）的 DH 算法，优点是能用较小的素数（256 位）实现 RSA 相同的安全等级。缺点是算法实现复杂，用于密钥交换的历史不长，没有经过长时间的安全攻击测试。</p></li><li><p>ECDH：不支持 PFS，安全性低，同时无法实现 false start。</p></li><li><p>DHE：不支持 ECC。非常消耗 CPU 资源 。</p></li></ul><p>因为这些算法都用到了数论的一些知识，我自己也是似懂非懂。但是他们有一个共同点就是都是运用了质数和模运算相关的数学原理和公式，感觉他们之间应该也是有一定的关联和关系。(后悔没有好好学数学呀)</p><p>参考：
<a href="https://blog.csdn.net/u013066244/article/details/79364011?utm_source=blogxgwz4">RSA和DH算法</a>
<a href=https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E6%9B%B2%E7%B7%9A%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B>ECDHE-wiki</a>
<a href=https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B>DH-wiki</a>
<a href=https://luckymrwang.github.io/2015/10/09/Nginx-SSL-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>Nginx SSL 性能优化</a></p><h3 id=3-摘要-签名算法>3.摘要/签名算法<a hidden class=anchor aria-hidden=true href=#3-摘要-签名算法>#</a></h3><p>HTTPS中常见的有MD5、SHA256、MAC、HMAC等，下面主要说明一下这些算法的区别和联系。</p><h4 id=1-md5>1. MD5<a hidden class=anchor aria-hidden=true href=#1-md5>#</a></h4><p>是一种消息摘要算法(Message-Digest Algorithm),一种被广泛使用的密码散列函数(Hash Function)，针对任意长度的输入，可以产生出一个定长128位（16字节）的散列值。</p><h4 id=2-sha>2. SHA<a hidden class=anchor aria-hidden=true href=#2-sha>#</a></h4><p>SHA表示安全哈希算法(Secure Hash Algorithm)，经过了很长时间的发展SHA算法已经发展成了一个拥有众多算法的SHA家族。常见的有SHA0、SHA1、SHA2(包含SHA224、SHA256等)、SHA3。0，1，2，3表示SHA算法大的版本，每个大版本中又根据输出字节长度的不同分为和不同的算法。比如SHA256 使用的是SHA2，输出的是256字节。更详细的大家可以看下面wiki百科中的内容，很详细。</p><p>SHA称作安全哈希算法的原因是，它相比MD5算法，需要更多的计算次数，最终的输出长度也要长，(SHA0和SHA1是160字节。SHA256是256字节)。如果想要破解需要付出比MD5高的多的计算次数。</p><p>经过长时间的发展，MD5和SHA0、SHA1已经被认为不安全，已经不再建议使用。
SHA2是目前被最常使用的算法，目前还没有针对SHA2的有效攻击。
SHA3是2015年才发布的，还没有大规模的取代SHA2。</p><p>参考 <a href=https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F>SHA算法家族</a></p><h4 id=3-mac-和-hmac>3. MAC 和 HMAC<a hidden class=anchor aria-hidden=true href=#3-mac-和-hmac>#</a></h4><p>相对于上面的MD5和SHA，这两种算法对于我算是比较陌生的。</p><p>MAC是消息认证码(Message Authentication Code)的简称。它和上面两种算法的区别是MAC的计算需要一个Key(上面HTTPS流程中就生了计算MAC的KEY)。只有知道了KEY才能正确的计算出对应的MAC。</p><p>HMAC的全称是密钥散列消息认证码(Keyed-hash message authentication code)。是指用秘钥并使用Hash散列算法生成认证码的一类算法的总称。</p><p>那么MAC算法和HMAC算法是什么关系呢？</p><p>我觉得可以这么理解。
MAC只是定义了一个概念&mdash;使用一个key，给一段消息生成一个授权码；但是生成这个授权码的算法它并没有定义。所以如果你使用SHA256这种Hash散列算法来生成授权码，那么这种算法就可以被称为HMAC-SHA256。
所以HMAC是MAC的一类实现方式，就像快排是排序算法中的一种实现方式一样。</p><p>参考：
<a href=https://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC>MAC-Wiki</a>
<a href=https://crypto.stackexchange.com/questions/6523/what-is-the-difference-between-mac-and-hmac>Difference between MAC and HMAC?</a></p><h4 id=4-salted-hash-和-hmac>4. Salted Hash 和 HMAC<a hidden class=anchor aria-hidden=true href=#4-salted-hash-和-hmac>#</a></h4><p>加盐Hash和HMAC在某种程度上很相似，但是在使用场景上还是有很大的区别。目前还有没找到解释的比较好的文章，后面再进行补充
* [ ] todo</p><h1 id=https证书>HTTPS证书<a hidden class=anchor aria-hidden=true href=#https证书>#</a></h1><p>现在HTTPS基本已经成为了一个网站的标配。想要给一个网站添加对HTTPS的支持，就需要针对这个网站的域名申请证书。</p><h2 id=https证书类型>HTTPS证书类型<a hidden class=anchor aria-hidden=true href=#https证书类型>#</a></h2><p>这里顺便说明一下目前的HTTPS证书大概分为3类。
* 域名型HTTPS 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站；
* 企业型HTTPS 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高；
* 增强型HTTPS 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。</p><p><img src=/img/2829175-5c621e00597c6c00.png#center alt=DV,OV></p><p><img src=/img/2829175-ef3241aa68eeb225.png#center alt=EV></p><p>我们看到越是高等级的证书，审核的严格程度也就越高。并在浏览器中会有一定程度的展示，也会给用户一种更为安全的感觉，当然价格也是更加昂贵。</p><h2 id=https证书内容和结构>HTTPS证书内容和结构<a hidden class=anchor aria-hidden=true href=#https证书内容和结构>#</a></h2><p><img src=/img/15898733815306.jpg#center alt=15898733815306.jpg></p><ul><li>Certificate<ul><li>Version Number（证书版本）</li><li>Serial Number(序列号)</li><li>Signature Algorithm ID（该和客户端使用的签名算法）</li><li>Issuer Name(证书签发者 DN)</li><li>Validity period(有效期)<ul><li>Not Before(生效开始时间)</li><li>Not After(有效结束时间)</li></ul></li><li>Subject name(证书使用者)</li><li>Subject Public Key Info(证书)<ul><li>Public Key Algorithm(公钥算法)</li><li>Subject Public Key(证书公钥)</li></ul></li><li>Issuer Unique Identifier (optional)(签发者唯一身份信息，可选)</li><li>Subject Unique Identifier (optional)(使用者唯一身份信息，可选)</li><li>Extensions (optional)(扩展字段)<ul><li>&mldr;</li></ul></li><li>Signature(CA机构对证书的签名)</li></ul></li></ul><p>参考 <a href=https://en.wikipedia.org/wiki/X.509>X.509 wiki</a>
<a href=https://zhuanlan.zhihu.com/p/36832100>X.509 数字证书的基本原理及应用</a>
<a href=https://blog.csdn.net/dickdick111/article/details/84931413>X.509证书的读取与解释</a></p><h2 id=如何获得https证书>如何获得HTTPS证书<a hidden class=anchor aria-hidden=true href=#如何获得https证书>#</a></h2><p>简单来说获的HTTPS证书有两种方式
* 在有CA认证的机构申请
* 自己生成</p><h3 id=1-通过ca机构申请>1.通过CA机构申请<a hidden class=anchor aria-hidden=true href=#1-通过ca机构申请>#</a></h3><p>申请CA机构认证的证书大致需要以下步骤</p><h4 id=1-1-生成csr-certificate-signing-request-文件>1.1 生成CSR(Certificate Signing Request)文件<a hidden class=anchor aria-hidden=true href=#1-1-生成csr-certificate-signing-request-文件>#</a></h4><p>主要方式有两种，本地生成和在线生成</p><ul><li><p>通过openssl命令本地生成CSR</p><pre><code>openssl req -new -nodes -sha256 -newkey rsa:2048 -keyout myprivate.key -out mydomain.csr
-new 指定生成一个新的CSR，
nodes指定私钥文件不被加密, 
sha256 指定摘要算法，
keyout生成私钥, 
newkey rsa:2048 指定私钥类型和长度，
最终生成CSR文件mydomain.csr。</code></pre></li><li><p>通过线上网站生成，一般需要填写下面的内容。
<img src=/img/2829175-31655affc6683c0e.png alt=CSR文件内容></p></li></ul><p>线上的工具会把公钥加入到CSR文件中，并同时生成私钥。</p><p>参考:<a href=https://www.chinassl.net/ssltools/generator-csr.html>在线CSR申请</a></p><h4 id=1-2-ca机构对证书签名>1.2 CA机构对证书签名<a hidden class=anchor aria-hidden=true href=#1-2-ca机构对证书签名>#</a></h4><p>接下来就需要按照CA机构的要求，和想要申请的证书类型，提交相关材料。</p><p>CA收到CSR并验证相关材料，并审核通过之后。需要进行的很重要的一个步骤就是:<code>使用CA机构的私钥对提供证书中的内容进行签名</code>，并把签名的结果存放在证书的数字签名部分。</p><p>CA机构签名完，并发送给我们之后，我们就能够把证书部署在我们的服务器中了。</p><p><img src=/img/2829175-06f817d855a63dd7.png#center alt=CA机构进行签名></p><h3 id=2-自己生成证书>2.自己生成证书<a hidden class=anchor aria-hidden=true href=#2-自己生成证书>#</a></h3><p>参考 <a href=https://www.barretlee.com/blog/2015/10/05/how-to-build-a-https-server/>自己生成HTTPS证书</a></p><p>大家可以参考上面的文章自己创建一个证书试试。
自己创建的证书同样可以完成上面的步骤。只不过有一点就是，因为自己生成的证书没有得到CA机构的私钥签名，所以当浏览器通过HTTPS握手获得服务器证书的时候，没有办法确定这个证书是否就是来自请求的服务器。
这个时候浏览器就会给出该网站不安全的提示。</p><p><img src=/img/2829175-8749dcdef5960ff5.png#center alt=不安全提示></p><p>如果客户端不能确认证书是安全，但是却贸然使用，就会有受到中间人攻击的风险。</p><h2 id=中间人攻击>中间人攻击<a hidden class=anchor aria-hidden=true href=#中间人攻击>#</a></h2><p>具体的概念大家可以去下面的文章中了解一下，我们这里直接举例说明一下。</p><p>这种中间人攻击的方式，常见于公共的未加密的WIFI。
* A想和B通讯，建立连接，并请求了B的证书。
* C通过提供公共WIFI的方式，监听了A和B的通讯，拦截了B发送给A的证书，并把证书替换成自己的。
* 如果A没有证书检验机制的话，那么A并不能发现证书已经被替换了。
* A还是以为在和B通讯。就会使用已经被替换了的证书中的公钥(也就是C的公钥)进行加密。
* C拦截到消息，使用自己的私钥解密，获得原始的请求数据。然后就能随意篡改，然后使用B的公钥加密，在发送给B，达到了攻击的目的。</p><p>中间人攻击还有另外一种方式，危害性更大。
如果有恶意程序在我们的手机或者浏览器中安装了一个证书，并且诱导我们把这书设置为信任证书。
那么如果有其他恶意程序，在和我们的终端进行HTTPS握手的时候，发送给我们使用上面的证书签名的证书，那么我们的终端将无法识别这个恶意证书。导致中间人攻击的发生。</p><p>要抵御中间人攻击的一个有效方式就是，充分利用证书的认证机制，还有对于证书的安装和信任要各位谨慎。</p><p>参考：<a href=https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB>中间人攻击-Wiki</a></p><h2 id=证书认证链>证书认证链<a hidden class=anchor aria-hidden=true href=#证书认证链>#</a></h2><p>上面的HTTPS流程中提到，客户端收到服务端证书之后，会进行验证。HTTPS证书的认证是链状的，每一个证书都需要它上级的证书来验证是否有效。</p><h3 id=链式结构>链式结构<a hidden class=anchor aria-hidden=true href=#链式结构>#</a></h3><p>目前我们常见的证书链中一般分为3级。不过中间证书这部分，也有可能又分为多级。但是也是保持这样的链式结构。</p><ul><li>根证书(Root CA)<ul><li>中介(中间)证书(Intermediates)<ul><li>终端实体证书(End-user)</li></ul></li></ul></li></ul><p>终端证书的签发者是中间证书。
中间证书的签发者是上级中间或者根证书。
根证书的签发者是他自己。</p><p><img src=/img/15900283382545.jpg#center alt=image.png></p><p>HTTPS的证书链，是一个自顶向下的信任链，每一个证书都需要它的上级证书来验证有效。所以根证书的作用就尤为重要，如果系统根证书被篡改，系统的安全性就受到威胁。</p><p>根证书一般是通过系统，或者浏览器内置到我们的电脑的中的。系统更新或者浏览器更新的时候，也有可能会添加新的根证书。</p><p>所以不要轻易的信任根证书，除非你是开发者，了解自己的所作所为。</p><p>参考:
<a href=https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/>数字证书</a></p><h3 id=验证证书>验证证书<a hidden class=anchor aria-hidden=true href=#验证证书>#</a></h3><p>我们以wiki百科的证书链来举例
<img src=/img/15898763181650.jpg#center alt=image.png></p><p>当我们和wiki的服务器建立HTTPS连接的时候，会获得wiki的(End-User)证书(后面简称为WK证书)。</p><p>服务器获得WK证书后，会用下面的几个方式来验证证书。</p><h4 id=1-证书有效性时间验证>1.证书有效性时间验证<a hidden class=anchor aria-hidden=true href=#1-证书有效性时间验证>#</a></h4><p>CA在颁发证书时，都为每个证书设定了有效期，包括开始时间与结束时间。系统当前时间不在证书起止时间的话，都认为证书是无效的。</p><h4 id=2-证书完整性验证>2.证书完整性验证<a hidden class=anchor aria-hidden=true href=#2-证书完整性验证>#</a></h4><p>上面证书链的时候说到每个证书需要他的上级证书来确保证书的有效性。这个确保的方式就是数字签名。</p><p><img src=/img/15898784529557.jpg#center alt=image.png></p><p>所以我们只需要，使用CA证书中的公钥和对应的签名算法来验证一下签名，就能够确认证书的有效性。</p><p>那么现在有一个问题就是，如何获取WK证书的上一级证书呢？
这里两种可能
1. 这个证书已经存在于你的电脑中了，直接使用就可以
2. 你的电脑中还没有这个证书，需要下载(这里有个疑问就是，根据什么区下载这个证书，很有可能是签发者的DN，但是查了很多资料，并没有找到证据)</p><p>拿到CA证书之后，就能够使用CA证书中的公钥对WK证书验签了。</p><p>一样的道理，CA证书的有效性需要CA的上级证书，也就是Root证书来证明。验证的过程是基本一致的。</p><p><img src=/img/15898853354686.jpg#center alt=证书认证链></p><p>参考:
<a href=https://zhuanlan.zhihu.com/p/30655259>HTTPS 精读之 TLS 证书校验</a>
<a href=https://blog.csdn.net/hqy1719239337/article/details/88891118>证书有效性验证、根证书</a></p><h4 id=3-ip-域名验证>3.IP/域名验证<a hidden class=anchor aria-hidden=true href=#3-ip-域名验证>#</a></h4><p>在申请域名的时候，都会指定证书所针对的域名。所以这里就是验证，当前请求的域名，是否在这个证书所包含的域名列表中。</p><p><img src=/img/15900391936813.jpg#center alt=image.png></p><p>证书里面的域名范围通常使用通配符来表示。
但是以*.example.com的二级域名范围就不能包含a.b.example.com这个三级域名。</p><h4 id=4-证书吊销验证>4.证书吊销验证<a hidden class=anchor aria-hidden=true href=#4-证书吊销验证>#</a></h4><p>浏览器获取到服务器证书后，需要判断该证书是不是已经被CA机构吊销。如果已经吊销需要浏览器给出提示。</p><p><img src=/img/15900300060927.jpg#center alt=image.png></p><p>这里只大概说一下证书的吊销校验主要分2种
1. 通过CRL(Certificate Revocation List) 证书吊销列表
需要定时的去更新CA机构提供的CRL文件，这个里面记录了改CA机构下所有被吊销的证书。CRL目前正在被OCSP取代，因为CRL不及时，并且每个CRL文件，比较大，影响用户体验。
2. 通过OCSP(Online Certificate Status Protocol) 在线证书状态协议
这是一个实时的通过证书的序列号去查询证书状态的协议，但是这个有一个问题是，因为每次建立HTTPS链接都需要请求这个接口，所以如果这个接口响应慢的话，十分影响用户的体验。所以需要浏览器这边有一个策略，就是如果在一定时间内OCSP没有响应，那怎么处理。
如果强依赖OCSP的话，会容易引起OCSP的单点故障。</p><p>详细的胡啊
参考：
<a href=https://www.anquanke.com/post/id/183339>你不在意的证书吊销机制</a>
<a href=https://wooyun.js.org/drops/SSL%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%EF%BC%9APKI%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E8%AF%81%E4%B9%A6%E5%90%8A%E9%94%80.html>PKI体系中的证书吊销</a></p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>HTTPS的相关总结就先到这里，不知道有没有解决大家的疑问。如果有疑问或者问题，欢迎大家在评论区继续沟通。</p><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><p><a href=https://hit-alibaba.github.io/interview/basic/network/HTTPS.html>HTTPS 基本过程</a></p><p><a href=https://zhangbuhuai.com/post/tls.html>TLS 协议</a></p><p><a href=https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/>数字证书</a></p><p><a href=https://www.anquanke.com/post/id/183339>你不在意的证书吊销机制</a></p><p><a href=https://wooyun.js.org/drops/SSL%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%EF%BC%9APKI%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E8%AF%81%E4%B9%A6%E5%90%8A%E9%94%80.html>PKI体系中的证书吊销</a></p><p><a href=https://zhuanlan.zhihu.com/p/30655259>HTTPS 精读之 TLS 证书校验</a></p><p><a href=https://blog.csdn.net/hqy1719239337/article/details/88891118>证书有效性验证、根证书</a></p><p><a href=https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/>数字证书</a></p><p><a href=https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB>中间人攻击-Wiki</a></p><p><a href=https://www.barretlee.com/blog/2015/10/05/how-to-build-a-https-server/>自己生成HTTPS证书</a></p><p><a href=https://www.chinassl.net/ssltools/generator-csr.html>在线CSR申请</a></p><p><a href=https://en.wikipedia.org/wiki/X.509>X.509 wiki</a></p><p><a href=https://zhuanlan.zhihu.com/p/36832100>X.509 数字证书的基本原理及应用</a></p><p><a href=https://blog.csdn.net/dickdick111/article/details/84931413>X.509证书的读取与解释</a></p><p><a href=https://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC>MAC-Wiki</a></p><p><a href=https://crypto.stackexchange.com/questions/6523/what-is-the-difference-between-mac-and-hmac>Difference between MAC and HMAC?</a></p><p><a href=https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F>SHA算法家族</a></p><p><a href="https://blog.csdn.net/u013066244/article/details/79364011?utm_source=blogxgwz4">RSA和DH算法</a></p><p><a href=https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E6%9B%B2%E7%B7%9A%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B>ECDHE-wiki</a></p><p><a href=https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B>DH-wiki</a></p><p><a href=https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html>RSA算法原理1</a></p><p><a href=http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html>RSA算法原理2</a></p><p><a href=https://zhuanlan.zhihu.com/p/37239435>密码学套件</a></p><p><a href=https://www.openssl.org/docs/man1.0.2/man1/ciphers.html>密码学套件表达式</a></p><p><a href=https://halfrost.com/https-key-cipher/>TLS 中的密钥计算</a></p><p><a href=http://www.linuxidc.com/Linux/2016-05/131147.htm>pre-master secret</a></p><p><a href=https://zhangbuhuai.com/post/tls.html>TLS协议</a></p><p><a href=https://tools.ietf.org/html/rfc5246>TLS RFC</a></p><p><a href=https://luckymrwang.github.io/2015/10/09/Nginx-SSL-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>Nginx SSL 性能优化</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://balvboy.github.io/tags/https/>https</a></li><li><a href=https://balvboy.github.io/tags/%E8%AF%81%E4%B9%A6/>证书</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share HTTPS详解  on twitter" href="https://twitter.com/intent/tweet/?text=HTTPS%e8%af%a6%e8%a7%a3%20&url=https%3a%2f%2fbalvboy.github.io%2fblog%2fhttps%25E8%25AF%25A6%25E8%25A7%25A3%2f&hashtags=https%2c%e8%af%81%e4%b9%a6"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share HTTPS详解  on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbalvboy.github.io%2fblog%2fhttps%25E8%25AF%25A6%25E8%25A7%25A3%2f&title=HTTPS%e8%af%a6%e8%a7%a3%20&summary=HTTPS%e8%af%a6%e8%a7%a3%20&source=https%3a%2f%2fbalvboy.github.io%2fblog%2fhttps%25E8%25AF%25A6%25E8%25A7%25A3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share HTTPS详解  on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbalvboy.github.io%2fblog%2fhttps%25E8%25AF%25A6%25E8%25A7%25A3%2f&title=HTTPS%e8%af%a6%e8%a7%a3%20"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share HTTPS详解  on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbalvboy.github.io%2fblog%2fhttps%25E8%25AF%25A6%25E8%25A7%25A3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share HTTPS详解  on whatsapp" href="https://api.whatsapp.com/send?text=HTTPS%e8%af%a6%e8%a7%a3%20%20-%20https%3a%2f%2fbalvboy.github.io%2fblog%2fhttps%25E8%25AF%25A6%25E8%25A7%25A3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share HTTPS详解  on telegram" href="https://telegram.me/share/url?text=HTTPS%e8%af%a6%e8%a7%a3%20&url=https%3a%2f%2fbalvboy.github.io%2fblog%2fhttps%25E8%25AF%25A6%25E8%25A7%25A3%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//balvboy.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href=https://balvboy.github.io>ZhouYang's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button>
</a><link rel=stylesheet type=text/css href=/css/table.css><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script><script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>