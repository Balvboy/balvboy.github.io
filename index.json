[{"content":" Java对象头 锁升级和对象头关系很密切，所以我先了解一下对象头。\n我们先来看一下64位系统下对象头的结构，对象头结构分为两部分Mark Word和Klass Word。我们主要关注Mark Word，klass word是指向这个对象的类对象的指针。\n|--------------------------------------------------------------------------------------------------------------| | Object Header (128 bits) | |--------------------------------------------------------------------------------------------------------------| | Mark Word (64 bits) | Klass Word (64 bits) | |--------------------------------------------------------------------------------------------------------------| | unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 无锁 |----------------------------------------------------------------------|--------|------------------------------| | thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 偏向锁 |----------------------------------------------------------------------|--------|------------------------------| | ptr_to_lock_record:62 | lock:2 | OOP to metadata object | 轻量锁 |----------------------------------------------------------------------|--------|------------------------------| | ptr_to_heavyweight_monitor:62 | lock:2 | OOP to metadata object | 重量锁 |----------------------------------------------------------------------|--------|------------------------------| | | lock:2 | OOP to metadata object | GC |--------------------------------------------------------------------------------------------------------------| 对象头的格式在处于不同锁级别的时候，格式有所不同。 - 无锁状态下，可以保存的数据有对象的hashCode，垃圾回收年龄，偏向标识，锁状态 - 偏向状态下，hashCode会被替换成，线程Id,和epoch，同时还有垃圾回收年龄，偏向标识，锁状态 - 轻量级状态下，保留了锁状态，其他部分都被替换成了指向Lock Record的指针。 - 重量级状态下，指向Lock Record的指针被替换成了指向一个Monitor对象的指针。\n这里大家可能会有疑问，在各种锁状态下，都会有部分对象头中的数据被替换成了锁相关的数据，那么被替换的数据都去哪里了呢。 - 偏向锁，hashcode和偏向锁不能共存，在任何情况下调用hashcode，都会导致该锁对象的偏向锁失效。 - 如果在获得偏向锁之前调用了hashcode，会把对象头中的biased_lock设置为0 - 如果在获取锁之后的同步代码块中，调用hashcode，则会导致偏向撤销。 - 轻量级锁，会把被替换的对象头整体放到Lock Record中的 displaced_mark_word中 - 重量级锁，会放到monitor对象的_header中。 下面我们主要主要关注一下和锁状态关系比较密切的几个\nbiased_lock和lock  biased_lock这个标志位表示当前这个锁对象是否可以偏向。0表示不可偏向 1表示可偏向。 lock表示当前锁对象所处的锁级别   下面在开启偏向锁，并且过了4秒钟的默认偏向锁生效时间的前提下我们来分析。\n 创建出来的实例的对象头的后三位为1 01，并且偏向的线程ID也为空,表示当前的实例状态是可偏向、没有偏向线程、没有锁定（也叫做匿名偏向状态） 当有线程对这个实例加锁，这时候线程会偏向这个线程，既对象头中的线程ID修改为这个线程的ID，后三位为1 01,这时候实例状态是，可偏向，偏向某一线程，没有锁定(这里为什么认为是没有锁定，我理解，就是把偏向锁也认为是无锁状态) 这时候有另一个线程，尝试锁定这个实例，这时候会触发偏向锁的撤销，也就是把对象头中的biased_lock标志位从1改为0，并且升级到轻量级锁。这时候如果之前偏向的线程已经执行完毕，这个线程就能顺利的使用轻量级获得锁。这时候后三位是0 00。这时候意思是不可偏向，已轻量级锁定 这时候如果另一个线程来尝试锁定，并且没有获取成功，会导致锁继续升级为重量级锁。这时候后三位是0 10。这时候意思是不可偏向，已重量级锁定  epoch epoch主要和批量重偏向次数有关，每当这个类型实例，发生了一次批量重偏向，就会把实例所属类型的epoch加1，同时把当前所有正在被线程使用的该类型的锁对象，对象头中的epoch加1，这个操作发生在安全点。 所以如果某些锁对象，如果发生批量重偏向的时候，没有被线程使用，那它的epoch就会小于类型中的epoch，当有线程尝试锁定这个锁对象的时候，则会直接进行一次重偏向。让这个锁对象，偏向当前的线程。\n注意这里是把所有正在被线程使用的锁对象的epoch加1，因为上面重偏向逻辑的存在，所以需要保证正在被某个线程持有的锁对象，不会重新偏向给其他线程。\n下面我就按照偏向锁、轻量级锁、重量级锁的顺序来详细了解一下加锁过程，和其中的关键部分。\n锁升级整体流程 为什么要有锁升级 在jdk1.6之前，当一个线程获得synchronized，会阻塞后面的所有其他线程，而java的线程和操作系统的线程是一一映射的，所以阻塞和唤醒线程，都需要操作系统提供支持，都需要从用户态转入内核态，需要耗费大量的CPU的时间，这种状态转换用时可能比执行用户代码的时间还要长。所以在jdk1.6之前，synchronized都是一个重量级的操作，而在jdk1.6之后，对synchronized进行的优化，引入了偏向锁和轻量级锁的概念，使得synchronized的性能得到了很大的提升。jdk1.6之后的synchronized，从偏向锁到轻量级锁，再到重量级锁，让锁随着线程竞争的升级来逐渐升级。\n在有一个线程访问的时候，使用偏向锁，只需要一次比较就能获得锁，性能最好。 在多个线程交替访问的时候，使用轻量级锁，只需要一次CAS操作就可以获得锁（这里说的交替，是指的线程不会同时去争抢锁。一个线程用完了，下一个线程再去获取）。 在存在线程竞争的时候，使用重量级锁。让没有获取到锁的线程进入阻塞状态，避免一些无效的自旋操作，节省CPU资源。\n首先看一下这张图，这是Hotspot官方给出的锁升级过程图，我们先简单分析一下这张图。\n 开启了偏向锁  锁对象刚分配的时候默认锁状态是匿名偏向状态。 有一个线程抢占锁，则在对象头中存储当前线程ID，锁进入偏向状态。 如果发生了重偏向，则会重新回到匿名偏向状态。 如果发生了偏向撤销。  如果发生的时候是无锁状态，则会进入不可偏向的无锁状态。 如果发生的时候是有线程正持有，则会进入轻量级加锁状态。 如果还有另一个线程尝试获取，并且获取失败，就会再升级到重量级。 轻量级和重量级在执行完同步代码之后，锁对象头会回到不可偏向的无锁状态。  偏向锁执行完同步代码之后，不会修改对象头，仍然保持上次的偏向状态。  没有开启偏向锁，则默认分配的就是不可偏向的无锁状态。  有线程尝试获取，则直接轻量级锁定 如果又有另一个线程获取锁，并且轻量级获取失败(也就是上一个线程还没有执行完同步代码)，就会导致锁升级到重量级。 执行完同步代码，对象头回到初始的不可偏向无锁状态。   偏向锁 偏向锁被设计于优化单线程访问下的synchronized，在偏向锁下，只需要一个比较就能够获取锁。 下面我们从C++的源码来分析一下偏向锁的过程\n偏向锁加锁 CASE(_monitorenter): { oop lockee = STACK_OBJECT(-1); // derefing\u0026#39;s lockee ought to provoke implicit null check  CHECK_NULL(lockee); // find a free monitor or one already allocated for this object  // if we find a matching object then we need a new monitor  // since this is recursive enter  BasicObjectLock* limit = istate-\u0026gt;monitor_base(); BasicObjectLock* most_recent = (BasicObjectLock*) istate-\u0026gt;stack_base(); BasicObjectLock* entry = NULL; //从当前线程栈中获取一个空闲的BasicObjectLock  while (most_recent != limit ) { if (most_recent-\u0026gt;obj() == NULL) entry = most_recent; else if (most_recent-\u0026gt;obj() == lockee) break; most_recent++; } //获取BasicObjectLock成功  if (entry != NULL) { //将线程栈中的BasicObjectLock的obj指针指向锁对象  entry-\u0026gt;set_obj(lockee); int success = false; uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place; //获取当前锁对象的对象头，用来进行下面的判断  markOop mark = lockee-\u0026gt;mark(); intptr_t hash = (intptr_t) markOopDesc::no_hash; // implies UseBiasedLocking  //判断锁对象是否是是偏向模式  if (mark-\u0026gt;has_bias_pattern()) { uintptr_t thread_ident; uintptr_t anticipated_bias_locking_value; thread_ident = (uintptr_t)istate-\u0026gt;thread(); //下面这个操作，可以理解为为了方便进行后面的运算，可以说是比较骚的一种玩法，我们可以不用过分关注  anticipated_bias_locking_value = (((uintptr_t)lockee-\u0026gt;klass()-\u0026gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) \u0026amp; ~((uintptr_t) markOopDesc::age_mask_in_place); //value = 0 表示已经偏向，并且偏向的就是自己，而且epoch和klass的epoch也相同，什么都不用做，直接获得偏向锁  if (anticipated_bias_locking_value == 0) { // already biased towards this thread, nothing to do  if (PrintBiasedLockingStatistics) { //如果需要统计偏向锁重入次数，可以使用biased_lock_entry_count_addr统计  (* BiasedLocking::biased_lock_entry_count_addr())++; } //标记状态为获取锁成功  success = true; } //对象的Klass的对象头不是偏向模式，则撤销偏向  else if ((anticipated_bias_locking_value \u0026amp; markOopDesc::biased_lock_mask_in_place) != 0) { // try revoke bias  markOop header = lockee-\u0026gt;klass()-\u0026gt;prototype_header(); if (hash != markOopDesc::no_hash) { header = header-\u0026gt;copy_set_hash(hash); } if (Atomic::cmpxchg_ptr(header, lockee-\u0026gt;mark_addr(), mark) == mark) { if (PrintBiasedLockingStatistics) (*BiasedLocking::revoked_lock_entry_count_addr())++; } } //当前对象的对象头epoch不等于Klass中的epoch，则尝试重新偏向  else if ((anticipated_bias_locking_value \u0026amp; epoch_mask_in_place) !=0) { // try rebias  markOop new_header = (markOop) ( (intptr_t) lockee-\u0026gt;klass()-\u0026gt;prototype_header() | thread_ident); if (hash != markOopDesc::no_hash) { new_header = new_header-\u0026gt;copy_set_hash(hash); } //进行CAS将对象头中线程Id替换为自己，如果替换成功，则偏向成功  if (Atomic::cmpxchg_ptr((void*)new_header, lockee-\u0026gt;mark_addr(), mark) == mark) { if (PrintBiasedLockingStatistics) (* BiasedLocking::rebiased_lock_entry_count_addr())++; } //替换失败，表示有多个线程并发争抢，则开始锁的升级  else { CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception); } success = true; } else { //重新偏向， 如果markOop是匿名偏向的时候会偏向当前线程成功  //走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）  // try to bias towards thread in case object is anonymously biased  //构建一个匿名偏向的对象头  markOop header = (markOop) ((uintptr_t) mark \u0026amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place | (uintptr_t)markOopDesc::age_mask_in_place | epoch_mask_in_place)); if (hash != markOopDesc::no_hash) { header = header-\u0026gt;copy_set_hash(hash); } markOop new_header = (markOop) ((uintptr_t) header | thread_ident); // debugging hint  DEBUG_ONLY(entry-\u0026gt;lock()-\u0026gt;set_displaced_header((markOop) (uintptr_t) 0xdeaddead);) //进行CAS替换，如果替换成功，则偏向成功(只有markOop是匿名偏向的时候，才会替换成功)  if (Atomic::cmpxchg_ptr((void*)new_header, lockee-\u0026gt;mark_addr(), header) == header) { if (PrintBiasedLockingStatistics) (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++; } //失败，则升级  else { CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception); } success = true; } } // traditional lightweight locking  //轻量级锁  if (!success) { //设置当前的对象头为无锁状态，并且复制到Lock Record中的markoop中  markOop displaced = lockee-\u0026gt;mark()-\u0026gt;set_unlocked(); entry-\u0026gt;lock()-\u0026gt;set_displaced_header(displaced); bool call_vm = UseHeavyMonitors; //将对象头中的地址替换为指向Lock Record的指针，替换成功，则说明获取轻量级锁成功,则什么都不做。  //这里判断，如果是替换失败，则继续判断是否是锁重入。  if (call_vm || Atomic::cmpxchg_ptr(entry, lockee-\u0026gt;mark_addr(), displaced) != displaced) { // Is it simple recursive case?  //这里判断是不是锁重入，判断指向Lock Record的指针指向的地址是否属于当前线程栈  if (!call_vm \u0026amp;\u0026amp; THREAD-\u0026gt;is_lock_owned((address) displaced-\u0026gt;clear_lock_bits())) { //如果是轻量级锁的锁重入,说明前面set_displaced_header设置的是第一个Lock Record的地址，  //所以要重新将申请的Lock Record的displaced_header置为空,同样也会通过申请的displaced_header的个数来统计轻量级锁的重入次数  //栈的最高位的Lock Record的displaced_header不是空，重入锁退出锁的时候，会由低到高遍历退出，只在最后一个锁的时候使用CAS替换  entry-\u0026gt;lock()-\u0026gt;set_displaced_header(NULL); } else { //替换失败，则进行锁升级  CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception); } } } UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1); } else { istate-\u0026gt;set_msg(more_monitors); UPDATE_PC_AND_RETURN(0); // Re-execute  } }  通过代码我们可以知道在偏向锁的获取过程主要进行了几个判断\n 锁本省的偏向模式是否关闭 锁的epoch和proto header是否一致并且当前得前程ID和已经偏向的线程ID是否一致 锁类型的偏向模式(proto header)是否关闭  具体流程如下\n 获得一个可用的Lock Record，并把锁对象设置到lock record的obj中。 判断锁对象是否处于偏向模式  如果不是偏向模式，则直接走轻量级流程 是偏向模式  判断是不是已经偏向了当前线程，并且epoch和proto header中相同。并且proto header中也是偏向模式  如果是，则设置success = true，表示直接获取成功。  如果不是，则判断proto header中是否关闭了偏向模式  如果proto header关闭了偏向模式，则构建一个通过proto header构建一个新的对象头，并CAS设置到锁对象头中，完成偏向撤销，然后走轻量级逻辑。（对象头状态: 偏向模式-\u0026gt;撤销偏向）  如果没有关闭，则继续判断，是不是epoch不同  如果是epoch不同，则表示发生了批量重偏向，然后构建一个偏向当前线程的对象头，然后CAS设置到锁对象头。  如果CAS成功，则设置success = true，表示获取偏向锁成功。（对象头状态: 偏向其他线程-\u0026gt;重新偏向当前线程） 如果CAS失败，则表示在这一步发生了线程并发获取锁的操作，则直接调用monitorenter锁升级。   如果都不满足上面的情况，那就是标明，当前锁对象头处于匿名偏向状态，或者偏向了其他线程，那构建一个偏向当前线程的对象头，和匿名偏向的对象头，然后CAS替换到锁对象头中，这里只有锁是匿名偏向状态的时候才会替换成功  如果设置成功，则设置success= true，表示获取偏向锁成功。（对象头状态: 匿名偏向-\u0026gt;偏向当前线程） 如果设置失败，说明锁已经偏向了其他线程，则直接调用monitorenter锁升级。      偏向锁撤销 如果一直只有一个线程持有这个锁，那么这个锁会一直保持偏向状态，并且获取所得操作只需要一次判断，效率最高。 如果一旦出现了另一个线程，尝试获取这个锁对象，就会触发偏向锁的撤销。 偏向撤销，是指把锁对象头中的bias_lock修改为0，这样可以让后续的获取锁的步骤中，跳过偏向流程，直接进入轻量级逻辑。 撤销会有三种情况 1. 锁对象处于匿名偏向状态时发起的偏向撤销。比如这个锁对象在没有被任何线程获取之前，调用了hashcode()方法。 2. 持有偏向锁的线程自己发起的偏向撤销，比如在同步方法里调用了hashcode()方法。 3. 一个线程持有偏向锁，另一个线程也尝试获取，导致的偏向撤销。\n前两种情况的撤销，不会对任何线程产生影响，所以可以不用等待安全点，直接操作就行。而且第一种，因为没有任何线程获取过它，所以直接使用CAS操作替换就行。 第三种情况，因为直接撤销的话，有可能会对正持有偏向锁的线程产生影响，为了避免这种影响，所以需要在安全点来进行。\n下面我们通过代码来分析一下这个过程。\nfast_enter //obj 是锁对象 //lock 是线程栈中的 lock record，存储了displaced header //attempt_rebias 是是否允许重偏向，我们这里是true void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, bool attempt_rebias, TRAPS) { //判断是否开启偏向锁,如果没开启这走slow_enter升级  if (UseBiasedLocking) { //判断是否是业务线程触发的撤销  if (!SafepointSynchronize::is_at_safepoint()) { BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD); if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) { return; } } else { //这里表示是由vm线程触发的  assert(!attempt_rebias, \u0026#34;can not rebias toward VM thread\u0026#34;); BiasedLocking::revoke_at_safepoint(obj); } assert(!obj-\u0026gt;mark()-\u0026gt;has_bias_pattern(), \u0026#34;biases should be revoked by now\u0026#34;); } //执行锁升级  slow_enter(obj, lock, THREAD); }  revoke_and_rebias 我们先列举一下这个方法的返回值\n BIAS_REVOKED_AND_REBIASED 偏向撤销并已重偏向 BIAS_REVOKED 偏向已撤销 NOT_BIASED 没有偏向  我们看到fast_enter的逻辑中，只要revoke_and_rebias()方法返回的不是BIAS_REVOKED_AND_REBIASED,那么最终都会执行到slow_enter中进行锁升级。\n下面我们来看revoke_and_rebias()方法的实现。\nBiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) { assert(!SafepointSynchronize::is_at_safepoint(), \u0026#34;must not be called while at safepoint\u0026#34;); // We can revoke the biases of anonymously-biased objects  // efficiently enough that we should not cause these revocations to  // update the heuristics because doing so may cause unwanted bulk  // revocations (which are expensive) to occur.  //获取锁的对象头  markOop mark = obj-\u0026gt;mark(); //1. 如果不允许重新偏向，并且锁处于匿名偏向  if (mark-\u0026gt;is_biased_anonymously() \u0026amp;\u0026amp; !attempt_rebias) { // We are probably trying to revoke the bias of this object due to  // an identity hash code computation. Try to revoke the bias  // without a safepoint. This is possible if we can successfully  // compare-and-exchange an unbiased header into the mark word of  // the object, meaning that no other thread has raced to acquire  // the bias of the object.  markOop biased_value = mark; //构建撤销了偏向模式的对象头  markOop unbiased_prototype = markOopDesc::prototype()-\u0026gt;set_age(mark-\u0026gt;age()); //CAS替换锁对象的对象头  markOop res_mark = (markOop)Atomic::cmpxchg_ptr(unbiased_prototype, obj-\u0026gt;mark_addr(), mark); //如果替换成功，则撤销完成，然后通过slow_enter进行锁升级即可  //如果替换失败，说明此时锁已经被其他线程获取，则会通过下面的逻辑走由JVM线程发起的单个撤销  if (res_mark == biased_value) { return BIAS_REVOKED; } //2. 如果不是匿名偏向，或者是允许重偏向，并且锁对象是偏向模式  //这里大多数情况是，锁偏向了某个线程。  } else if (mark-\u0026gt;has_bias_pattern()) { Klass* k = obj-\u0026gt;klass(); //获取Klass的markOop  markOop prototype_header = k-\u0026gt;prototype_header(); //2.1. 如果Klass的Oop不是偏向模式则执行  //表示锁对象所属的类型，已经关闭了偏向模式，发生了批量撤销  if (!prototype_header-\u0026gt;has_bias_pattern()) { // This object has a stale bias from before the bulk revocation  // for this data type occurred. It\u0026#39;s pointless to update the  // heuristics at this point so simply update the header with a  // CAS. If we fail this race, the object\u0026#39;s bias has been revoked  // by another thread so we simply return and let the caller deal  // with it.  markOop biased_value = mark; markOop res_mark = (markOop) Atomic::cmpxchg_ptr(prototype_header, obj-\u0026gt;mark_addr(), mark); assert(!(*(obj-\u0026gt;mark_addr()))-\u0026gt;has_bias_pattern(), \u0026#34;even if we raced, should still be revoked\u0026#34;); return BIAS_REVOKED; //2.2 . 如果Klass markOop和锁对象的markOop的epoch不同，则执行  //这里是说明锁对象仍然处于偏向模式，但是发生了一次批量重偏向，导致epoch不同了  } else if (prototype_header-\u0026gt;bias_epoch() != mark-\u0026gt;bias_epoch()) { // The epoch of this biasing has expired indicating that the  // object is effectively unbiased. Depending on whether we need  // to rebias or revoke the bias of this object we can do it  // efficiently enough with a CAS that we shouldn\u0026#39;t update the  // heuristics. This is normally done in the assembly code but we  // can reach this point due to various points in the runtime  // needing to revoke biases.  // 如果允许重偏向  if (attempt_rebias) { assert(THREAD-\u0026gt;is_Java_thread(), \u0026#34;\u0026#34;); markOop biased_value = mark; //构建一个偏向当前线程的对象头  markOop rebiased_prototype = markOopDesc::encode((JavaThread*) THREAD, mark-\u0026gt;age(), prototype_header-\u0026gt;bias_epoch()); //cas替换  markOop res_mark = (markOop) Atomic::cmpxchg_ptr(rebiased_prototype, obj-\u0026gt;mark_addr(), mark); // 如果替换成功，返回BIAS_REVOKED_AND_REBIASED，表示获取锁成功  //替换失败，则走下面的偏向撤销流程  if (res_mark == biased_value) { return BIAS_REVOKED_AND_REBIASED; } } else { // 如果不允许重偏向，则进行偏向撤销  markOop biased_value = mark; markOop unbiased_prototype = markOopDesc::prototype()-\u0026gt;set_age(mark-\u0026gt;age()); markOop res_mark = (markOop) Atomic::cmpxchg_ptr(unbiased_prototype, obj-\u0026gt;mark_addr(), mark); if (res_mark == biased_value) { return BIAS_REVOKED; } } } } //3. 如果锁对象已经偏向了某个线程，而且proto header中偏向模式没有关闭，  //epoch 也相同的话(也就是偏向了某个线程，但是没有发生批量重偏向和批量撤销)  //则后走下面的逻辑  //update_heuristics 这个方法就是决定接下来改进行什么样的操作  HeuristicsResult heuristics = update_heuristics(obj(), attempt_rebias); if (heuristics == HR_NOT_BIASED) { return NOT_BIASED; } else if (heuristics == HR_SINGLE_REVOKE) { //3.1 开始单个撤销  Klass *k = obj-\u0026gt;klass(); markOop prototype_header = k-\u0026gt;prototype_header(); //当前对象偏向当前线程，并且对象的epoch和Klass的Epoch相同，则直接开始执行撤销，  //也就是说是线程自己发起的偏向撤销，就是我们上面提到的在同步代码中，调用了hashcode方法  if (mark-\u0026gt;biased_locker() == THREAD \u0026amp;\u0026amp; prototype_header-\u0026gt;bias_epoch() == mark-\u0026gt;bias_epoch()) { // A thread is trying to revoke the bias of an object biased  // toward it, again likely due to an identity hash code  // computation. We can again avoid a safepoint in this case  // since we are only going to walk our own stack. There are no  // races with revocations occurring in other threads because we  // reach no safepoints in the revocation path.  // Also check the epoch because even if threads match, another thread  // can come in with a CAS to steal the bias of an object that has a  // stale epoch.  ResourceMark rm; if (TraceBiasedLocking) { tty-\u0026gt;print_cr(\u0026#34;Revoking bias by walking my own stack:\u0026#34;); } //因为是自己线程发起的，所以直接进行撤销操作，不需要等待安全点，这里allow_rebias 也是false  BiasedLocking::Condition cond = revoke_bias(obj(), false, false, (JavaThread*) THREAD); ((JavaThread*) THREAD)-\u0026gt;set_cached_monitor_info(NULL); assert(cond == BIAS_REVOKED, \u0026#34;why not?\u0026#34;); return cond; } else { //3.2 如果需要撤销的不是当前线程，则需要等待线程安全点，之后Jvm在线程安全点会触发撤销程序  VM_RevokeBias revoke(\u0026amp;obj, (JavaThread*) THREAD); VMThread::execute(\u0026amp;revoke); return revoke.status_code(); } } //批量撤销和批量重偏向，注意这里，会把attempt_rebias传过去  assert((heuristics == HR_BULK_REVOKE) || (heuristics == HR_BULK_REBIAS), \u0026#34;?\u0026#34;); VM_BulkRevokeBias bulk_revoke(\u0026amp;obj, (JavaThread*) THREAD, (heuristics == HR_BULK_REBIAS), attempt_rebias); VMThread::execute(\u0026amp;bulk_revoke); return bulk_revoke.status_code(); }  首先\n 判断: 是否处于匿名偏向状态，并且不允许重新偏向  这是我们上面说到的撤销的第一种情况，在同步代码块执行前，调用了锁对象的hashcode()方法。  判断：是否锁对象处于偏向模式，包括匿名偏向和偏向了某一个线程  判断: 是否Class已经关闭了偏向模式  说明发生了偏向撤销 直接使用Class的proto header替换锁对象的对象头，完成撤销操作  判断: 锁对象和Class的epoch是否不同  epoch不同说明，发生了批量重偏向 根据attempt_rebias来处理，如果为true则尝试重偏向，如果为false，则执行偏向撤销\n   无法简单的判断如何操作，需要根据Class中记录的偏向撤销信息来进行决策  走到这里条件是:已经偏向了某个线程、Class的偏向模式没有关闭、epoch相同 如果是返回HR_SINGLE_REVOKE  判断: 当前线程是否为持有锁线程，并且epoch相同。  这里是我们上面提到的撤销3种情况中的，在同步代码快中调用了hashcode()方法 如果是则直接由当前线程调用revoke_bias完成撤销，因为自己发起的，不会导致持有锁线程的异常。 如果不是，则需要交给JVM线程，在安全点调用revoke_bias完成撤销。   如果返回的HR_BULK_REVOKE和HR_BULK_REBIAS，则由JVM线程，在安全点完成批量撤销和批量重偏向。    update_heuristics JVM通过这个方法来进行偏向撤销的决策。 先说一下这个决策的数据依据。 - 每个锁对象，发生一次偏向撤销，都会在这个锁对象所属的Class中记录下来，称谓偏向撤销次数 - 每当发生了批量撤销，也会记录下来最近一次发生的时间。 - 用户设置的批量重偏向阈值和批量撤销阈值，新一次批量重偏向延迟时间\n-XX:BiasedLockingBulkRebiasThreshold=20 偏向锁批量重偏向阈值 -XX:BiasedLockingBulkRevokeThreshold=40 偏向锁批量撤销阈值 JVM就是根据上面这些数据来进行计算决策的。\nstatic HeuristicsResult update_heuristics(oop o, bool allow_rebias) { markOop mark = o-\u0026gt;mark(); //如果不是偏向模式直接返回  if (!mark-\u0026gt;has_bias_pattern()) { return HR_NOT_BIASED; } // 锁对象的类  Klass* k = o-\u0026gt;klass(); // 当前时间  jlong cur_time = os::javaTimeMillis(); // 上一次批量撤销或者批量重偏向的时间  // 因为批量撤销和批量重偏向都是同一个方法，所以都会更新这个时间  jlong last_bulk_revocation_time = k-\u0026gt;last_biased_lock_bulk_revocation_time(); // 该类偏向锁撤销的次数  int revocation_count = k-\u0026gt;biased_lock_revocation_count(); // BiasedLockingBulkRebiasThreshold是重偏向阈值（默认20），  //BiasedLockingBulkRevokeThreshold是批量撤销阈值（默认40），  //BiasedLockingDecayTime是开启一次新的批量重偏向距离上次批量重偏向或者批量撤销后的延迟时间，默认25000。也就是开启批量重偏向后，  //经过了一段较长的时间（\u0026gt;=BiasedLockingDecayTime），撤销计数器才超过阈值，那我们会重置计数器。  if ((revocation_count \u0026gt;= BiasedLockingBulkRebiasThreshold) \u0026amp;\u0026amp; (revocation_count \u0026lt; BiasedLockingBulkRevokeThreshold) \u0026amp;\u0026amp; (last_bulk_revocation_time != 0) \u0026amp;\u0026amp; (cur_time - last_bulk_revocation_time \u0026gt;= BiasedLockingDecayTime)) { // This is the first revocation we\u0026#39;ve seen in a while of an  // object of this type since the last time we performed a bulk  // rebiasing operation. The application is allocating objects in  // bulk which are biased toward a thread and then handing them  // off to another thread. We can cope with this allocation  // pattern via the bulk rebiasing mechanism so we reset the  // klass\u0026#39;s revocation count rather than allow it to increase  // monotonically. If we see the need to perform another bulk  // rebias operation later, we will, and if subsequently we see  // many more revocation operations in a short period of time we  // will completely disable biasing for this type.  k-\u0026gt;set_biased_lock_revocation_count(0); revocation_count = 0; } // 自增撤销计数器  if (revocation_count \u0026lt;= BiasedLockingBulkRevokeThreshold) { revocation_count = k-\u0026gt;atomic_incr_biased_lock_revocation_count(); } // 如果达到批量撤销阈值则返回HR_BULK_REVOKE  if (revocation_count == BiasedLockingBulkRevokeThreshold) { return HR_BULK_REVOKE; } // 如果达到批量重偏向阈值则返回HR_BULK_REBIAS  if (revocation_count == BiasedLockingBulkRebiasThreshold) { return HR_BULK_REBIAS; } // 没有达到阈值则撤销单个对象的锁  return HR_SINGLE_REVOKE; }   获取偏向撤销次数、上次批量撤销的时间 然后就是一个比较长的判断  撤销次数大于等于重偏向阈值20，小于批量撤销阈值40，并且发生过重偏向或者批量撤销，并且距离上次发生的时间超过了25000ms，那么我们就把撤销次数清零。 这个判断的意思是，如果一个类型发生过批量操作，但是在接下来的很长时间内，都没有达到下一次批量操作的触发条件，那么JVM就会认为，这个类型的锁对象线程争抢不严重，为了避免它达到批量撤销阈值，从而再也不能使用偏向模式，而把撤销计数归0\n  然后就是根据撤销计数返回对应的撤销类型了。  revoke_bias update_heuristics 返回对应的撤销决策之后，后面就要根据决策进行具体的处理了。 我们先看单个撤销revoke_bias\nstatic BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread) { markOop mark = obj-\u0026gt;mark(); // 如果没有开启偏向模式，则直接返回NOT_BIASED  if (!mark-\u0026gt;has_bias_pattern()) { ... return BiasedLocking::NOT_BIASED; } uint age = mark-\u0026gt;age(); // 构建两个mark word，一个是匿名偏向模式（101），一个是无锁模式（001）  markOop biased_prototype = markOopDesc::biased_locking_prototype()-\u0026gt;set_age(age); markOop unbiased_prototype = markOopDesc::prototype()-\u0026gt;set_age(age); ... JavaThread* biased_thread = mark-\u0026gt;biased_locker(); if (biased_thread == NULL) { // 匿名偏向。当调用锁对象的hashcode()方法可能会导致走到这个逻辑  // 这里我也有点疑问，如果是匿名偏向状态，这表示没有被线程获取过，那么在revoke_and_bias的逻辑中应该可以CAS成功，如果那里失败，这里也不会是匿名偏向模式了  // 如果不允许重偏向，则将对象的mark word设置为无锁模式  if (!allow_rebias) { obj-\u0026gt;set_mark(unbiased_prototype); } ... return BiasedLocking::BIAS_REVOKED; } // code 1：判断偏向线程是否还存活  bool thread_is_alive = false; // 如果当前线程就是偏向线程  if (requesting_thread == biased_thread) { thread_is_alive = true; } else { // 遍历当前jvm的所有线程，如果能找到，则说明偏向的线程还存活  for (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread-\u0026gt;next()) { if (cur_thread == biased_thread) { thread_is_alive = true; break; } } } // 如果偏向的线程已经不存活了  if (!thread_is_alive) { // 允许重偏向则将对象mark word设置为匿名偏向状态，否则设置为无锁状态  if (allow_rebias) { obj-\u0026gt;set_mark(biased_prototype); } else { //如果不允许，就设置为偏向撤销状态  obj-\u0026gt;set_mark(unbiased_prototype); } ... return BiasedLocking::BIAS_REVOKED; } // 线程还存活则遍历线程栈中所有的Lock Record  GrowableArray\u0026lt;MonitorInfo*\u0026gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread); BasicLock* highest_lock = NULL; for (int i = 0; i \u0026lt; cached_monitor_info-\u0026gt;length(); i++) { MonitorInfo* mon_info = cached_monitor_info-\u0026gt;at(i); // 如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码  if (mon_info-\u0026gt;owner() == obj) { ... // 需要升级为轻量级锁，直接修改偏向线程栈中的Lock Record。  //为了处理锁重入的case，在这里将Lock Record的Displaced Mark Word  //设置为null，第一个Lock Record会在下面的代码中再处理  markOop mark = markOopDesc::encode((BasicLock*) NULL); highest_lock = mon_info-\u0026gt;lock(); highest_lock-\u0026gt;set_displaced_header(mark); } else { ... } } if (highest_lock != NULL) { // 修改第一个Lock Record为无锁状态，然后将obj的mark word设置为指向该Lock Record的指针  highest_lock-\u0026gt;set_displaced_header(unbiased_prototype); obj-\u0026gt;release_set_mark(markOopDesc::encode(highest_lock)); ... } else { // 走到这里说明偏向线程已经不在同步块中了  ... if (allow_rebias) { //设置为匿名偏向状态  // 目前从代码中，只发现了会在批量重偏向的时候，allow_rebias会是true，从fast_enter带过来，然后传到VM_BulkRevokeBias  obj-\u0026gt;set_mark(biased_prototype); } else { // 将mark word设置为无锁状态  obj-\u0026gt;set_mark(unbiased_prototype); } } return BiasedLocking::BIAS_REVOKED; }  上面的撤销逻辑看似比较长，其实核心逻辑并不复杂：\n 如果当前对象锁已经不是偏向模式了，就不用执行撤销。 如果当前锁对象偏向的线程Id为NULL，也就是没有偏向任何线程，就根据参数allow_rebias判断是否允许重新偏向，不允许就设置锁状态为无锁，相当于撤销偏向。 判断当前锁对象中偏向的线程是否存活，如果持有偏向锁的线程已经死掉了，那如果允许重新偏向就设置对象头锁状态为偏向锁的初始状态，不允许就设置为无锁状态。 如果线程还存活，就开始执行真正的撤销了：  这里回忆一下前面偏向锁的获取和退出流程：偏向锁的获取，就是在当前线程的线程栈中申请一块Lock Record，然后将Lock Record的obj指向锁对象，并且在对象头中存储当前线程的线程Id。而偏向锁的退出，仅仅将Lock Record中的obj值置为空，其他的什么都没有做。\n 如果持有偏向锁的线程依旧存活，这里就有两种情况  持有偏向锁的线程还没有退出同步代码块 第二是持有偏向锁的线程退出了同步代码块。  而判断是否已经退出，判断依据就是线程栈中是否还有指向锁对象的Lock Record，这以上面的代码中，首先就是遍历线程栈，判断持有锁的线程是否退出了。 遍历结束后，如果highest_lock不等于空，说还没有退出，如果等于NULL说明已经退出了。 如果还在代码块中没有退出，就需要升级锁为轻量级锁，升级为轻量级锁业很简单，先将Lock Record的displaced_header设置为无锁的markoop，在把锁对象头替换成指向LockRecord的指针。 后面看完轻量级锁，再回过头看这里的升级过程，就会明白了。 如果持有偏向锁的线程已经退出了，则判断是否允许重新偏向，如果允许重新偏向，就设置锁对象的对象头为匿名偏向状态。否则设置为轻量级无锁状态，即撤销偏向锁。  批量重偏向，批量撤销  当只有一个线程A反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当线程B尝试获得锁时，就需要等到safe point时交给JVM将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。（因为锁已经被线程A持有，线程B不能修改锁的状态，因为会影响线程A。所以叫给JVM来修改锁的状态）safe point这个词我们在GC中经常会提到，其代表了一个状态，在该状态下所有线程都是暂停的(STW)。总之，偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。\n  一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。 存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。  批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。 JVM以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1。然后根据撤销计数器来决定是否触发批量操作，具体逻辑可以查看上面的 update_heuristics方法逻辑。\n下面我们看代码。 最终批量重偏向和批量撤销都会调用到bulk_revoke_or_rebias_at_safepoint方法。\nstatic BiasedLocking::Condition bulk_revoke_or_rebias_at_safepoint(oop o, bool bulk_rebias, bool attempt_rebias_of_object, JavaThread* requesting_thread) { ... jlong cur_time = os::javaTimeMillis(); //记录本次批量操作的时间  o-\u0026gt;klass()-\u0026gt;set_last_biased_lock_bulk_revocation_time(cur_time); Klass* k_o = o-\u0026gt;klass(); Klass* klass = k_o; if (bulk_rebias) { // 批量重偏向的逻辑  if (klass-\u0026gt;prototype_header()-\u0026gt;has_bias_pattern()) { // 拿到类中的epoch  int prev_epoch = klass-\u0026gt;prototype_header()-\u0026gt;bias_epoch(); // code 1：把类中的epoch自增加1  klass-\u0026gt;set_prototype_header(klass-\u0026gt;prototype_header()-\u0026gt;incr_bias_epoch()); // 获取到自增后的类epoch  int cur_epoch = klass-\u0026gt;prototype_header()-\u0026gt;bias_epoch(); // code 2：遍历所有线程的栈，更新所有该类型锁实例的epoch  // 这里很重要，这里是遍历的线程栈，也就是表示是当前正在使用的偏向锁  //也就是说，这里是找到所有当前正在被线程持有的，或者说正在同步代码块中执行的偏向锁对象  //然后把它们的epoch和类的epoch保持一致。  //这么做的目的是，因为线程在获取偏向锁的时候，会比较锁的epoch和类型epoch是否相同  //如果不同的话，会进行重偏向操作。所以为了避免，当前正在使用的锁，别其他线程获取，  //所以这里会把当前正在使用的锁，和类的epoch保持一致  for (JavaThread* thr = Threads::first(); thr != NULL; thr = thr-\u0026gt;next()) { GrowableArray\u0026lt;MonitorInfo*\u0026gt;* cached_monitor_info = get_or_compute_monitor_info(thr); for (int i = 0; i \u0026lt; cached_monitor_info-\u0026gt;length(); i++) { MonitorInfo* mon_info = cached_monitor_info-\u0026gt;at(i); oop owner = mon_info-\u0026gt;owner(); markOop mark = owner-\u0026gt;mark(); if ((owner-\u0026gt;klass() == k_o) \u0026amp;\u0026amp; mark-\u0026gt;has_bias_pattern()) { // We might have encountered this object already in the case of recursive locking  assert(mark-\u0026gt;bias_epoch() == prev_epoch || mark-\u0026gt;bias_epoch() == cur_epoch, \u0026#34;error in bias epoch adjustment\u0026#34;); owner-\u0026gt;set_mark(mark-\u0026gt;set_bias_epoch(cur_epoch)); } } } } // 接下来对当前锁对象进行重偏向  //没错这里也是调用的 revoke_bias,不过第三个参数 is_bulk 为true  revoke_bias(o, attempt_rebias_of_object \u0026amp;\u0026amp; klass-\u0026gt;prototype_header()-\u0026gt;has_bias_pattern(), true, requesting_thread); } else { ... // code 3：批量撤销的逻辑，将类中的偏向标记关闭，markOopDesc::prototype()返回的是一个关闭偏向模式的prototype  klass-\u0026gt;set_prototype_header(markOopDesc::prototype()); // code 4：遍历所有线程的栈，撤销该类所有锁的偏向  //这里和上面批量重偏向一样，撤销的也是当前被使用的锁对象  for (JavaThread* thr = Threads::first(); thr != NULL; thr = thr-\u0026gt;next()) { GrowableArray\u0026lt;MonitorInfo*\u0026gt;* cached_monitor_info = get_or_compute_monitor_info(thr); for (int i = 0; i \u0026lt; cached_monitor_info-\u0026gt;length(); i++) { MonitorInfo* mon_info = cached_monitor_info-\u0026gt;at(i); oop owner = mon_info-\u0026gt;owner(); markOop mark = owner-\u0026gt;mark(); // 判断锁是否该类型的，并且开启了偏向模式  if ((owner-\u0026gt;klass() == k_o) \u0026amp;\u0026amp; mark-\u0026gt;has_bias_pattern()) { //执行偏向撤销，并且allow_rebias 为false，is_bulk 为true  revoke_bias(owner, false, true, requesting_thread); } } } // 撤销当前锁对象的偏向模式  revoke_bias(o, false, true, requesting_thread); } ... BiasedLocking::Condition status_code = BiasedLocking::BIAS_REVOKED; //在执行完批量操作后，如果允许重偏向，并且锁对象和类都处于偏向模式  //那么就让这个锁对象直接重偏向到当前线程，因为这里是安全点，所以直接设置即可，不需要考虑并发。  if (attempt_rebias_of_object \u0026amp;\u0026amp; o-\u0026gt;mark()-\u0026gt;has_bias_pattern() \u0026amp;\u0026amp; klass-\u0026gt;prototype_header()-\u0026gt;has_bias_pattern()) { // 构造一个偏向请求线程的mark word  markOop new_mark = markOopDesc::encode(requesting_thread, o-\u0026gt;mark()-\u0026gt;age(), klass-\u0026gt;prototype_header()-\u0026gt;bias_epoch()); // 更新当前锁对象的mark word  o-\u0026gt;set_mark(new_mark); status_code = BiasedLocking::BIAS_REVOKED_AND_REBIASED; ... } ... return status_code; }  这个方法的整体逻辑还是比较清晰的。\n 首先记录本次批量操作的时间 然后根据类型是批量重偏向还是批量撤销 然后都是遍历所有的线程栈，找到仍然在使用的锁对象  重偏向的修改epoch，然后执行偏向撤销 批量撤销的，就执行偏向撤销  批量操作完成之后，如果锁对象和class仍然处于偏向模式，并且是允许重偏向的，那么就把锁对象偏向到当前线程。  我觉的这里的一个关键点就是，要理解批量操作的锁对象，都是正在被线程使用的。其他没有被操作的锁对象，需要等待。\n偏向锁释放 CASE(_monitorexit): { oop lockee = STACK_OBJECT(-1); CHECK_NULL(lockee); // derefing\u0026#39;s lockee ought to provoke implicit null check  // find our monitor slot  BasicObjectLock* limit = istate-\u0026gt;monitor_base(); BasicObjectLock* most_recent = (BasicObjectLock*) istate-\u0026gt;stack_base(); //循环遍历线程栈中的Lock Record  while (most_recent != limit ) { //如果Lock Record的Obj指向的是当前锁对象，说明是当前锁对象的Lock Record  if ((most_recent)-\u0026gt;obj() == lockee) { BasicLock* lock = most_recent-\u0026gt;lock(); markOop header = lock-\u0026gt;displaced_header(); //将obj设置为Null  most_recent-\u0026gt;set_obj(NULL); //如果不是偏向模式（即是轻量级锁）,下面是轻量级模式。  if (!lockee-\u0026gt;mark()-\u0026gt;has_bias_pattern()) { bool call_vm = UseHeavyMonitors; // If it isn\u0026#39;t recursive we either must swap old header or call the runtime  if (header != NULL || call_vm) { //将对象头中的markoop替换为Lock Record中的markoop  if (call_vm || Atomic::cmpxchg_ptr(header, lockee-\u0026gt;mark_addr(), lock) != lock) { // restore object for the slow case  //如果替换失败，则还原Lock Record，并且执行锁升级的monitorexit  most_recent-\u0026gt;set_obj(lockee); CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception); } } } UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1); } most_recent++; } // Need to throw illegal monitor state exception  CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception); ShouldNotReachHere(); }   遍历当前线程栈中的所有的Lock Record， 如果Lock Record的obj指向的是自己，则说明当前的Lock Record属于当前锁对象。 将Lock Record的obj设置为空。如果是偏向锁，则就不做其他操作了。 如果是轻量级锁，后面再说明。  HashCode和偏向锁 在上面时，我们提到当调用hashCode的时候，会引起偏向撤销,我们先用Java代码模拟一下这个情况。\n在同步代码中调用锁的hashcode对锁状态的影响 public class HashCodeAndBiasLock { /* 依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.openjdk.jol\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jol-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.14\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; */ public static void main(String[] args) throws InterruptedException { Thread.sleep(5000); BiasLock lock = new BiasLock(); System.out.println(\u0026#34;初始状态\u0026#34;); System.out.println(ClassLayout.parseInstance(lock).toPrintable()); synchronized (lock){ System.out.println(\u0026#34;加锁状态\u0026#34;); System.out.println(ClassLayout.parseInstance(lock).toPrintable()); lock.hashCode(); System.out.println(\u0026#34;hashcode后状态\u0026#34;); System.out.println(ClassLayout.parseInstance(lock).toPrintable()); } } } 执行结果 我们关注一下圈出来的部分\n大多数cpu使用的是小端序，数据的高位字节存放在地址的高端 低位字节存放在地址低端。锁标志位在对象头中处于最右边的高字节，所以在小端序中就会放到地址的高端，也就是最左边。\n 锁对象初始的时候是匿名偏向状态， 加锁之后，还是偏向状态，偏向了当前线程 调用hashcode之后，就升级到了重量级锁  那么下面我们就根据代码具体分析一下。 hashCode()是本地native方法，实现最终调用是synchronizer.cpp中的ObjectSynchronizer::FastHashCode\nintptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) { //首先就判断了JVM是否启用了偏向锁（这个由参数配置），  if (UseBiasedLocking) { // NOTE: many places throughout the JVM do not expect a safepoint  // to be taken here, in particular most operations on perm gen  // objects. However, we only ever bias Java instances and all of  // the call sites of identity_hash that might revoke biases have  // been checked to make sure they can handle a safepoint. The  // added check of the bias pattern is to avoid useless calls to  // thread-local storage.  if (obj-\u0026gt;mark()-\u0026gt;has_bias_pattern()) { // Handle for oop obj in case of STW safepoint  Handle hobj(Self, obj); //然后判断当前是否是偏向模式（即偏向还没有被撤销），  //如果都是，则撤销偏向模式  BiasedLocking::revoke_and_rebias(hobj, false, JavaThread::current()); obj = hobj(); } } ObjectMonitor* monitor = NULL; markOop temp, test; intptr_t hash; markOop mark = ReadStableMark(obj); //无锁状态  //当在同步方法执行之前，调用hashcode,那么会进入这里  if (mark-\u0026gt;is_neutral()) { //这里会先去对象头中拿hash  hash = mark-\u0026gt;hash(); // this is a normal header  if (hash) { // if it has hash, just return it  return hash; } //如果为空，则重新计算hash，并设置到一个对象头中  hash = get_next_hash(Self, obj); // allocate a new hash code  temp = mark-\u0026gt;copy_set_hash(hash); // merge the hash code into header  // use (machine word version) atomic operation to install the hash  // 如果设置成功则返回计算的hashcode  test = (markOop) Atomic::cmpxchg_ptr(temp, obj-\u0026gt;mark_addr(), mark); if (test == mark) { return hash; } // If atomic operation failed, we must inflate the header  // into heavy weight monitor. We could add more code here  // for fast path, but it does not worth the complexity.  //这种是重量级锁的情况下，尝试从monitor中保存的对象头中获取hashcode，如果获取不到则升级到重量级锁  } else if (mark-\u0026gt;has_monitor()) { monitor = mark-\u0026gt;monitor(); temp = monitor-\u0026gt;header(); assert(temp-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); hash = temp-\u0026gt;hash(); if (hash) { return hash; } // Skip to the following code to reduce code size  //如果是轻量级锁,尝试再对象头中获取，如果获取不到则升级到重量级锁  } else if (Self-\u0026gt;is_lock_owned((address)mark-\u0026gt;locker())) { temp = mark-\u0026gt;displaced_mark_helper(); // this is a lightweight monitor owned  assert(temp-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); hash = temp-\u0026gt;hash(); // by current thread, check if the displaced  if (hash) { // header contains hash code  return hash; } // WARNING:  // The displaced header is strictly immutable.  // It can NOT be changed in ANY cases. So we have  // to inflate the header into heavyweight monitor  // even the current thread owns the lock. The reason  // is the BasicLock (stack slot) will be asynchronously  // read by other threads during the inflate() function.  // Any change to stack may not propagate to other threads  // correctly.  } // Inflate the monitor to set hash code  // 到这儿，说明没有获取到hashCode，首先直接将锁膨胀为轻量级锁，然后获取hashcode并且设置hsahcode  monitor = ObjectSynchronizer::inflate(Self, obj); // Load displaced header and check it has hash code  mark = monitor-\u0026gt;header(); assert(mark-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); hash = mark-\u0026gt;hash(); if (hash == 0) { hash = get_next_hash(Self, obj); temp = mark-\u0026gt;copy_set_hash(hash); // merge hash code into header  assert(temp-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); test = (markOop) Atomic::cmpxchg_ptr(temp, monitor, mark); if (test != mark) { // The only update to the header in the monitor (outside GC)  // is install the hash code. If someone add new usage of  // displaced header, please update this code  hash = test-\u0026gt;hash(); assert(test-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); assert(hash != 0, \u0026#34;Trivial unexpected object/monitor header usage.\u0026#34;); } } // We finally get the hash  return hash;  我们来分析一下执行流程。\n 如果JVM开启了偏向锁，并且锁处于偏向模式，就会调用revoke_and_rebias撤销偏向 如果锁对象处于无锁状态，就会计算hashcode，并设置到对象头中，如果设置成功，返回计算的hashcode 如果锁是处于重量级锁状态，就从Monitor中的保存的对象头中获取hashcode 如果处于轻量级，就从Lock Record保存的对象头中获取hashcode 如果上述操作失败了，或者没有获取到，则会把锁升级到重量级，然后重新计算并返回。  所以就能解释上面Java代码的情况了\n 执行hashcode()时，锁处于偏向状态，所以首先会执行revoke_and_bias,撤销偏向锁，然后进入revoke_bias，判断当前线程还存活，所以会升级到轻量级锁。 继续回到hashcode中执行，就会走到轻量级的判断，因为这时候还没所有生成过hashcode，所以Lock Record中的hashcode是空的，所以就会继续向下走升级到重量级锁。  关于偏向撤销的思考  其实这里我也一直有一个疑问，就是在很多情况下，直接重偏向应该是一个更好的选择，那为什么每次都要先进行偏向撤销？\n 我自己考虑可能会有两个方面的原因 1. 首先重偏向的操作不能影响正在持有锁的线程。因为单单只根据对象头无法得知持有偏向锁线程的状态。所以正常的偏向只能发生在从匿名偏向到偏向的这个过程。而重偏向也只有在安全点中，也就是能够确认线程已经执行完同步代码的情况下才能发生（也就是 revoke_bias中最下面的那段逻辑） 2. 另一个原因就是，既然会有锁升级，那就表示每个阶段的锁都有最适合自己的场景。既然已经有了多个线程尝试获取锁，那么就说明在一定程度上已经到了不适合偏向锁的场景了，如果强行使用偏向锁，那么就会无法利用到偏向锁的优势，反而造成锁性能下降。\n偏向锁的优势就在于少了一次CAS操作，偏向锁在偏向之后，如果是同一个线程尝试加锁，只需要一次比较操作，就能加锁成功。 如果强行使用偏向锁，当一个线程尝试锁定一个已经偏向另一个线程的锁对象的时候，直接进行重偏向，那么这时候需要进行的操作就是\n 判断是不是偏向状态 判断是不是偏向的线程 还得等到安全点判断之前的线程是否还存活（这个是最要命的） CAS替换偏向线程ID 这样的话，就损失掉了偏向锁相对于轻量级锁的优势。而且多耗费了很多  所以JVM在遇到有多个线程尝试锁定同一个对象的时候，会直接锁升级。 所以有就有说到了上面的提到的不同锁，使用场景问题。 让偏向锁只工作在自己最优的没有线程竞争的环境下，从而达到最佳的性能。\n轻量级锁过程 轻量级锁被设计用于多个线程交替访问场景下的synchronized，适用一次CAS就能获取到锁。\n轻量级获取 当上面的偏向锁获取失败的时候，会升级到轻量级锁。 这时候锁对象的对象头格式也会发生相应的变化，在锁对象的对象头中，会存储一个指向持有锁的线程的线程栈中的一个Lock Record的指针。 被Lock Record指针锁顶替的对象头中其他字段的信息，为在Lock Record中存储。\nCASE(_monitorenter): { oop lockee = STACK_OBJECT(-1); ... if (entry != NULL) { ... // 上面省略的代码中如果CAS操作失败也会调用到InterpreterRuntime::monitorenter  // traditional lightweight locking  //轻量级锁  if (!success) { //设置当前的对象头为无锁状态，并且复制到Lock Record中的markoop中  markOop displaced = lockee-\u0026gt;mark()-\u0026gt;set_unlocked(); entry-\u0026gt;lock()-\u0026gt;set_displaced_header(displaced); bool call_vm = UseHeavyMonitors; //将对象头中的地址替换为指向Lock Record的指针，替换成功，则说明获取轻量级锁成功,则什么都不做。  //这里替换失败有两种情况  // 1.发生了竞争  // 2.是锁重入  //所以下面继续判断是否为所重入  if (call_vm || Atomic::cmpxchg_ptr(entry, lockee-\u0026gt;mark_addr(), displaced) != displaced) { // Is it simple recursive case?  //这里判断是不是锁重入，判断指向Lock Record的指针指向的地址是否属于当前线程栈  if (!call_vm \u0026amp;\u0026amp; THREAD-\u0026gt;is_lock_owned((address) displaced-\u0026gt;clear_lock_bits())) { //如果是轻量级锁的锁重入,说明前面set_displaced_header设置的是第一个Lock Record的地址，  //所以要重新将申请的Lock Record的displaced_header置为空,同样也会通过申请的displaced_header的个数来统计轻量级锁的重入次数  //栈的最高位的Lock Record的displaced_header不是空，重入锁退出锁的时候，会由低到高遍历退出，只在最后一个锁的时候使用CAS替换  entry-\u0026gt;lock()-\u0026gt;set_displaced_header(NULL); } else { //不是所重入，是发生了竞争，则进行锁升级  CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception); } } } UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1); } else { istate-\u0026gt;set_msg(more_monitors); UPDATE_PC_AND_RETURN(0); // Re-execute  } }   构建一个无锁状态的对象头，(也就是把对象头的后三位设置为001，其他位不变) 把这个无锁的对象头保存到Lock Record中的Displaced header中。 判断是否有UseHeavyMonitors参数，如果有，则直接走重量级锁 使用CAS操作，把指向当前Lock Record的对象头，替换到锁对象的对象头中。  如果CAS成功，则表示获取成功，则结束 如果CAS失败，则表示当前锁对象的对象头已经不是无锁状态，已经有线程轻量级锁定了这个对象  需要判断是不是当前线程，如果是当前线程则表示是重入 如果不是当前线程，则表示发生了线程争抢，另一个线程已经获取到了轻量级锁，则需要进行锁升级    轻量级锁重入处理 当发生了,轻量级锁重入，会把第二次重入的displaced header 设置为null，因为记录重入后的对象头是没有必要的，因为所有的重入锁都退出之后，最终还是要把最开始的那个lock record中的displaced header还原到锁对象头中。中间的重入操作都可能省略掉这个操作。 轻量级释放 CASE(_monitorexit): { oop lockee = STACK_OBJECT(-1); CHECK_NULL(lockee); // derefing\u0026#39;s lockee ought to provoke implicit null check  // find our monitor slot  BasicObjectLock* limit = istate-\u0026gt;monitor_base(); BasicObjectLock* most_recent = (BasicObjectLock*) istate-\u0026gt;stack_base(); //循环遍历线程栈中的Lock Record  while (most_recent != limit ) { //如果Lock Record的Obj指向的是当前锁对象，说明是当前锁对象的Lock Record  if ((most_recent)-\u0026gt;obj() == lockee) { BasicLock* lock = most_recent-\u0026gt;lock(); markOop header = lock-\u0026gt;displaced_header(); //将obj设置为Null  most_recent-\u0026gt;set_obj(NULL); //如果不是偏向模式（即是轻量级锁）  if (!lockee-\u0026gt;mark()-\u0026gt;has_bias_pattern()) { bool call_vm = UseHeavyMonitors; // If it isn\u0026#39;t recursive we either must swap old header or call the runtime  if (header != NULL || call_vm) { //将对象头中的markoop替换为Lock Record中的markoop  if (call_vm || Atomic::cmpxchg_ptr(header, lockee-\u0026gt;mark_addr(), lock) != lock) { // restore object for the slow case  //如果替换失败，则还原Lock Record，并且执行锁升级的monitorexit  //说明在持有轻量级锁期间，有另一个线程，尝试获取，导致锁已经升级到重量级了  most_recent-\u0026gt;set_obj(lockee); CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception); } } } UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1); } most_recent++; } // Need to throw illegal monitor state exception  CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception); ShouldNotReachHere(); }  1、循环遍历当前线程的线程栈，找到指向当前锁对象的Lock Record. 2、将Lock Record的obj设置为空，也就是不再让Lock Record指向锁对象。（这个动作偏向锁也会有） 3、判断如果是轻量级锁，然后判断如果Lock Record的Displaced header不为空，则通过CAS将Displaced header中的markoop替换回对象头中。前面讲轻量级锁获取的时候也有提到过，如果是轻量级锁重入，则Lock Record的Displaced header设置为空，这里退出的时候，会判断如果不为空则替换。 4、如果替换成功，则释放锁成功。如果替换失败，则说明当前锁被其他线程抢占过，所已经升级到了重量级。所以要执行InterpreterRuntime::monitorexit的退出逻辑，monitorexit中，主要做的是轻量级锁的退出和锁膨胀为重量级锁。\nIRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem)) #ifdef ASSERT  thread-\u0026gt;last_frame().interpreter_frame_verify_monitor(elem); #endif  Handle h_obj(thread, elem-\u0026gt;obj()); assert(Universe::heap()-\u0026gt;is_in_reserved_or_null(h_obj()), \u0026#34;must be NULL or an object\u0026#34;); if (elem == NULL || h_obj()-\u0026gt;is_unlocked()) { THROW(vmSymbols::java_lang_IllegalMonitorStateException()); } ObjectSynchronizer::slow_exit(h_obj(), elem-\u0026gt;lock(), thread); // Free entry. This must be done here, since a pending exception might be installed on  // exit. If it is not cleared, the exception handling code will try to unlock the monitor again.  elem-\u0026gt;set_obj(NULL); #ifdef ASSERT  thread-\u0026gt;last_frame().interpreter_frame_verify_monitor(elem); #endif IRT_END void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) { assert(!object-\u0026gt;mark()-\u0026gt;has_bias_pattern(), \u0026#34;should not see bias pattern here\u0026#34;); // if displaced header is null, the previous enter is recursive enter, no-op  markOop dhw = lock-\u0026gt;displaced_header(); markOop mark; //这里判断，Lock Record的displaced_header是否为空，如果是，当前的Lock Record是重入中的一个。  //如果没有持有轻量级锁，那就没必要执行膨胀了，直接返回。中间assert了一下是否已经是重量级锁，别的什么也没做。  if (dhw == NULL) { // Recursive stack-lock.  // Diagnostics -- Could be: stack-locked, inflating, inflated.  mark = object-\u0026gt;mark(); assert(!mark-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); if (mark-\u0026gt;has_locker() \u0026amp;\u0026amp; mark != markOopDesc::INFLATING()) { assert(THREAD-\u0026gt;is_lock_owned((address)mark-\u0026gt;locker()), \u0026#34;invariant\u0026#34;); } if (mark-\u0026gt;has_monitor()) { ObjectMonitor * m = mark-\u0026gt;monitor(); assert(((oop)(m-\u0026gt;object()))-\u0026gt;mark() == mark, \u0026#34;invariant\u0026#34;); assert(m-\u0026gt;is_entered(THREAD), \u0026#34;invariant\u0026#34;); } return; } //执行到这儿，说明Lock Record的displaced_header不为空，说明可能是轻量级锁，也可能已经膨胀为了重量级锁。  mark = object-\u0026gt;mark(); // If the object is stack-locked by the current thread, try to  // swing the displaced header from the box back to the mark.  //尝试将其强转为markOop，成功，则说明还是轻量级锁，则尝试用CAS将Lock Record的isplaced_header替换回对象头。  //则尝试释放轻量级锁，即通过CAS将displaced header替换回对象头中，替换成功则说明轻量级锁释放成功。  if (mark == (markOop) lock) { assert(dhw-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); if ((markOop) Atomic::cmpxchg_ptr (dhw, object-\u0026gt;mark_addr(), mark) == mark) { TEVENT(fast_exit: release stacklock); return; } } //开始执行锁的膨胀升级为重量级锁，并且执行exit  ObjectSynchronizer::inflate(THREAD, object)-\u0026gt;exit(true, THREAD); }   这里判断，Lock Record的displaced_header是否为空，如果是，则说明已经没有持有当前轻量级级锁了。如果没有持有轻量级锁，那就没必要执行膨胀了，直接返回。中间assert了一下是否已经是重量级锁，别的什么也没做。 如果Lock Record的displaced_header不为空， 判断如果当前对象头还是轻量级锁，并且指向的是当前Lock Record，则尝试释放轻量级锁，即通过CAS将displaced header替换回对象头中，替换成功则说明轻量级锁释放成功。 如果前面的判断或者是替换都失败了，就开始执行ObjectSynchronizer::inflate进行锁膨胀为重量级锁。膨胀成功后ObjectSynchronizer::inflate的返回值为ObjectMonitor对象，ObjectMonitor就是用于实现重量级锁的。然后调用ObjectMonitor的exit方法进行锁的释放。  重量级锁 重量级锁被设计用于有线程竞争的场景的，在重量级模式下，没有获取到锁的线程，会先通过自旋，然后进入阻塞操作。避免大量无效的自旋，占用过多的CPU资源。 下面我们还是通过代码来分析一下。\n重量级锁获取 在偏向锁撤销之后，会调用到slow_enter方法，然后在进行一次轻量级获取，如果仍然失败，就会执行inflate，锁膨胀，并返回一下ObjectMonitor对象。\nvoid ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) { markOop mark = obj-\u0026gt;mark(); assert(!mark-\u0026gt;has_bias_pattern(), \u0026#34;should not see bias pattern here\u0026#34;); //无锁状态  if (mark-\u0026gt;is_neutral()) { // Anticipate successful CAS -- the ST of the displaced mark must  // be visible \u0026lt;= the ST performed by the CAS.  lock-\u0026gt;set_displaced_header(mark); if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-\u0026gt;mark_addr(), mark)) { TEVENT(slow_enter: release stacklock); return; } // Fall through to inflate() ...  // 轻量级锁重入  } else if (mark-\u0026gt;has_locker() \u0026amp;\u0026amp; THREAD-\u0026gt;is_lock_owned((address)mark-\u0026gt;locker())) { assert(lock != mark-\u0026gt;locker(), \u0026#34;must not re-lock the same lock\u0026#34;); assert(lock != (BasicLock*)obj-\u0026gt;mark(), \u0026#34;don\u0026#39;t relock with same BasicLock\u0026#34;); lock-\u0026gt;set_displaced_header(NULL); return; } // The object header will never be displaced to this lock,  // so it does not matter what the value is, except that it  // must be non-zero to avoid looking like a re-entrant lock,  // and must not look locked either.  // 现在这个lock是没有获取到锁的线程的lock record，现在存储的是什么并不重要，所以设置没有什么特殊意义的值。  // 不能为null，因为null代表重入  // 不能为0，10，01，因为他们都有相对的意义，所以只能为11了  lock-\u0026gt;set_displaced_header(markOopDesc::unused_mark()); //开始升级为重量级锁  ObjectSynchronizer::inflate(THREAD, obj())-\u0026gt;enter(THREAD); }  获取monitor对象 inflate ObjectMonitor * NOINLINE ObjectSynchronizer::inflate(Thread * Self, oop object) { // Inflate mutates the heap ...  // Relaxing assertion for bug 6320749.  assert(Universe::verify_in_progress() || !SafepointSynchronize::is_at_safepoint(), \u0026#34;invariant\u0026#34;); for (;;) { //获取锁对象的markoop  const markOop mark = object-\u0026gt;mark(); assert(!mark-\u0026gt;has_bias_pattern(), \u0026#34;invariant\u0026#34;); // The mark can be in one of the following states:  // * Inflated - just return  // * Stack-locked - coerce it to inflated  // * INFLATING - busy wait for conversion to complete  // * Neutral - aggressively inflate the object.  // * BIASED - Illegal. We should never see this  // CASE: inflated  //判断是否有Objectmonitor,如果有，说明已经膨胀过了，直接返回monitor  if (mark-\u0026gt;has_monitor()) { ObjectMonitor * inf = mark-\u0026gt;monitor(); assert(inf-\u0026gt;header()-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); assert(inf-\u0026gt;object() == object, \u0026#34;invariant\u0026#34;); assert(ObjectSynchronizer::verify_objmon_isinpool(inf), \u0026#34;monitor is invalid\u0026#34;); return inf; } // CASE: inflation in progress - inflating over a stack-lock.  // Some other thread is converting from stack-locked to inflated.  // Only that thread can complete inflation -- other threads must wait.  // The INFLATING value is transient.  // Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.  // We could always eliminate polling by parking the thread on some auxiliary list.  //如果有其他线程正在执行膨胀，则当前线程不再去执行膨胀逻辑,进行忙等待，直到膨胀完成  if (mark == markOopDesc::INFLATING()) { TEVENT(Inflate: spin while INFLATING); ReadStableMark(object); continue; } // CASE: stack-locked  // Could be stack-locked either by this thread or by some other thread.  //  // Note that we allocate the objectmonitor speculatively, _before_ attempting  // to install INFLATING into the mark word. We originally installed INFLATING,  // allocated the objectmonitor, and then finally STed the address of the  // objectmonitor into the mark. This was correct, but artificially lengthened  // the interval in which INFLATED appeared in the mark, thus increasing  // the odds of inflation contention.  //  // We now use per-thread private objectmonitor free lists.  // These list are reprovisioned from the global free list outside the  // critical INFLATING...ST interval. A thread can transfer  // multiple objectmonitors en-mass from the global free list to its local free list.  // This reduces coherency traffic and lock contention on the global free list.  // Using such local free lists, it doesn\u0026#39;t matter if the omAlloc() call appears  // before or after the CAS(INFLATING) operation.  // See the comments in omAlloc().  //判断目前对象头的状态是否是轻量级锁的状态，则创建一个ObjectMonitor并进行初始化  if (mark-\u0026gt;has_locker()) { //创建一个ObjectMonitor  //omAlloc(Self)会尝试优先从tlab里面分配  ObjectMonitor * m = omAlloc(Self); // Optimistically prepare the objectmonitor - anticipate successful CAS  // We do this before the CAS in order to minimize the length of time  // in which INFLATING appears in the mark.  m-\u0026gt;Recycle(); m-\u0026gt;_Responsible = NULL; m-\u0026gt;_recursions = 0; m-\u0026gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit; // Consider: maintain by type/class  //设置对象的状态为膨胀中，设置失败则重新执行膨胀逻辑  //如果设置失败，则表示已经有线程膨胀完成了，所以continue，在进行上面是否有monitor的判断，然后膨胀完的monitor  markOop cmp = (markOop) Atomic::cmpxchg_ptr(markOopDesc::INFLATING(), object-\u0026gt;mark_addr(), mark); if (cmp != mark) { omRelease(Self, m, true); continue; // Interference -- just retry  } //这里描述了为什么需要添加一个 INFLATING状态  // We\u0026#39;ve successfully installed INFLATING (0) into the mark-word.  // This is the only case where 0 will appear in a mark-word.  // Only the singular thread that successfully swings the mark-word  // to 0 can perform (or more precisely, complete) inflation.  //  // Why do we CAS a 0 into the mark-word instead of just CASing the  // mark-word from the stack-locked value directly to the new inflated state?  // Consider what happens when a thread unlocks a stack-locked object.  // It attempts to use CAS to swing the displaced header value from the  // on-stack basiclock back into the object header. Recall also that the  // header value (hashcode, etc) can reside in (a) the object header, or  // (b) a displaced header associated with the stack-lock, or (c) a displaced  // header in an objectMonitor. The inflate() routine must copy the header  // value from the basiclock on the owner\u0026#39;s stack to the objectMonitor, all  // the while preserving the hashCode stability invariants. If the owner  // decides to release the lock while the value is 0, the unlock will fail  // and control will eventually pass from slow_exit() to inflate. The owner  // will then spin, waiting for the 0 value to disappear. Put another way,  // the 0 causes the owner to stall if the owner happens to try to  // drop the lock (restoring the header from the basiclock to the object)  // while inflation is in-progress. This protocol avoids races that might  // would otherwise permit hashCode values to change or \u0026#34;flicker\u0026#34; for an object.  // Critically, while object-\u0026gt;mark is 0 mark-\u0026gt;displaced_mark_helper() is stable.  // 0 serves as a \u0026#34;BUSY\u0026#34; inflate-in-progress indicator.  // fetch the displaced mark from the owner\u0026#39;s stack.  // The owner can\u0026#39;t die or unwind past the lock while our INFLATING  // object is in the mark. Furthermore the owner can\u0026#39;t complete  // an unlock on the object, either.  markOop dmw = mark-\u0026gt;displaced_mark_helper(); assert(dmw-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); // Setup monitor fields to proper values -- prepare the monitor  // 吧当前的锁对象头，保存到monitor中  m-\u0026gt;set_header(dmw); // Optimization: if the mark-\u0026gt;locker stack address is associated  // with this thread we could simply set m-\u0026gt;_owner = Self.  // Note that a thread can inflate an object  // that it has stack-locked -- as might happen in wait() -- directly  // with CAS. That is, we can avoid the xchg-NULL .... ST idiom.  //关键哈，把重量级Monitor的持有这，设置为当前整持有这个轻量级锁的线程的 Lock Record地址  m-\u0026gt;set_owner(mark-\u0026gt;locker()); m-\u0026gt;set_object(object); // TODO-FIXME: assert BasicLock-\u0026gt;dhw != 0.  // Must preserve store ordering. The monitor state must  // be stable at the time of publishing the monitor address.  guarantee(object-\u0026gt;mark() == markOopDesc::INFLATING(), \u0026#34;invariant\u0026#34;); //设置对象头指向当前的objectmonitor  object-\u0026gt;release_set_mark(markOopDesc::encode(m)); return m; } // CASE: neutral  // TODO-FIXME: for entry we currently inflate and then try to CAS _owner.  // If we know we\u0026#39;re inflating for entry it\u0026#39;s better to inflate by swinging a  // pre-locked objectMonitor pointer into the object header. A successful  // CAS inflates the object *and* confers ownership to the inflating thread.  // In the current implementation we use a 2-step mechanism where we CAS()  // to inflate and then CAS() again to try to swing _owner from NULL to Self.  // An inflateTry() method that we could call from fast_enter() and slow_enter()  // would be useful.  assert(mark-\u0026gt;is_neutral(), \u0026#34;invariant\u0026#34;); //创建ObjectMonitor  ObjectMonitor * m = omAlloc(Self); // prepare m for installation - set monitor to initial state  m-\u0026gt;Recycle(); m-\u0026gt;set_header(mark); m-\u0026gt;set_owner(NULL); m-\u0026gt;set_object(object); m-\u0026gt;_recursions = 0; m-\u0026gt;_Responsible = NULL; m-\u0026gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit; // consider: keep metastats by type/class  //把对象头替换为执行objectMonitor的指针  if (Atomic::cmpxchg_ptr (markOopDesc::encode(m), object-\u0026gt;mark_addr(), mark) != mark) { m-\u0026gt;set_object(NULL); m-\u0026gt;set_owner(NULL); m-\u0026gt;Recycle(); omRelease(Self, m, true); m = NULL; continue; // interference - the markword changed - just retry.  // The state-transitions are one-way, so there\u0026#39;s no chance of  // live-lock -- \u0026#34;Inflated\u0026#34; is an absorbing state.  } // Hopefully the performance counters are allocated on distinct  // cache lines to avoid false sharing on MP systems ...  OM_PERFDATA_OP(Inflations, inc()); TEVENT(Inflate: overwrite neutral); if (log_is_enabled(Debug, monitorinflation)) { if (object-\u0026gt;is_instance()) { ResourceMark rm; log_debug(monitorinflation)(\u0026#34;Inflating object \u0026#34; INTPTR_FORMAT \u0026#34; , mark \u0026#34; INTPTR_FORMAT \u0026#34; , type %s\u0026#34;, p2i(object), p2i(object-\u0026gt;mark()), object-\u0026gt;klass()-\u0026gt;external_name()); } } return m; } }  inflate方法的功能是返回一个可用ObjectMonitor对象，如果没有就创建一个。inflate中是一个for循环，主要是为了处理多线程同时调用inflate的情况。然后会根据锁对象的状态进行不同的处理：\n 已经是重量级状态，说明膨胀已经完成已经有了ObjectMonitor，直接返回 如果是轻量级锁则需要进行膨胀操作 如果是膨胀中状态，则进行忙等待 如果是无锁状态则需要进行膨胀操作  其中轻量级锁和无锁状态需要进行膨胀操作，轻量级锁膨胀流程如下：\n 调用omAlloc分配一个ObjectMonitor对象(以下简称monitor)，在omAlloc方法中会先从线程私有的monitor集合omFreeList中分配对象，如果omFreeList中已经没有monitor对象，则从JVM全局的gFreeList中分配一批monitor到omFreeList中。 初始化monitor对象 将状态设置为膨胀中（INFLATING）状态 设置monitor的header字段为displaced mark word，obj字段为锁对象 设置owner字段为之前持有轻量级锁的线程的Lock Record，也就是膨胀完之后，要让之前持有锁的线程继续持有这个重量级锁，谁能用自己的Lock Record设置owner，就表示谁获取到了这个重量级锁 设置锁对象头的mark word为重量级锁状态，指向第一步分配的monitor对象  无锁状态下的膨胀流程如下：\n 调用omAlloc分配一个ObjectMonitor对象(以下简称monitor) 初始化monitor对象 设置monitor的header字段为 mark word，owner字段为null，obj字段为锁对象 设置锁对象头的mark word为重量级锁状态，指向第一步分配的monitor对象  进入重量级锁 enter 在获得了Monitor之后，线程就要进入Monitor，看看能不能获取到重量锁了\nvoid ATTR ObjectMonitor::enter(TRAPS) { Thread * const Self = THREAD ; void * cur ; // owner为null代表无锁状态，如果能CAS设置成功，则当前线程直接获得锁  cur = Atomic::cmpxchg_ptr (Self, \u0026amp;_owner, NULL) ; if (cur == NULL) { ... return ; } // 如果是重入的情况，则把重入计数器加1  if (cur == Self) { // TODO-FIXME: check for integer overflow! BUGID 6557169.  _recursions ++ ; return ; } // 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀且第一次调用enter方法，那cur是指向Lock Record的指针  // 这里也就是说，之前持有轻量级锁的线程，自己膨胀到重量级锁，同志们有印象是什么操作吗，就是在同步代码块中调用了hashcode呀，就会执行到这个逻辑  if (Self-\u0026gt;is_lock_owned ((address)cur)) { assert (_recursions == 0, \u0026#34;internal state error\u0026#34;); // 重入计数重置为1  // 因为之前就是这个线程持有轻量级锁，现在还是这个线程持有重量级锁，还是相当于锁重入了，所以_recursions设置为1，表示重入1次。  _recursions = 1 ; // 设置owner字段为当前线程（之前owner是指向Lock Record的指针）  _owner = Self ; return ; } ... // 在调用昂贵的系统同步操作之前，先尝试一轮自适应自旋  if (Knob_SpinEarly \u0026amp;\u0026amp; TrySpin (Self) \u0026gt; 0) { ... //自旋的过程中获得了锁，则直接返回  Self-\u0026gt;_Stalled = 0 ; return ; } ... { ... for (;;) { jt-\u0026gt;set_suspend_equivalent(); // 在该方法中调用系统同步操作  EnterI (THREAD) ; ... } Self-\u0026gt;set_current_pending_monitor(NULL); } ... }  我们看到，这个enter方法，还是通过CAS和自旋来尝试获得重量级锁，如果同构这两步能够获取成功，那么就能够避免切换到内核态去执行。 如果不能获取到，也不能让线程一直自旋获取，需要调用EnterI来获取锁，获取进入阻塞状态。\n重量级进入 EnterI 在进入到这个方法之前，我们在来熟悉一下ObjectMonitor中比较重要的属性，有的之前已经见到了，有的还没有\n   名称 作用     _header 保存锁对象的对象头markoop   _object 锁对象   _owner 正常情况下是持有锁的线程，如果是有轻量级膨胀上来的，那么会是当时轻量级Lock Reord   _recursions 重量级锁的重入次数   _EntryList 被阻塞的线程重新进入时，会将其放在当前队列中。其实这个队列是被wait()方法阻塞的线程，当调用notify/notifyAll时，会将准备唤醒的线程放在这个队列中。   _cxq 当对象锁已经被一个线程持有，其他所有的线程在尝试获取锁的时候，如果没有获取到，将其挂起后都会被放在这个队列上。   _WaitSet 调用wait()方法阻塞的线程，都会放在当前队列中   _succ 线程是在线程释放锁是被设置，其含义是Heir presumptive，也就是假定继承人   _Responsible 当竞争发生时，选取一个线程作为_Responsible，_Responsible线程调用的是有时间限制的park方法，其目的是防止出现搁浅现象。    void NOINLINE ObjectMonitor::EnterI(TRAPS) { Thread * const Self = THREAD; assert(Self-\u0026gt;is_Java_thread(), \u0026#34;invariant\u0026#34;); assert(((JavaThread *) Self)-\u0026gt;thread_state() == _thread_blocked, \u0026#34;invariant\u0026#34;); // Try the lock - TATAS  if (TryLock (Self) \u0026gt; 0) { assert(_succ != Self, \u0026#34;invariant\u0026#34;); assert(_owner == Self, \u0026#34;invariant\u0026#34;); assert(_Responsible != Self, \u0026#34;invariant\u0026#34;); return; } DeferredInitialize(); // We try one round of spinning *before* enqueueing Self.  //  // If the _owner is ready but OFFPROC we could use a YieldTo()  // operation to donate the remainder of this thread\u0026#39;s quantum  // to the owner. This has subtle but beneficial affinity  // effects.  // 再尝试一轮自旋  // 我们看到这里又同样的逻辑执行了2次，为什么这样呢，  if (TrySpin (Self) \u0026gt; 0) { assert(_owner == Self, \u0026#34;invariant\u0026#34;); assert(_succ != Self, \u0026#34;invariant\u0026#34;); assert(_Responsible != Self, \u0026#34;invariant\u0026#34;); return; } // The Spin failed -- Enqueue and park the thread ...  assert(_succ != Self, \u0026#34;invariant\u0026#34;); assert(_owner != Self, \u0026#34;invariant\u0026#34;); assert(_Responsible != Self, \u0026#34;invariant\u0026#34;); // Enqueue \u0026#34;Self\u0026#34; on ObjectMonitor\u0026#39;s _cxq.  //  // Node acts as a proxy for Self.  // As an aside, if were to ever rewrite the synchronization code mostly  // in Java, WaitNodes, ObjectMonitors, and Events would become 1st-class  // Java objects. This would avoid awkward lifecycle and liveness issues,  // as well as eliminate a subset of ABA issues.  // TODO: eliminate ObjectWaiter and enqueue either Threads or Events.  ObjectWaiter node(Self); Self-\u0026gt;_ParkEvent-\u0026gt;reset(); node._prev = (ObjectWaiter *) 0xBAD; node.TState = ObjectWaiter::TS_CXQ; // Push \u0026#34;Self\u0026#34; onto the front of the _cxq.  // Once on cxq/EntryList, Self stays on-queue until it acquires the lock.  // Note that spinning tends to reduce the rate at which threads  // enqueue and dequeue on EntryList|cxq.  ObjectWaiter * nxt; for (;;) { node._next = nxt = _cxq; //尝试将当前线程放在cxq队列的头部，如果放成功了则跳出循环  if (Atomic::cmpxchg_ptr(\u0026amp;node, \u0026amp;_cxq, nxt) == nxt) break; // Interference - the CAS failed because _cxq changed. Just retry.  // As an optional optimization we retry the lock.  //放失败了，则说明cxq对象被改变了，则尝试获取锁。  //获取成功则直接返回，获取失败，在继续尝试将线程放在Cxq队列的头部  if (TryLock (Self) \u0026gt; 0) { assert(_succ != Self, \u0026#34;invariant\u0026#34;); assert(_owner == Self, \u0026#34;invariant\u0026#34;); assert(_Responsible != Self, \u0026#34;invariant\u0026#34;); return; } } // Check for cxq|EntryList edge transition to non-null. This indicates  // the onset of contention. While contention persists exiting threads  // will use a ST:MEMBAR:LD 1-1 exit protocol. When contention abates exit  // operations revert to the faster 1-0 mode. This enter operation may interleave  // (race) a concurrent 1-0 exit operation, resulting in stranding, so we  // arrange for one of the contending thread to use a timed park() operations  // to detect and recover from the race. (Stranding is form of progress failure  // where the monitor is unlocked but all the contending threads remain parked).  // That is, at least one of the contended threads will periodically poll _owner.  // One of the contending threads will become the designated \u0026#34;Responsible\u0026#34; thread.  // The Responsible thread uses a timed park instead of a normal indefinite park  // operation -- it periodically wakes and checks for and recovers from potential  // strandings admitted by 1-0 exit operations. We need at most one Responsible  // thread per-monitor at any given moment. Only threads on cxq|EntryList may  // be responsible for a monitor.  //  // Currently, one of the contended threads takes on the added role of \u0026#34;Responsible\u0026#34;.  // A viable alternative would be to use a dedicated \u0026#34;stranding checker\u0026#34; thread  // that periodically iterated over all the threads (or active monitors) and unparked  // successors where there was risk of stranding. This would help eliminate the  // timer scalability issues we see on some platforms as we\u0026#39;d only have one thread  // -- the checker -- parked on a timer.  //这里判断的是，如果nex==null(说明cxq队列为空)，并且entryList为空。  //那说明当前线程是第一个阻塞或者等待当前锁的线程  //也就是说，这个线程是进入monitor的第一个线程，那么就把这个线程设置为_Responsible  if ((SyncFlags \u0026amp; 16) == 0 \u0026amp;\u0026amp; nxt == NULL \u0026amp;\u0026amp; _EntryList == NULL) { // Try to assume the role of responsible thread for the monitor.  // CONSIDER: ST vs CAS vs { if (Responsible==null) Responsible=Self }  //通过cas将_Responsible指针指向Self  Atomic::cmpxchg_ptr(Self, \u0026amp;_Responsible, NULL); } // The lock might have been released while this thread was occupied queueing  // itself onto _cxq. To close the race and avoid \u0026#34;stranding\u0026#34; and  // progress-liveness failure we must resample-retry _owner before parking.  // Note the Dekker/Lamport duality: ST cxq; MEMBAR; LD Owner.  // In this case the ST-MEMBAR is accomplished with CAS().  //  // TODO: Defer all thread state transitions until park-time.  // Since state transitions are heavy and inefficient we\u0026#39;d like  // to defer the state transitions until absolutely necessary,  // and in doing so avoid some transitions ...  TEVENT(Inflated enter - Contention); int nWakeups = 0; int recheckInterval = 1; //执行到这儿，说明线程已经被成功放在了cxq队列的头部，  //然后下面进入一个循环，只有成功获取到了锁，才能够跳出循环。  for (;;) { //再次尝试获取锁  if (TryLock(Self) \u0026gt; 0) break; assert(_owner != Self, \u0026#34;invariant\u0026#34;); //如果_Responsible指针为NULL，则再次尝试让_Responsible指向当前线程  if ((SyncFlags \u0026amp; 2) \u0026amp;\u0026amp; _Responsible == NULL) { Atomic::cmpxchg_ptr(Self, \u0026amp;_Responsible, NULL); } // park self  //如果_Responsible成功指向了当前线程，说明当前线程是第一个被阻塞或者等待获取锁的线程。  //则会执行一个简单的退避算法。执行有等待时间的park操作,第一次是1ms  //每次到时间后自己去尝试获取锁，获取失败后继续睡眠，每次睡眠的时间是上一次的8倍。  if (_Responsible == Self || (SyncFlags \u0026amp; 1)) { TEVENT(Inflated enter - park TIMED); Self-\u0026gt;_ParkEvent-\u0026gt;park((jlong) recheckInterval); // Increase the recheckInterval, but clamp the value.  recheckInterval *= 8; if (recheckInterval \u0026gt; MAX_RECHECK_INTERVAL) { recheckInterval = MAX_RECHECK_INTERVAL; } } else { //如果当前线程不是第一个阻塞或者等待锁的线程，则直接park。  TEVENT(Inflated enter - park UNTIMED); Self-\u0026gt;_ParkEvent-\u0026gt;park(); } if (TryLock(Self) \u0026gt; 0) break; // The lock is still contested.  // Keep a tally of the # of futile wakeups.  // Note that the counter is not protected by a lock or updated by atomics.  // That is by design - we trade \u0026#34;lossy\u0026#34; counters which are exposed to  // races during updates for a lower probe effect.  TEVENT(Inflated enter - Futile wakeup); // This PerfData object can be used in parallel with a safepoint.  // See the work around in PerfDataManager::destroy().  OM_PERFDATA_OP(FutileWakeups, inc()); ++nWakeups; // Assuming this is not a spurious wakeup we\u0026#39;ll normally find _succ == Self.  // We can defer clearing _succ until after the spin completes  // TrySpin() must tolerate being called with _succ == Self.  // Try yet another round of adaptive spinning.  if ((Knob_SpinAfterFutile \u0026amp; 1) \u0026amp;\u0026amp; TrySpin(Self) \u0026gt; 0) break; // We can find that we were unpark()ed and redesignated _succ while  // we were spinning. That\u0026#39;s harmless. If we iterate and call park(),  // park() will consume the event and return immediately and we\u0026#39;ll  // just spin again. This pattern can repeat, leaving _succ to simply  // spin on a CPU. Enable Knob_ResetEvent to clear pending unparks().  // Alternately, we can sample fired() here, and if set, forgo spinning  // in the next iteration.  if ((Knob_ResetEvent \u0026amp; 1) \u0026amp;\u0026amp; Self-\u0026gt;_ParkEvent-\u0026gt;fired()) { Self-\u0026gt;_ParkEvent-\u0026gt;reset(); OrderAccess::fence(); } if (_succ == Self) _succ = NULL; // Invariant: after clearing _succ a thread *must* retry _owner before parking.  OrderAccess::fence(); } //执行到这里，说明当前线程成功获取了锁，所以下面要做的事情，就是要将当前线程从当前锁的阻塞队列上去掉，  // Egress :  // Self has acquired the lock -- Unlink Self from the cxq or EntryList.  // Normally we\u0026#39;ll find Self on the EntryList .  // From the perspective of the lock owner (this thread), the  // EntryList is stable and cxq is prepend-only.  // The head of cxq is volatile but the interior is stable.  // In addition, Self.TState is stable.  assert(_owner == Self, \u0026#34;invariant\u0026#34;); assert(object() != NULL, \u0026#34;invariant\u0026#34;); // I\u0026#39;d like to write:  // guarantee (((oop)(object()))-\u0026gt;mark() == markOopDesc::encode(this), \u0026#34;invariant\u0026#34;) ;  // but as we\u0026#39;re at a safepoint that\u0026#39;s not safe.  //从队列中去掉当前线程的操作  UnlinkAfterAcquire(Self, \u0026amp;node); if (_succ == Self) _succ = NULL; assert(_succ != Self, \u0026#34;invariant\u0026#34;); //如果_Responsible是当前线程，则将_Responsible设置为NULL  if (_Responsible == Self) { _Responsible = NULL; OrderAccess::fence(); // Dekker pivot-point  } return; }   首先还是尝试获取锁，获取失败后再尝试自旋一下，自旋依旧失败，之后是真正的挂起逻辑。 当时这里进行了2轮自旋，尝试自旋获得锁，我们可以理解，是为了尽可能的在用户态获得锁，那为什么要执行2次呢？\n// We try one round of spinning *before* enqueueing Self. // // If the _owner is ready but OFFPROC we could use a YieldTo() // operation to donate the remainder of this thread\u0026#39;s quantum // to the owner. This has subtle but beneficial affinity // effects.  上面的注释给了我们答案，这么做会有一些微秒的亲和力影响。\n什么是亲和力？这是很多操作系统中都有的一种 CPU 执行调度逻辑，说的是，如果在过去一段时间内，某个线程尝试获取某种资源一直失败，那么系统在后面会倾向于将该资源分配给这个线程。这里我们前后两次执行，就是告诉系统当前线程「迫切」想要获得这个 cas 资源，如果可以用的话尽量分配给它。当然这种亲和力不是一种得到保证的协议，因此这种操作只能是一种积极的、并且人畜无害的操作。\n 执行真正挂起逻辑之前，首先将自己包装成一个ObjectWaiter对象，并通过CAS放在_cxq队列的头部。\n 执行真正挂起逻辑的时候，有一个指针_Responsible，当cxq队列和_EntryList为空，并且_Responsible为空的时候，说明当前线程是第一个等待锁的线程，就通过CAS将_Responsible指向当前线程。 然后，进入到一个无限循环中，只有成功获取了锁，才能退出循环。 _Responsible的作用是什么呢\n// Check for cxq|EntryList edge transition to non-null. This indicates // the onset of contention. While contention persists exiting threads // will use a ST:MEMBAR:LD 1-1 exit protocol. When contention abates exit // operations revert to the faster 1-0 mode. This enter operation may interleave // (race) a concurrent 1-0 exit operation, resulting in stranding, so we // arrange for one of the contending thread to use a timed park() operations // to detect and recover from the race. (Stranding is form of progress failure // where the monitor is unlocked but all the contending threads remain parked). // That is, at least one of the contended threads will periodically poll _owner. // One of the contending threads will become the designated \u0026#34;Responsible\u0026#34; thread. // The Responsible thread uses a timed park instead of a normal indefinite park // operation -- it periodically wakes and checks for and recovers from potential // strandings admitted by 1-0 exit operations. We need at most one Responsible // thread per-monitor at any given moment. Only threads on cxq|EntryList may // be responsible for a monitor. 上面的注释中说到，重量级操作中，是有可能发生搁浅(搁浅是指：Monitor已解锁但所有竞争线程均已park，就是没有线程去尝试获取锁)，为了避免这种情况。需要指定一个线程，定期唤醒去执行执行检查,或者说去尝试获取锁。保证至少有一个线程能够获取锁。\n 如果_Responsible指向的是当前程，就通过一个简单的退避算法进行有条件的挂起，第一次1ms，第二次8ms，每次下一次都是上一次睡眠时间的8倍，但时间自动唤醒自己并尝试获取锁。\n 如果_Responsible指向的不是当前线程，则当前线程会执行park将自己挂起，只有当前得到锁的线程释放锁的时候，才有机会被唤醒并且竞争锁。\n 最后，当获取到锁之后，就会跳出循环，填出循环后需要做一些后续处理，需要把自己从等待队列中移除，\n 如果如果是_Responsible线程获取到了了，那么就需要把_Responsible设置为null，等待其他线程被唤醒的使用重新设置为_Responsible。\n  降到这里其实加锁过程，就差不多完成了，可能会有一些疑惑，为什么 EntryList cxq 这些都没怎么用到呢？ 别急在重量级锁退出的时候，就会用到了，我们机械往下分析。\n自旋锁和适应性自旋 我们看到在重量级代码中，有很多次的出现了自旋的操作，这么做的目的就是，尽量在用户态解决战斗，防止线程无谓地进行状态切换。所以我们能从中知道，尽量避免无效的状态切换对于一个高性能的系统有多么重要。\n但是要想不切换到内核态，就必须要给线程找点事情做，所以就需要线程进行自旋。上面在重量级锁的获取中，看到了很多采用TryLock,来尝试自旋获取锁。这个其实就是我们经常说的自旋锁。\n我觉得准确来说自旋不能算作一种锁，在Java里它只能算是一种获取重量级锁的优化方式。在线程占有锁时间比较短的情况下，能够避免其他等待锁线程切换到内核态进入阻塞状态\n自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开启，在JDK 1.6中就已经改为默认开启了。 自旋等待不能代替阻塞，因为自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源， 而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。 自旋次数的默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改。\n在JDK 1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。 另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。\n重量级锁释放 上面我们理清了 ObjectMonitor enter 的逻辑，我们知道了如下几件事情：\n ObjectMonitor 内部通过一个 CXQ 队列保存所有的等待线程 在实际进入队列之前，会反复尝试 lock，在某些系统上会存在 CPU 亲和力的优化 入队的时候，通过 ObjectWaiter 对象将当前线程包裹起来，并且入到 CXQ 队列的头部 入队成功以后，会根据当前线程是否为第一个等待线程做不同的处理，如果是第一个这个线程会被设置为_Responsible。 如果是第一个等待线程，会根据一个简单的「退避算法」来有条件的 wait，并定时醒来继续尝试获取 如果不是第一个等待线程，那么会执行无限期等待 如果_Responsible线程获取到重量级锁，会将_Responsible设置为null 线程的 park 在 posix 系统上是通过 pthread 的 condition wait 实现的  当一个线程获得对象锁成功之后，就可以执行自定义的同步代码块了。执行完成之后会执行到 ObjectMonitor 的 exit 函数中，释放当前对象锁，方便下一个线程来获取这个锁，下面我们逐步分析下 exit 的实现过程。\nexit 函数的实现比较长，但是整体上的结构比较清晰：\nvoid ATTR ObjectMonitor::exit(bool not_suspended, TRAPS) { Thread * Self = THREAD ; // 如果_owner不是当前线程  if (THREAD != _owner) { // 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀后还没调用过enter方法，_owner会是指向Lock Record的指针。  if (THREAD-\u0026gt;is_lock_owned((address) _owner)) { assert (_recursions == 0, \u0026#34;invariant\u0026#34;) ; //在这时把owner修改为指向当前线程，应该是为了方便后面进行处理吧，因为只有这一种情况下是owner指向的不是线程。  _owner = THREAD ; _recursions = 0 ; } else { // 异常情况:当前不是持有锁的线程  TEVENT (Exit - Throw IMSX) ; assert(false, \u0026#34;Non-balanced monitor enter/exit!\u0026#34;); if (false) { THROW(vmSymbols::java_lang_IllegalMonitorStateException()); } return; } } // 重入计数器还不为0，则计数器-1后返回,因为这表明这只是一次重量级锁的重入，只需要吧重入次数减一即可。  if (_recursions != 0) { _recursions--; // this is simple recursive enter  TEVENT (Inflated exit - recursive) ; return ; } // _Responsible设置为null，一直不知道这个SyncFlags是什么东西，也不知道代表什么意思，苦恼  if ((SyncFlags \u0026amp; 4) == 0) { _Responsible = NULL ; } ... for (;;) { assert (THREAD == _owner, \u0026#34;invariant\u0026#34;) ; // Knob_ExitPolicy默认为0  if (Knob_ExitPolicy == 0) { // code 1：先释放锁，这时如果有其他线程进入同步块则能获得锁  OrderAccess::release_store_ptr (\u0026amp;_owner, NULL) ; // drop the lock  OrderAccess::storeload() ; // See if we need to wake a successor  // code 2：如果没有等待的线程(cxq和entryList都为空)或已经有假定继承人_succ不为空  // 那么表示不需要继续唤醒了，返回即可  if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL) { TEVENT (Inflated exit - simple egress) ; return ; } TEVENT (Inflated exit - complex egress) ; // code 3：要执行之后的操作需要重新获得锁，即设置_owner为当前线程  // 不满足上面的条件，表示需要挑一个线程唤醒，要操作_cxq 和 entryList，需要重新获取重量级锁  // 如果获取失败了，则表示此时重量级锁，已经被其他线程获取了，直接返回就行  // 如果获取成功了则下面需要按照不同的QMode进行处理  if (Atomic::cmpxchg_ptr (THREAD, \u0026amp;_owner, NULL) != NULL) { return ; } TEVENT (Exit - Reacquired) ; }else{ //此处代码忽略掉了  } ... ObjectWaiter * w = NULL ; // code 4：根据QMode的不同会有不同的唤醒策略，默认为0  int QMode = Knob_QMode ; if (QMode == 2 \u0026amp;\u0026amp; _cxq != NULL) { // QMode == 2 : cxq中的线程有更高优先级，直接唤醒cxq的队首线程  w = _cxq ; assert (w != NULL, \u0026#34;invariant\u0026#34;) ; assert (w-\u0026gt;TState == ObjectWaiter::TS_CXQ, \u0026#34;Invariant\u0026#34;) ; ExitEpilog (Self, w) ; return ; } if (QMode == 3 \u0026amp;\u0026amp; _cxq != NULL) { // 将cxq中的元素插入到EntryList的末尾  w = _cxq ; for (;;) { assert (w != NULL, \u0026#34;Invariant\u0026#34;) ; ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, \u0026amp;_cxq, w) ; if (u == w) break ; w = u ; } assert (w != NULL , \u0026#34;invariant\u0026#34;) ; ObjectWaiter * q = NULL ; ObjectWaiter * p ; for (p = w ; p != NULL ; p = p-\u0026gt;_next) { guarantee (p-\u0026gt;TState == ObjectWaiter::TS_CXQ, \u0026#34;Invariant\u0026#34;) ; p-\u0026gt;TState = ObjectWaiter::TS_ENTER ; p-\u0026gt;_prev = q ; q = p ; } // Append the RATs to the EntryList  // TODO: organize EntryList as a CDLL so we can locate the tail in constant-time.  ObjectWaiter * Tail ; for (Tail = _EntryList ; Tail != NULL \u0026amp;\u0026amp; Tail-\u0026gt;_next != NULL ; Tail = Tail-\u0026gt;_next) ; if (Tail == NULL) { _EntryList = w ; } else { Tail-\u0026gt;_next = w ; w-\u0026gt;_prev = Tail ; } // Fall thru into code that tries to wake a successor from EntryList  } if (QMode == 4 \u0026amp;\u0026amp; _cxq != NULL) { // 将cxq插入到EntryList的队首  w = _cxq ; for (;;) { assert (w != NULL, \u0026#34;Invariant\u0026#34;) ; ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, \u0026amp;_cxq, w) ; if (u == w) break ; w = u ; } assert (w != NULL , \u0026#34;invariant\u0026#34;) ; ObjectWaiter * q = NULL ; ObjectWaiter * p ; for (p = w ; p != NULL ; p = p-\u0026gt;_next) { guarantee (p-\u0026gt;TState == ObjectWaiter::TS_CXQ, \u0026#34;Invariant\u0026#34;) ; p-\u0026gt;TState = ObjectWaiter::TS_ENTER ; p-\u0026gt;_prev = q ; q = p ; } // Prepend the RATs to the EntryList  if (_EntryList != NULL) { q-\u0026gt;_next = _EntryList ; _EntryList-\u0026gt;_prev = q ; } _EntryList = w ; // Fall thru into code that tries to wake a successor from EntryList  } w = _EntryList ; if (w != NULL) { // 如果EntryList不为空，则直接唤醒EntryList的队首元素  assert (w-\u0026gt;TState == ObjectWaiter::TS_ENTER, \u0026#34;invariant\u0026#34;) ; ExitEpilog (Self, w) ; return ; } // EntryList为null，则处理cxq中的元素  w = _cxq ; if (w == NULL) continue ; // 因为之后要将cxq的元素移动到EntryList，所以这里将cxq字段设置为null  for (;;) { assert (w != NULL, \u0026#34;Invariant\u0026#34;) ; ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, \u0026amp;_cxq, w) ; if (u == w) break ; w = u ; } TEVENT (Inflated exit - drain cxq into EntryList) ; assert (w != NULL , \u0026#34;invariant\u0026#34;) ; assert (_EntryList == NULL , \u0026#34;invariant\u0026#34;) ; if (QMode == 1) { // QMode == 1 : 将cxq中的元素转移到EntryList，并反转顺序  ObjectWaiter * s = NULL ; ObjectWaiter * t = w ; ObjectWaiter * u = NULL ; while (t != NULL) { guarantee (t-\u0026gt;TState == ObjectWaiter::TS_CXQ, \u0026#34;invariant\u0026#34;) ; t-\u0026gt;TState = ObjectWaiter::TS_ENTER ; u = t-\u0026gt;_next ; t-\u0026gt;_prev = u ; t-\u0026gt;_next = s ; s = t; t = u ; } _EntryList = s ; assert (s != NULL, \u0026#34;invariant\u0026#34;) ; } else { // QMode == 0 or QMode == 2‘  // 将cxq中的元素转移到EntryList  _EntryList = w ; ObjectWaiter * q = NULL ; ObjectWaiter * p ; for (p = w ; p != NULL ; p = p-\u0026gt;_next) { guarantee (p-\u0026gt;TState == ObjectWaiter::TS_CXQ, \u0026#34;Invariant\u0026#34;) ; p-\u0026gt;TState = ObjectWaiter::TS_ENTER ; p-\u0026gt;_prev = q ; q = p ; } } // _succ不为null，说明已经有个继承人了，所以不需要当前线程去唤醒，减少上下文切换的比率  if (_succ != NULL) continue; w = _EntryList ; // 唤醒EntryList第一个元素  if (w != NULL) { guarantee (w-\u0026gt;TState == ObjectWaiter::TS_ENTER, \u0026#34;invariant\u0026#34;) ; ExitEpilog (Self, w) ; return ; } } }  上面的 exit 函数整体上分为如下几个部分：\n 首先判断owner是否是当前线程，因为只有获得当前锁的线程，才能执行exit。 对重入次数进行减1操作。 接下来是个无限循环，只有成功释放了锁，才会跳出循环。在循环中，主要做的事情是：\n 这里根据不同的退出策略执行了一段不同的逻辑，但是大致做的事情都差不多，这里我们只分析默认为0的情况。\n 首先释放掉当前线程对重量级锁的占用(设置owner为null)，此时如果其他线程来抢占锁，是可以抢占成功的，有点类似ReenrantLock的非公平锁的意思。\n 然后判断了cxq队列和_EntryList是否都是空，或者是已经设置了假定继承人，如果是，就直接返回。因为没有线程需要唤醒，或者等待假定继承人去获得锁即可。\n 如果不满足上面条件，说明需要挑选一个线程来获取锁，那么这里因为需要操作_cxq和_EntryList，所以需要重新CAS获取重量级锁。\n 如果这里CAS获取失败，说明已经有其他线程获取到了锁，则直接返回即可\n  下面就需要根据策略从_cxq和_EntryList中挑选一个线程唤醒了。\n  默认唤醒策略 默认的QMode为0，所以我们就先来分析这个策略的逻辑。 很奇怪，代码中，并没有单独判断QMode=0的这个种情况，所以我们需要把其他的逻辑去掉，剩下的就是QMode=0的逻辑了\nvoid ObjectMonitor::exit(bool not_suspended, TRAPS) { for (;;) { ... ObjectWaiter * w = NULL; int QMode = Knob_QMode; if (QMode == 2 \u0026amp;\u0026amp; _cxq != NULL){ ... } if (QMode == 3 \u0026amp;\u0026amp; _cxq != NULL){ ... } if (QMode == 4 \u0026amp;\u0026amp; _cxq != NULL){ ... } w = _EntryList; //优先从EntryList中唤醒线程  //判断entryList是否为空  if (w != NULL) { //如果不为空，唤醒entryList的头节点  ExitEpilog(Self, w); return; } //先把 cxq赋值给 w，然后清空cxq  w = _cxq; // Drain _cxq into EntryList - bulk transfer.  // First, detach _cxq.  // The following loop is tantamount to: w = swap(\u0026amp;cxq, NULL)  for (;;) { ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr(NULL, \u0026amp;_cxq, w); if (u == w) break; w = u; } if (QMode == 1) { ... }else { // QMode == 0 or QMode == 2  //将cxq中的元素转移到EntryList  //并将cxq转化为双向类别  _EntryList = w; ObjectWaiter * q = NULL; ObjectWaiter * p; for (p = w; p != NULL; p = p-\u0026gt;_next) { p-\u0026gt;TState = ObjectWaiter::TS_ENTER; p-\u0026gt;_prev = q; q = p; } } //唤醒entryList中的头部节点  w = _EntryList; if (w != NULL) { ExitEpilog(Self, w); return; } } }  总结一下就是\n 在默认情况下,所有等待锁的线程，会先放到_cxq队列中，后来的会放到_cxq的头部。 当之前持有锁的线程，执行完了同步代码，触发了锁退出逻辑。 在默认QMode=0的情况下下，其他模式我们先不分析了，首先会判断EntryList是否不为空，如果不为空，则唤醒EntryList的头节点的线程。 在首次重量级锁退出的时候，EntryList肯定为空，则会继续向下走，会把_cxq中的节点，转移到_EntryList中，并把修改为双向节点。(可以知道，默认模式下，是在锁第一次释放的时候，把所有等待锁的节点移动到EntryList中) 然后唤醒EntryList的头部节点。  根据这个逻辑，表现在Java程序中。有 T1,T2,T3,T4 四个线程按顺序去获得锁，那么最终获得锁的顺序是。 1. T1 2. T4 3. T3 4. T2\nT4是最后进来的线程会放在在cxq队列的头部，在T1释放的时候，会转移到EntryList的头部，然后首先被唤醒。\n我们来验证一下\npackage com.zhou.techstack.thread; import java.util.concurrent.TimeUnit; public class ThreadSyncOrder { public static void main(String[] args) { Object lock = new Object(); Thread t1 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;Thread 1 start!!!!!!\u0026#34;); synchronized (lock) { System.out.println(\u0026#34;Thread 1 get lock!!!!!!\u0026#34;); sleepSeconds(5); } Thread t5 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;Thread 5 start!!!!!!\u0026#34;); synchronized (lock) { System.out.println(\u0026#34;Thread 5 get lock!!!!!!\u0026#34;); } }); t5.start(); }); Thread t2 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;Thread 2 start!!!!!!\u0026#34;); synchronized (lock) { System.out.println(\u0026#34;Thread 2 get lock!!!!!!\u0026#34;); sleepSeconds(1); } }); Thread t3 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;Thread 3 start!!!!!!\u0026#34;); synchronized (lock) { System.out.println(\u0026#34;Thread 3 get lock!!!!!!\u0026#34;); sleepSeconds(1); } }); Thread t4 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;Thread 4 start!!!!!!\u0026#34;); synchronized (lock) { System.out.println(\u0026#34;Thread 4 get lock!!!!!!\u0026#34;); sleepSeconds(1); } }); t1.start(); sleepSeconds(1); t2.start(); sleepSeconds(1); t3.start(); sleepSeconds(1); t4.start(); } private static void sleepSeconds(int seconds) { try { TimeUnit.SECONDS.sleep(seconds); } catch (InterruptedException e) { e.printStackTrace(); } } } 这个代码，我们在上面的逻辑基础上，有添加了一个逻辑，就是T1在释放锁之后，又创建了一个线程T5。 我们看一下执行结果\nThread 1 start!!!!!! Thread 1 get lock!!!!!! Thread 2 start!!!!!! Thread 3 start!!!!!! Thread 4 start!!!!!! Thread 4 get lock!!!!!! Thread 5 start!!!!!! Thread 3 get lock!!!!!! Thread 2 get lock!!!!!! Thread 5 get lock!!!!!!  首先 T1第一个启动，并且获得了锁，这个没有什么问题。 接着T2,T3,T4相继启动，这时候我们根据上面的逻辑可以得知，这几个线程都会加入到_cxq中，并且顺序是 T4-\u0026gt;T3-\u0026gt;T2。 接着T1执行完毕，释放锁，这时候会把_cxq中的节点移动到EntryList中，并且唤醒头节点T4。然后T1紧接着创建T5，并启动，这时候T5，也会被加入到_cxq的头结点，只不过因为在释放的时候，_cxq中的节点已经移动到了EntryList，所以这时_cxq中只有T5一个节点。 接着T4执行完毕，释放锁，这时因为EntryList不为空，所以唤醒此时EntryList的头结点T3 同样T3执行完毕，释放锁，唤醒T2 T2执行完毕后，EntryList又变成空，所以会继续将_cxq中的节点移动到EntryList，然后唤醒头结点T5  其他唤醒策略 这里对于其他策略，我们就暂时不做分析了，但是大致的逻辑都是对_cxq和EntryList进行操作，调整他们的优先级，顺序，包括优先_cxq啊，反转_cxq啊等等。 有兴趣的同学也可以自己查看源码，或者查阅下面的参考文章。\nwait、notify、natifyAll wait 我们知道调用 lock.wait()之后，当前持有锁的线程，就会丢掉锁，并进入阻塞状态，等到调用 lock.notify()的时候才会被唤醒 下面我们来看源码来分析一下wait的实现原理。\nint ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) { //如果使用偏向锁，首先撤销偏向。  //因为wait需要将线程放在ObjectMonitor的waitSet队列中，要wait必须要膨胀为重量级锁。  if (UseBiasedLocking) { BiasedLocking::revoke_and_rebias(obj, false, THREAD); assert(!obj-\u0026gt;mark()-\u0026gt;has_bias_pattern(), \u0026#34;biases should be revoked by now\u0026#34;); } if (millis \u0026lt; 0) { TEVENT(wait - throw IAX); THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \u0026#34;timeout value is negative\u0026#34;); } //膨胀为重量级锁，如果已经是重量级锁， inflate方法会直接返回当前的ObjectMonitor  ObjectMonitor* monitor = ObjectSynchronizer::inflate(THREAD, obj()); DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis); //调用ObjectMonitor的wait方法  monitor-\u0026gt;wait(millis, true, THREAD); // This dummy call is in place to get around dtrace bug 6254741. Once  // that\u0026#39;s fixed we can uncomment the following line, remove the call  // and change this function back into a \u0026#34;void\u0026#34; func.  // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);  return dtrace_waited_probe(monitor, obj, THREAD); }  通过这个方法我们可以知道，如果是在偏向模式和轻量级模式的同步代码中调用了wait()方法，那么也会导致锁升级到重量级模式。\n然后就看ObjectMonitor的wait方法\nvoid ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) { Thread * const Self = THREAD; assert(Self-\u0026gt;is_Java_thread(), \u0026#34;Must be Java thread!\u0026#34;); JavaThread *jt = (JavaThread *)THREAD; DeferredInitialize(); // Throw IMSX or IEX.  CHECK_OWNER(); EventJavaMonitorWait event; // check for a pending interrupt  //检查是否被中断，中断了就就直接抛异常  if (interruptible \u0026amp;\u0026amp; Thread::is_interrupted(Self, true) \u0026amp;\u0026amp; !HAS_PENDING_EXCEPTION) { // post monitor waited event. Note that this is past-tense, we are done waiting.  if (JvmtiExport::should_post_monitor_waited()) { // Note: \u0026#39;false\u0026#39; parameter is passed here because the  // wait was not timed out due to thread interrupt.  JvmtiExport::post_monitor_waited(jt, this, false); // In this short circuit of the monitor wait protocol, the  // current thread never drops ownership of the monitor and  // never gets added to the wait queue so the current thread  // cannot be made the successor. This means that the  // JVMTI_EVENT_MONITOR_WAITED event handler cannot accidentally  // consume an unpark() meant for the ParkEvent associated with  // this ObjectMonitor.  } if (event.should_commit()) { post_monitor_wait_event(\u0026amp;event, 0, millis, false); } TEVENT(Wait - Throw IEX); THROW(vmSymbols::java_lang_InterruptedException()); return; } TEVENT(Wait); assert(Self-\u0026gt;_Stalled == 0, \u0026#34;invariant\u0026#34;); Self-\u0026gt;_Stalled = intptr_t(this); //设置当前线程等到的OObjectMonitor为当前的ObjectMonitor  jt-\u0026gt;set_current_waiting_monitor(this); // create a node to be put into the queue  // Critically, after we reset() the event but prior to park(), we must check  // for a pending interrupt.  //将当前线程封装成ObjectWaiter  ObjectWaiter node(Self); node.TState = ObjectWaiter::TS_WAIT; Self-\u0026gt;_ParkEvent-\u0026gt;reset(); OrderAccess::fence(); // ST into Event; membar ; LD interrupted-flag  // Enter the waiting queue, which is a circular doubly linked list in this case  // but it could be a priority queue or any data structure.  // _WaitSetLock protects the wait queue. Normally the wait queue is accessed only  // by the the owner of the monitor *except* in the case where park()  // returns because of a timeout of interrupt. Contention is exceptionally rare  // so we use a simple spin-lock instead of a heavier-weight blocking lock.  //获取一个SpinLock  Thread::SpinAcquire(\u0026amp;_WaitSetLock, \u0026#34;WaitSet - add\u0026#34;); //将当前线程添加到WaitSet队列的最后面  AddWaiter(\u0026amp;node); //释放SpinLock  Thread::SpinRelease(\u0026amp;_WaitSetLock); if ((SyncFlags \u0026amp; 4) == 0) { _Responsible = NULL; } intptr_t save = _recursions; // record the old recursion count  _waiters++; // increment the number of waiters  _recursions = 0; // set the recursion level to be 1  //释放锁对象  exit(true, Self); // exit the monitor  guarantee(_owner != Self, \u0026#34;invariant\u0026#34;); // The thread is on the WaitSet list - now park() it.  // On MP systems it\u0026#39;s conceivable that a brief spin before we park  // could be profitable.  //  // TODO-FIXME: change the following logic to a loop of the form  // while (!timeout \u0026amp;\u0026amp; !interrupted \u0026amp;\u0026amp; _notified == 0) park()  // 下面进入阻塞状态  // 如果调用的wait()，则使用park进入没有超时时间的阻塞  // 如果调用的wait(time),是使用park(time)进入有超时时间的阻塞  // 进入阻塞之后，有三种会被唤醒的情况  // 1. 阻塞时间到了  // 2. 线程被中断了  // 3. 线程被notify唤醒  int ret = OS_OK; int WasNotified = 0; { // State transition wrappers  OSThread* osthread = Self-\u0026gt;osthread(); OSThreadWaitState osts(osthread, true); { ThreadBlockInVM tbivm(jt); // Thread is in thread_blocked state and oop access is unsafe.  jt-\u0026gt;set_suspend_equivalent(); if (interruptible \u0026amp;\u0026amp; (Thread::is_interrupted(THREAD, false) || HAS_PENDING_EXCEPTION)) { // Intentionally empty  } else if (node._notified == 0) { // 根据入参 millis 判断是否有条件的挂起。这里挂起后，就不会继续往下执行了。  //除非timeout到时了，或者中断，或者notify/notifyAll  if (millis \u0026lt;= 0) { Self-\u0026gt;_ParkEvent-\u0026gt;park(); } else { ret = Self-\u0026gt;_ParkEvent-\u0026gt;park(millis); } } // were we externally suspended while we were waiting?  if (ExitSuspendEquivalent (jt)) { // TODO-FIXME: add -- if succ == Self then succ = null.  jt-\u0026gt;java_suspend_self(); } } // Exit thread safepoint: transition _thread_blocked -\u0026gt; _thread_in_vm  // Node may be on the WaitSet, the EntryList (or cxq), or in transition  // from the WaitSet to the EntryList.  // See if we need to remove Node from the WaitSet.  // We use double-checked locking to avoid grabbing _WaitSetLock  // if the thread is not on the wait queue.  //  // Note that we don\u0026#39;t need a fence before the fetch of TState.  // In the worst case we\u0026#39;ll fetch a old-stale value of TS_WAIT previously  // written by the is thread. (perhaps the fetch might even be satisfied  // by a look-aside into the processor\u0026#39;s own store buffer, although given  // the length of the code path between the prior ST and this load that\u0026#39;s  // highly unlikely). If the following LD fetches a stale TS_WAIT value  // then we\u0026#39;ll acquire the lock and then re-fetch a fresh TState value.  // That is, we fail toward safety.  //执行到这儿，说明park的线程，已经被唤醒了，可能是timeout到时了，或者中断，或者notify/notifyAll  //首先要将其从WaitSet队列中移除。因为要操作waitSet，所以也要先获取锁  if (node.TState == ObjectWaiter::TS_WAIT) { Thread::SpinAcquire(\u0026amp;_WaitSetLock, \u0026#34;WaitSet - unlink\u0026#34;); if (node.TState == ObjectWaiter::TS_WAIT) { DequeueSpecificWaiter(\u0026amp;node); // unlink from WaitSet  assert(node._notified == 0, \u0026#34;invariant\u0026#34;); node.TState = ObjectWaiter::TS_RUN; } Thread::SpinRelease(\u0026amp;_WaitSetLock); } // The thread is now either on off-list (TS_RUN),  // on the EntryList (TS_ENTER), or on the cxq (TS_CXQ).  // The Node\u0026#39;s TState variable is stable from the perspective of this thread.  // No other threads will asynchronously modify TState.  guarantee(node.TState != ObjectWaiter::TS_WAIT, \u0026#34;invariant\u0026#34;); OrderAccess::loadload(); if (_succ == Self) _succ = NULL; //WasNotified用于判断，当前节点是否是通过notify唤醒的  WasNotified = node._notified; // Reentry phase -- reacquire the monitor.  // re-enter contended monitor after object.wait().  // retain OBJECT_WAIT state until re-enter successfully completes  // Thread state is thread_in_vm and oop access is again safe,  // although the raw address of the object may have changed.  // (Don\u0026#39;t cache naked oops over safepoints, of course).  // post monitor waited event. Note that this is past-tense, we are done waiting.  if (JvmtiExport::should_post_monitor_waited()) { JvmtiExport::post_monitor_waited(jt, this, ret == OS_TIMEOUT); if (node._notified != 0 \u0026amp;\u0026amp; _succ == Self) { // In this part of the monitor wait-notify-reenter protocol it  // is possible (and normal) for another thread to do a fastpath  // monitor enter-exit while this thread is still trying to get  // to the reenter portion of the protocol.  //  // The ObjectMonitor was notified and the current thread is  // the successor which also means that an unpark() has already  // been done. The JVMTI_EVENT_MONITOR_WAITED event handler can  // consume the unpark() that was done when the successor was  // set because the same ParkEvent is shared between Java  // monitors and JVM/TI RawMonitors (for now).  //  // We redo the unpark() to ensure forward progress, i.e., we  // don\u0026#39;t want all pending threads hanging (parked) with none  // entering the unlocked monitor.  node._event-\u0026gt;unpark(); } } if (event.should_commit()) { post_monitor_wait_event(\u0026amp;event, node._notifier_tid, millis, ret == OS_TIMEOUT); } OrderAccess::fence(); assert(Self-\u0026gt;_Stalled != 0, \u0026#34;invariant\u0026#34;); Self-\u0026gt;_Stalled = 0; assert(_owner != Self, \u0026#34;invariant\u0026#34;); //要继续执行，必须重新获取锁才可以，这里就是重新获取锁的逻辑。  //是经过了一定的阻塞时间，自己唤醒的，那么需要重新尝试获取锁，通过enter方法。  ObjectWaiter::TStates v = node.TState; if (v == ObjectWaiter::TS_RUN) { enter(Self); } else { guarantee(v == ObjectWaiter::TS_ENTER || v == ObjectWaiter::TS_CXQ, \u0026#34;invariant\u0026#34;); ReenterI(Self, \u0026amp;node); node.wait_reenter_end(this); } // Self has reacquired the lock.  // Lifecycle - the node representing Self must not appear on any queues.  // Node is about to go out-of-scope, but even if it were immortal we wouldn\u0026#39;t  // want residual elements associated with this thread left on any lists.  guarantee(node.TState == ObjectWaiter::TS_RUN, \u0026#34;invariant\u0026#34;); assert(_owner == Self, \u0026#34;invariant\u0026#34;); assert(_succ != Self, \u0026#34;invariant\u0026#34;); } // OSThreadWaitState()  //执行到这儿，说明线程被唤醒，并且重新获取了锁。  //设置当前线程wait的Monitor为NULL  jt-\u0026gt;set_current_waiting_monitor(NULL); guarantee(_recursions == 0, \u0026#34;invariant\u0026#34;); _recursions = save; // restore the old recursion count  _waiters--; // decrement the number of waiters  // Verify a few postconditions  assert(_owner == Self, \u0026#34;invariant\u0026#34;); assert(_succ != Self, \u0026#34;invariant\u0026#34;); assert(((oop)(object()))-\u0026gt;mark() == markOopDesc::encode(this), \u0026#34;invariant\u0026#34;); if (SyncFlags \u0026amp; 32) { OrderAccess::fence(); } // check if the notification happened  //是否是notify唤醒的，如果不是，判断如果是中断，需要抛出中断异常  //判断是否是中断唤醒，如果是抛出中断异常  if (!WasNotified) { // no, it could be timeout or Thread.interrupt() or both  // check for interrupt event, otherwise it is timeout  if (interruptible \u0026amp;\u0026amp; Thread::is_interrupted(Self, true) \u0026amp;\u0026amp; !HAS_PENDING_EXCEPTION) { TEVENT(Wait - throw IEX from epilog); THROW(vmSymbols::java_lang_InterruptedException()); } } }  wait方法的主要逻辑是\n 将线程封装成ObjectWaiter。 添加到WaitSet队列，WaitSet是一个双向循环队列，将其添加到了队列的末尾。(操作WaitSet的时候，都需要获得一个SpinLock) 调用exit方法释放锁，exit是退出synchronized的逻辑，详细可看synchronized实现原理 将线程挂起，这里挂起根据入参millis进行了有条件的挂起（是否到时间自动唤醒）。挂起之后，线程就不再执行了，必须等待当前线程被唤醒才会继续执行。  线程被唤醒有三种情况： 到时间自动唤醒， 中断唤醒， notify/notifyAll唤醒( 这里准确来说是，notify之后，被移动到了cxq队列，然后在exit的逻辑中获取到了锁，被唤醒)。  唤醒之后从WaitSet中移除。 判断是怎么唤醒的  自己到时间唤醒，调用enter重新尝试获取锁 notify唤醒, 中断唤醒，抛出中断异常。   notify 根据java中关于notify的注释中说，notify会随机挑选一个处于阻塞状态的线程唤醒。那真的是随机吗？ 下面我们根据看源码来分析一下。\nvoid ObjectSynchronizer::notify(Handle obj, TRAPS) { //如果使用偏向，先撤销偏向  if (UseBiasedLocking) { BiasedLocking::revoke_and_rebias(obj, false, THREAD); assert(!obj-\u0026gt;mark()-\u0026gt;has_bias_pattern(), \u0026#34;biases should be revoked by now\u0026#34;); } //判断如果是轻量级锁，直接返回  markOop mark = obj-\u0026gt;mark(); if (mark-\u0026gt;has_locker() \u0026amp;\u0026amp; THREAD-\u0026gt;is_lock_owned((address)mark-\u0026gt;locker())) { return; } //获取重量级锁的ObjectMonitor并执行其notify方法  ObjectSynchronizer::inflate(THREAD, obj())-\u0026gt;notify(THREAD); }  首先和wait一样，在调用notify后，也肯定会升级到重量级锁。\nvoid ObjectMonitor::INotify(Thread * Self) { //获取notify策略，默认为2  const int policy = Knob_MoveNotifyee; Thread::SpinAcquire(\u0026amp;_WaitSetLock, \u0026#34;WaitSet - notify\u0026#34;); //取出 waitSet的头结点  ObjectWaiter * iterator = DequeueWaiter(); if (iterator != NULL) { // Disposition - what might we do with iterator ?  // a. add it directly to the EntryList - either tail (policy == 1)  // or head (policy == 0).  // b. push it onto the front of the _cxq (policy == 2).  // For now we use (b).  if (policy != 4) { iterator-\u0026gt;TState = ObjectWaiter::TS_ENTER; } //设置线程是通过notify唤醒  iterator-\u0026gt;_notified = 1; iterator-\u0026gt;_notifier_tid = Self-\u0026gt;osthread()-\u0026gt;thread_id(); ObjectWaiter * list = _EntryList; //下面根据不同的策略进行唤醒。  if (policy == 0) { // prepend to EntryList  //添加到EntryList队列的队首  if (list == NULL) { iterator-\u0026gt;_next = iterator-\u0026gt;_prev = NULL; _EntryList = iterator; } else { list-\u0026gt;_prev = iterator; iterator-\u0026gt;_next = list; iterator-\u0026gt;_prev = NULL; _EntryList = iterator; } } else if (policy == 1) { // append to EntryList  //添加到EntryList队列的队尾  if (list == NULL) { iterator-\u0026gt;_next = iterator-\u0026gt;_prev = NULL; _EntryList = iterator; } else { // CONSIDER: finding the tail currently requires a linear-time walk of  // the EntryList. We can make tail access constant-time by converting to  // a CDLL instead of using our current DLL.  ObjectWaiter * tail; for (tail = list; tail-\u0026gt;_next != NULL; tail = tail-\u0026gt;_next) /* empty */; assert(tail != NULL \u0026amp;\u0026amp; tail-\u0026gt;_next == NULL, \u0026#34;invariant\u0026#34;); tail-\u0026gt;_next = iterator; iterator-\u0026gt;_prev = tail; iterator-\u0026gt;_next = NULL; } } else if (policy == 2) { // prepend to cxq  //添加到CXQ队列的队首  if (list == NULL) { iterator-\u0026gt;_next = iterator-\u0026gt;_prev = NULL; _EntryList = iterator; } else { iterator-\u0026gt;TState = ObjectWaiter::TS_CXQ; for (;;) { ObjectWaiter * front = _cxq; iterator-\u0026gt;_next = front; if (Atomic::cmpxchg_ptr(iterator, \u0026amp;_cxq, front) == front) { break; } } } } else if (policy == 3) { // append to cxq  //添加CXQ队列的队尾  iterator-\u0026gt;TState = ObjectWaiter::TS_CXQ; for (;;) { ObjectWaiter * tail = _cxq; if (tail == NULL) { iterator-\u0026gt;_next = NULL; if (Atomic::cmpxchg_ptr(iterator, \u0026amp;_cxq, NULL) == NULL) { break; } } else { while (tail-\u0026gt;_next != NULL) tail = tail-\u0026gt;_next; tail-\u0026gt;_next = iterator; iterator-\u0026gt;_prev = tail; iterator-\u0026gt;_next = NULL; break; } } } else { ParkEvent * ev = iterator-\u0026gt;_event; iterator-\u0026gt;TState = ObjectWaiter::TS_RUN; OrderAccess::fence(); ev-\u0026gt;unpark(); } // _WaitSetLock protects the wait queue, not the EntryList. We could  // move the add-to-EntryList operation, above, outside the critical section  // protected by _WaitSetLock. In practice that\u0026#39;s not useful. With the  // exception of wait() timeouts and interrupts the monitor owner  // is the only thread that grabs _WaitSetLock. There\u0026#39;s almost no contention  // on _WaitSetLock so it\u0026#39;s not profitable to reduce the length of the  // critical section.  if (policy \u0026lt; 4) { iterator-\u0026gt;wait_reenter_begin(this); } } Thread::SpinRelease(\u0026amp;_WaitSetLock); }  这里我们看到这个逻辑就比较简单了，就是从waitSet中取出头节点，然后根据策略，放到cxq或者entryList的不同位置。 根据不同的唤醒策略进行不同的操作：\n policy == 0 ： 取出WaitSet的队首元素，添加到EntryList队列的队首。 policy == 1 ： 取出WaitSet的队首元素，添加到EntryList队列的队尾 policy == 2 ： 取出WaitSet的队首元素，添加到CXQ队列的队首(默认策略) policy == 3 ： 取出WaitSet的队首元素，添加CXQ队列的队尾  我们可以看到，notify方法并没有真正的去唤醒阻塞线程，只是把线程从waitSet移动到了cxq的头部，然后等待其他线程释放重量级锁之后，在exit方法中，真正的唤醒。\nnotifyAll void ObjectMonitor::notifyAll(TRAPS) { CHECK_OWNER(); if (_WaitSet == NULL) { TEVENT(Empty-NotifyAll); return; } DTRACE_MONITOR_PROBE(notifyAll, this, object(), THREAD); int tally = 0; while (_WaitSet != NULL) { tally++; INotify(THREAD); } OM_PERFDATA_OP(Notifications, inc(tally)); }  上面看完notify，在看notifyAll就比较简单了。他是循环调用了notify方法，也就是把waitSet中的所有节点都添加到了cxq的头部。\n其他知识点(瞎写的) 安全点 安全点的官方定义是在程序执行期间的所有GC Root已知并且所有堆对象的内容一致的点。 在这个期间，所有的用户线程都会停顿，然后由vm线程来执行一些操作 比如我们已经知道 - 偏向锁的撤销， - 批量重偏向， - 批量撤销 - CMS中的某些步骤\n当然这里只是简单的提一下。\njvm线程如何执行任务 在JVM中，每种需要VMThread执行的操作都被封装成了VM_Operation。然后具体的任务继承VM_Operation,然后把需要执行的逻辑放在doit方法中，比如批量向撤销操作就被封装成了VM_BulkRevokeBias。\n在上面的revoke_and_bias代码中，执行安全点偏向撤销的代码：\nVM_BulkRevokeBias bulk_revoke(\u0026amp;obj, (JavaThread*) THREAD, (heuristics == HR_BULK_REBIAS), attempt_rebias); VMThread::execute(\u0026amp;bulk_revoke); return bulk_revoke.status_code();  他在doit方法中执行的逻辑是\nvirtual void doit() { _status_code = bulk_revoke_or_rebias_at_safepoint((*_obj)(), _bulk_rebias, _attempt_rebias_of_object, _requesting_thread); clean_up_cached_monitor_info(); }  他的继承关系是 VM_BulkRevokeBias -\u0026gt; VM_RevokeBias -\u0026gt; VM_Operation VMThread在执行的时候，会检查每个操作对象的evaluation_mode,来判断这个操作能不能并发的执行。 evaluation_mode这个方法是是定义在父类VM_Operation，默认是safepoint也就是需要所有线程都进入安全点，也就是需要stw。 子类可以选择重写这个方法。有下面几种选择\nenum Mode { _safepoint, // blocking, safepoint, vm_op C-heap allocated  _no_safepoint,// blocking, no safepoint, vm_op C-Heap allocated  _concurrent, // non-blocking,no safepoint, vm_op C-Heap allocated  _async_safepoint // non-blocking,safepoint, vm_op C-Heap allocated  };  JVM中使用的CAS方法 在JVM代码中，实现CAS是借助于下面这个方法。\ncmpxchg_ptr(intptr_t exchange_value, volatile intptr_t* dest, intptr_t compare_value)  cmpxchg_ptr这个方法的三个参数分别是  第一个 字段变化的值 exchange value 第二个 需要修改的字段地址 address 第三个 比较值， compare value，也就是只有当字段是这个值的时候，才能发生交换。 方法的返回值，如果交换成功，返回compare value   下面借助一个例子来说明这个方法的作用\n//构建一个匿名偏向的对象头 markOop header = (markOop) ((uintptr_t) mark \u0026amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |(uintptr_t)markOopDesc::age_mask_in_place |epoch_mask_in_place)); //构建一个偏向当前线程的对象头 markOop new_header = (markOop) ((uintptr_t) header | thread_ident); //执行CAS操作 if (Atomic::cmpxchg_ptr((void*)new_header, lockee-\u0026gt;mark_addr(), header) == header) { //成功 }else{ //失败 }  根据上面的代码，的意思就是，如果锁对象的对象头的值为匿名偏向状态，那么把锁对象的对象头修改为偏向当前线程的对象头  参考文章 [java-并发之基石篇]\n[死磕Synchronized底层实现]\n[从源码分析Synchronized实现原理]\n[Wait与notify/notifyAll源码分析]\n","permalink":"https://balvboy.github.io/blog/synchronized/","summary":"Java对象头 锁升级和对象头关系很密切，所以我先了解一下对象头。\n我们先来看一下64位系统下对象头的结构，对象头结构分为两部分Mark Word和Klass Word。我们主要关注Mark Word，klass word是指向这个对象的类对象的指针。\n|--------------------------------------------------------------------------------------------------------------| | Object Header (128 bits) | |--------------------------------------------------------------------------------------------------------------| | Mark Word (64 bits) | Klass Word (64 bits) | |--------------------------------------------------------------------------------------------------------------| | unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 无锁 |----------------------------------------------------------------------|--------|------------------------------| | thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 偏向锁 |----------------------------------------------------------------------|--------|------------------------------| | ptr_to_lock_record:62 | lock:2 | OOP to metadata object | 轻量锁 |----------------------------------------------------------------------|--------|------------------------------| | ptr_to_heavyweight_monitor:62 | lock:2 | OOP to metadata object | 重量锁 |----------------------------------------------------------------------|--------|------------------------------| | | lock:2 | OOP to metadata object | GC |--------------------------------------------------------------------------------------------------------------| 对象头的格式在处于不同锁级别的时候，格式有所不同。 - 无锁状态下，可以保存的数据有对象的hashCode，垃圾回收年龄，偏向标识，锁状态 - 偏向状态下，hashCode会被替换成，线程Id,和epoch，同时还有垃圾回收年龄，偏向标识，锁状态 - 轻量级状态下，保留了锁状态，其他部分都被替换成了指向Lock Record的指针。 - 重量级状态下，指向Lock Record的指针被替换成了指向一个Monitor对象的指针。","title":"Java同步机制(一)-Synchronized"},{"content":" Redis的线程 从接触到Redis开始，就了解到Redis的一个重要特性就是单线程。 带着这个特性，我通过命令top -H -p 2582查看了Redis Server内部开启的线程，发现Redis中并非只有1个线程，而是有4个。 这里面肯定有一主线程是负责Redis的操作的，那剩下的3个线程是负责什么的呢。\n我们在Redis的源码中寻找一下答案\nRedis源码分析 1.main方法 server.supervised = redisIsSupervised(server.supervised_mode); int background = server.daemonize \u0026amp;\u0026amp; !server.supervised; //判断Redis的启动模式 if (background) daemonize(); initServer(); //初始化server服务 if (background || server.pidfile) createPidFile(); redisSetProcTitle(argv[0]); redisAsciiArt(); checkTcpBacklogSettings(); 2.initServer函数 if (server.cluster_enabled) clusterInit(); replicationScriptCacheInit(); scriptingInit(1); slowlogInit(); latencyMonitorInit(); //初始化 background io bioInit(); server.initial_memory_usage = zmalloc_used_memory(); 这里我们主要关注bioInit();方法，bio这里就是background IO的简写\n3.BIO  /* Background I/O service for Redis. * * This file implements operations that we need to perform in the background. * Currently there is only a single operation, that is a background close(2) * system call. This is needed as when the process is the last owner of a * reference to a file closing it means unlinking it, and the deletion of the * file is slow, blocking the server. * * In the future we\u0026#39;ll either continue implementing new things we need or * we\u0026#39;ll switch to libeio. However there are probably long term uses for this * file as we may want to put here Redis specific background tasks (for instance * it is not impossible that we\u0026#39;ll need a non blocking FLUSHDB/FLUSHALL * implementation). 从上面的描述可以看出BIO目前只包括一个操作，就是后台 close内核函数操作，因为这个操作牵扯到很重的文件IO，文件IO会严重阻塞redis-server，所以需要开辟线程来单独处理这些操作。\nvoid bioInit(void) { pthread_attr_t attr; pthread_t thread; size_t stacksize; int j; /* Initialization of state vars and objects */ for (j = 0; j \u0026lt; BIO_NUM_OPS; j++) { pthread_mutex_init(\u0026amp;bio_mutex[j],NULL); pthread_cond_init(\u0026amp;bio_newjob_cond[j],NULL); pthread_cond_init(\u0026amp;bio_step_cond[j],NULL); bio_jobs[j] = listCreate(); bio_pending[j] = 0; } /* Set the stack size as by default it may be small in some system */ pthread_attr_init(\u0026amp;attr); pthread_attr_getstacksize(\u0026amp;attr,\u0026amp;stacksize); if (!stacksize) stacksize = 1; /* The world is full of Solaris Fixes */ while (stacksize \u0026lt; REDIS_THREAD_STACK_SIZE) stacksize *= 2; pthread_attr_setstacksize(\u0026amp;attr, stacksize); /* Ready to spawn our threads. We use the single argument the thread * function accepts in order to pass the job ID the thread is * responsible of. */ for (j = 0; j \u0026lt; BIO_NUM_OPS; j++) { //循环创建bio线程  void *arg = (void*)(unsigned long) j; if (pthread_create(\u0026amp;thread,\u0026amp;attr,bioProcessBackgroundJobs,arg) != 0) { serverLog(LL_WARNING,\u0026#34;Fatal: Can\u0026#39;t initialize Background Jobs.\u0026#34;); exit(1); } bio_threads[j] = thread; } } 这个函数，从名字就可以看出它的主要功能是完成BIO的初始化操作，在源代码中我们找到了线程开辟操作，这里的思路是线程池，那么问题来了，BIO线程池中到底开辟几个线程呢？\n通过观察第121行，可以看到BIO_NUM_OPS参数影响了BIO线程池的线程量，那么这个数值到底为多少呢，我们稍微跟踪一下就可以获取：\n42 #define BIO_NUM_OPS 3 //bio.h文件 现在可以看出BIO_NUM_OPS默认数值为3，这个数值加上1个主线程，正好是图片中的4个线程。\n4. BIO线程执行的操作 while(1) { listNode *ln; /* The loop always starts with the lock hold. */ if (listLength(bio_jobs[type]) == 0) { pthread_cond_wait(\u0026amp;bio_newjob_cond[type],\u0026amp;bio_mutex[type]); continue; } /* Pop the job from the queue. */ ln = listFirst(bio_jobs[type]); //从任务队列中获取任务  job = ln-\u0026gt;value; /* It is now possible to unlock the background system as we know have * a stand alone job structure to process.*/ pthread_mutex_unlock(\u0026amp;bio_mutex[type]); /* Process the job accordingly to its type. */ if (type == BIO_CLOSE_FILE) { //文件关闭操作  close((long)job-\u0026gt;arg1); } else if (type == BIO_AOF_FSYNC) { //异步文件同步操作  redis_fsync((long)job-\u0026gt;arg1); } else if (type == BIO_LAZY_FREE) { //redis内存懒释放  /* What we free changes depending on what arguments are set: * arg1 -\u0026gt; free the object at pointer. * arg2 \u0026amp; arg3 -\u0026gt; free two dictionaries (a Redis DB). * only arg3 -\u0026gt; free the skiplist. */ if (job-\u0026gt;arg1) lazyfreeFreeObjectFromBioThread(job-\u0026gt;arg1); //懒释放对象  else if (job-\u0026gt;arg2 \u0026amp;\u0026amp; job-\u0026gt;arg3) lazyfreeFreeDatabaseFromBioThread(job-\u0026gt;arg2,job-\u0026gt;arg3);//懒释数据库  else if (job-\u0026gt;arg3) lazyfreeFreeSlotsMapFromBioThread(job-\u0026gt;arg3);//懒释放槽位型Map内存  } else { serverPanic(\u0026#34;Wrong job type in bioProcessBackgroundJobs().\u0026#34;); } zfree(job); 通过最初的现象，我们可以看出Redis-server开辟了四个线程，并通过源代码分析，我们可以看出后三个线程是BIO线程，这三个线程完成的功能是一样的，主要包括：从BIO任务队列中取出任务，文件描述符关闭、磁盘文件同步、内存对象懒释放操作。 其他的任务均由主线程完成。\nRedis单线程的优势 我们看到Redis在处理大多数命令的时候，是通过单线程来处理的这可能给Redis带来下面的优势 1. 使用单线程模型也能并发的处理客户端的请求； 2. 使用单线程模型能带来更好的可维护性，方便开发和调试； 3. Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；\n单线程也能并发 这里首先要说一下一个老生常谈的问题，并发和并行的区别。 这里用一个例子来说明 \u0026gt; 例如，一个调酒师能够照顾几个顾客，而一次只能准备一种饮料。因此，他可以在没有并行的情况下提供并发。\n所以说并发是，在一个时间段内能够处理多个请求即可，而并行是在同一个时刻能够处理多个请求。\n而Redis就可以理解为，上面的例子中提到的调酒师，Redis通过IO 多路复用技术就能够方便的实现同时照看成百上千个顾客,但是Redis在同一时刻只能处理一个顾客的请求。\n但是因为Redis几乎所有操作都是在内存中完成，所以他的每个操作的耗时都非常短，这里有一个计算机各个硬件执行时间的对比。 我们看到内存的读取访问时间是在纳秒级别，而到了硬盘就到了毫秒级。所以Redis这样的以内存操作为主的服务，能够达到每秒 10W甚至100W的并发都是有可能的(当然这个和很多情况有关，比如key的大小，命令的时间复杂度等等)。 同样在这种主要针对内存操作的情况下，Redis对于CPU的消耗是相对比较小的。所以CPU通常并不会成为Redis的瓶颈。 \u0026gt; It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU. \u0026gt; FAQ\n如果说你想更好的让Redis利用CPU，或者说Redis的并发量还不能满足你的要求，Redis给出的官方建议是，使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。 \u0026gt; However, to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. At some point a single box may not be enough anyway, so if you want to use multiple CPUs you can start thinking of some way to shard earlier. \u0026gt; FAQ\n可维护性 可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。\n性能瓶颈 上面也提到了，CPU一般不会成为Redis的瓶颈，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。\n AOF 是 Redis 的一种持久化机制，它会在每次收到来自客户端的写请求时，将其记录到日志中，每次 Redis 服务器启动时都会重放 AOF 日志构建原始的数据集，保证数据的持久性。\n 多线程虽然会帮助我们更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销，其中包括：\n 保存线程 1 的执行上下文； 加载线程 2 的执行上下文；  频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。\n引入多线程  However with Redis 4.0 we started to make Redis more threaded. For now this is limited to deleting objects in the background, and to blocking commands implemented via Redis modules. For the next releases, the plan is to make Redis more and more threaded.\n 从4.0版本开始，Redis加入了一些可以被其他线程异步处理的删除操作。\n删除操作 我们可以在 Redis 在中使用 DEL 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是同步地删除这些键值对也不会消耗太多的时间。\n但是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。\n总结 Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；（因为单线程的Redis已经这么快了，而且瓶颈不在CPU，并且开发起来更简单，所以顺理成章的使用了单线程） 而 Redis 引入多线程操作也是出于性能上的考虑(目前只是针对一些大键的删除)，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。\n参考 [Redis-Server 线程模型源码剖析]\n[为什么Redis使用单线程模型]\n[Redis is single-threaded, then how does it do concurrent I/O?]\n[为什么说Redis是单线程的以及Redis为什么这么快！]\n","permalink":"https://balvboy.github.io/blog/redis/","summary":"Redis的线程 从接触到Redis开始，就了解到Redis的一个重要特性就是单线程。 带着这个特性，我通过命令top -H -p 2582查看了Redis Server内部开启的线程，发现Redis中并非只有1个线程，而是有4个。 这里面肯定有一主线程是负责Redis的操作的，那剩下的3个线程是负责什么的呢。\n我们在Redis的源码中寻找一下答案\nRedis源码分析 1.main方法 server.supervised = redisIsSupervised(server.supervised_mode); int background = server.daemonize \u0026amp;\u0026amp; !server.supervised; //判断Redis的启动模式 if (background) daemonize(); initServer(); //初始化server服务 if (background || server.pidfile) createPidFile(); redisSetProcTitle(argv[0]); redisAsciiArt(); checkTcpBacklogSettings(); 2.initServer函数 if (server.cluster_enabled) clusterInit(); replicationScriptCacheInit(); scriptingInit(1); slowlogInit(); latencyMonitorInit(); //初始化 background io bioInit(); server.initial_memory_usage = zmalloc_used_memory(); 这里我们主要关注bioInit();方法，bio这里就是background IO的简写\n3.BIO  /* Background I/O service for Redis. * * This file implements operations that we need to perform in the background.","title":"Redis为何使用单线程 "},{"content":" 什么是HTTPS HTTPS简单的说就是安全版的HTTP。 因为HTTP协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，为了安全传输敏感数据，网景公司设计了SSL（Secure Socket Layer），在HTTP的基础上添加了一个安全传输层，对所有的数据都加密后再进行传输，客户端和服务器端收到加密数据后按照之前约定好的秘钥解密。\nHTTPS是如何保证安全的 HTTPS的安全性是建立在密码学的基础之上的，有很多算法起到了至关重要的作用。\nHTTPS的交互过程 通过上面的描述，我们已经能大概知道HTTPS是使用加密算法在浏览器和服务器之前传递秘钥，然后再使用秘钥完成信息的加解密。所以这个秘钥是如何生成的，还有秘钥是如何在浏览器和服务器之间传递的就成了HTTPS的关键，下面我们来详细的了解一下这个过程。\n1.交互流程  Client Hello 客户端（通常是浏览器）先向服务器发出加密通信的请求,请求大概中包括下面内容  支持的协议版本，比如TLS 1.0版。 一个客户端生成的随机数 Random Number-RNc，稍后用于生成\u0026rdquo;对话密钥\u0026rdquo;。 支持的加解密方法，比如对称加密支持AES，秘钥交换算法支持RSA、DH，签名算法支持sha256等。(在更高版本的TLS协议中，交换的是密码学套件，所谓的套件就是一整套的加解密，秘钥交换方案)。 支持的压缩方法。  服务器收到请求,然后响应  确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 一个服务器生成的随机数Random Number-RNs，稍后用于生成\u0026rdquo;对话密钥\u0026rdquo;。 确认使用的加密方法、秘钥交换算法、签名算法等等。 把服务器证书发送给客户端。 服务器要求验证客户端(浏览器)的证书(可选，大部分的服务器都不会要求)。  客户端收到服务器证书之后，会检查证书的有效性，如果服务器证书并不是经过CA机构认证的，浏览器就会在这个时候给用户提出警告。 客户端收到服务器验证客户端证书的请求，会将自己证书发送给服务器。客户端如果没有证书，则需要发送一个不包含证的证书消息。如果服务器需要客户端身份验证才能继续握手，则可能会使用致命的握手失败警报进行响应。(双向认证一般只存在于银行等一些安全性要求比较高的场景中，像早些时候我们使用的网银，里面存储的就是证书，用来在交易的时候和服务器端进行双向认证，保证安全) 服务器收到客户端证书，校验客户端证书是否有效 客户端把把上面流程中发送的所有消息(除了Client Hello)，使用客户端的私钥进行签名，然后发送给服务器。 服务器也保存着之前客户端发送的消息，然后用客户端发送过来的公钥，进行验签。 客户端生成一个Pre-Master-Secret随机数，然后使用服务器证书中的公钥加密，发送给服务器端。 服务器端收到Pre-Master-Secret的加密数据，因为是使用它的公钥加密的，所以可以使用私钥解密得到Pre-Master-Secret。 这时候客户端和服务端都同时知道了，RNc、RNs、Pre-Master-Secret这三个随机数，然后客户端和服务器端使用相同的PRF算法计算得到一个Master-Secret。然后可以从Master-Secret中再生成作为最终客户端和服务器端消息对称加密的秘钥，和对消息进行认证的MAC秘钥。  参考:TLS协议 TLS RFC\n2.Pre-Master-Secret Pre-Master-Secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。 所以，服务端需要对密文中解密出来对的Pre-Master-Secret中的版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被篡改，则立即停止发送任何消息。\n参考：pre-master secret \n3.Master-Secret 客户端和服务端在生成Master-Secret的之后，会把Master-Secret作为PRF的参数，继续运算，最终得到下面6个秘钥，分别用于MAC算法和加解密算法。\n   秘钥名称 秘钥作用     client write MAC key 客户端对发送数据进行MAC计算使用的秘钥，服务端使用同样的秘钥确认数据的完整性   server write MAC key 服务端对返回数据进行MAC计算使用的秘钥，客户端使用同一个秘钥验证完整性   client write key 对称加密key，客户端数据加密，服务端解密   server write key 服务端加密，客户端解密   client write IV 初始化向量，运用于分组对称加密   server write IV 初始化向量，运用于分组对称加密    参考: TLS 中的密钥计算\n4.PRF算法 PRF表示（Pseudo-random Function）伪随机函数\nMaster-secret和最终的6个秘钥都是依靠PRF来生成的。\nPRF是利用hash函数来实现，然后依赖递归可以生成无限长度的序列。具体使用哪种hash算吗，在TLS1.2之后需要的密码学套件中指定。\n然后master-secret和6个秘钥只需要PRF生成满足他们所需要的长度即可。\n比如Master-Secret的长度一直都是48位。\n参考: TLS 中的密钥计算\n5.双向认证 其实我们日常访问的绝大多数网站，都是单向认证的(也就是说并没有上面流程中的3、4、5、6步骤)，这里为例展示HTTPS的完整交互流程，所以分析的是双向认证。 服务器可以选择是否要真正客户端的证书。这里以使用NGINX配置HTTPS为例。 如果我们在NGINX的HTTPS相关配置中添加了下面这个配置，就表示需要验证客户端的证书。\nssl_verify_client on; 6.密码学套件 密码学套件是TLS发展了一段时间积累了很多密码学使用的经验之后提出的一整套的解决方案。一个套件中包含了应用于整个握手和传输使用到的所有非对称加密，对称加密和哈希算法，甚至包括证书的类型。\n密码学套件是SSLv3开始提出的概念，从此，零散的密码学选择问题变成了一个整体的密码学套件选择的问题。后续的版本在升级的时候会产生新的安全强度更高的密码学套件，同时抛弃比较弱的密码学套件\n密码套件分为三大部分：密钥交换算法，数据加密算法，消息验证算法。\n下面来分析一个密码学套件的名称，来解释一下它包含的意思\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA226 * WITH前面表示使用的非对称加密算法，WITH后面表示使用的对称加密和完整性校验算法\n TLS:表示TLS协议，如果未来TLS改名，这个名字可能会变，否则会一直是这个名字 DHE_RSA:这里又两个算法，表示第一个是约定密钥交换的算法，第二个是约定证书的验证算法。如果只有一个，表示这两中操作都是用同一个算法。 AES_256_CBC:指的是AES这种对称加密算法的256位算法的CBC模式，AES本身是一类对称加密算法的统称，实际的使用时要指定位数和计算模式，CBC就是一种基于块的计算模式。 SHA:表示用来校验数据完整性生成MAC，使用的算法，在TLS1.2之后也表示PRF算法使用的算法。  除了这种比较好理解的密码学套件，还有见到一些比较奇怪的，比如 ALL:!EXPORT:!LOW:!aNULL:!SSLv2 我来解释一下，上面出现的字段，更为详细的大家可以去查看下面的文章。 * ALL:表示所有除了明文(eNULL)传递意外的密码学套件 * !EXPORT:EXPORT表示有出口限制的密码学算法，前面加上!,就表示排除掉包含这些算法的密码学套件。 * !LOW:表示排除掉标记为密码强度比较低的算法。 * !aNULL:表示排除不提供身份验证算法的套件。 * !SSLv2:表示排除所有SSLv2的套件。\n大家可以使用openssl ciphers xxx命令查看套件表达式，所包含的密码学套件\n参考: 密码学套件 密码学套件表达式\nHTTPS中的算法 除了了解HTTPS的交互流程，HTTPS中使用的算法及算法的作用，也是我们必须要了解的一部分。 下面会按照算法的作用进行分类，并简单的介绍其中比较常见算法的作用，单并不会对算法的原理做过多的说明(主要是我也弄不明白)，会把相关的讲解原理的文章链接提供出来，大家有兴趣的可以自行去了解。\nHTTPS中算法，根据算法的用途可以分为几大类 * 加密算法 - 加密传递的信息，包括对称加密和非对称加密 * 秘钥传递算法 - 在客户端和服务器端传递加密使用的key，当然通过上面的流程我们知道并不是直接传递加密的key * 信息摘要/签名算法 - 对传递的信息摘要，确保信息在传递过程中不会被篡改\n1.加密算法 加密算法基本可以分为两种 对称加密和非对称加密\n对称加密 顾名思义就是加密和解密都是用一个同样的秘钥，它的优点就行加解密的速度很快，缺点就是尤其需要注意秘钥的传输，不能泄露。 包含的算法有 AES DES RC4等，常用的是AES\n非对称加密-RSA 非对称加密有一对秘钥公钥和私钥。使用公钥加密，然后使用私钥解密。公钥可以公开的发送给任何人。使用公钥加密的内容，只有私钥可以解开。安全性比对称加密大大提高。缺点是和对称加密相比速度较慢，加解密耗费的计算资源较多。\n这里我们先只需要了解RSA之所以安全的原因是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。\n所以这个大整数越大，RSA被破解的难度也就越高。\n具体的算法可以了解下面的两篇文章。\nRSA算法原理1 RSA算法原理2\n2.秘钥交换算法 常见的秘钥交换算法有下面几种： * RSA：算法实现简单，诞生于 1977 年，历史悠久，经过了长时间的破解测试，安全性高。缺点就是需要比较大的素数（目前常用的是 2048 位）来保证安全强度，很消耗 CPU 运算资源。RSA 是目前唯一一个既能用于密钥交换又能用于证书签名的算法。\n DH：diffie-hellman 密钥交换算法，诞生时间比较早（1977 年），但是 1999 年才公开。缺点是比较消耗 CPU 性能。\n ECDHE：使用椭圆曲线（ECC）的 DH 算法，优点是能用较小的素数（256 位）实现 RSA 相同的安全等级。缺点是算法实现复杂，用于密钥交换的历史不长，没有经过长时间的安全攻击测试。\n ECDH：不支持 PFS，安全性低，同时无法实现 false start。\n DHE：不支持 ECC。非常消耗 CPU 资源 。\n  因为这些算法都用到了数论的一些知识，我自己也是似懂非懂。但是他们有一个共同点就是都是运用了质数和模运算相关的数学原理和公式，感觉他们之间应该也是有一定的关联和关系。(后悔没有好好学数学呀)\n参考： RSA和DH算法 ECDHE-wiki DH-wiki Nginx SSL 性能优化\n3.摘要/签名算法 HTTPS中常见的有MD5、SHA256、MAC、HMAC等，下面主要说明一下这些算法的区别和联系。\n1. MD5 是一种消息摘要算法(Message-Digest Algorithm),一种被广泛使用的密码散列函数(Hash Function)，针对任意长度的输入，可以产生出一个定长128位（16字节）的散列值。\n2. SHA SHA表示安全哈希算法(Secure Hash Algorithm)，经过了很长时间的发展SHA算法已经发展成了一个拥有众多算法的SHA家族。常见的有SHA0、SHA1、SHA2(包含SHA224、SHA256等)、SHA3。0，1，2，3表示SHA算法大的版本，每个大版本中又根据输出字节长度的不同分为和不同的算法。比如SHA256 使用的是SHA2，输出的是256字节。更详细的大家可以看下面wiki百科中的内容，很详细。\nSHA称作安全哈希算法的原因是，它相比MD5算法，需要更多的计算次数，最终的输出长度也要长，(SHA0和SHA1是160字节。SHA256是256字节)。如果想要破解需要付出比MD5高的多的计算次数。\n经过长时间的发展，MD5和SHA0、SHA1已经被认为不安全，已经不再建议使用。 SHA2是目前被最常使用的算法，目前还没有针对SHA2的有效攻击。 SHA3是2015年才发布的，还没有大规模的取代SHA2。\n参考 SHA算法家族\n3. MAC 和 HMAC 相对于上面的MD5和SHA，这两种算法对于我算是比较陌生的。\nMAC是消息认证码(Message Authentication Code)的简称。它和上面两种算法的区别是MAC的计算需要一个Key(上面HTTPS流程中就生了计算MAC的KEY)。只有知道了KEY才能正确的计算出对应的MAC。\nHMAC的全称是密钥散列消息认证码(Keyed-hash message authentication code)。是指用秘钥并使用Hash散列算法生成认证码的一类算法的总称。\n那么MAC算法和HMAC算法是什么关系呢？\n我觉得可以这么理解。 MAC只是定义了一个概念\u0026mdash;使用一个key，给一段消息生成一个授权码；但是生成这个授权码的算法它并没有定义。所以如果你使用SHA256这种Hash散列算法来生成授权码，那么这种算法就可以被称为HMAC-SHA256。 所以HMAC是MAC的一类实现方式，就像快排是排序算法中的一种实现方式一样。\n参考： MAC-Wiki Difference between MAC and HMAC?\n4. Salted Hash 和 HMAC 加盐Hash和HMAC在某种程度上很相似，但是在使用场景上还是有很大的区别。目前还有没找到解释的比较好的文章，后面再进行补充 * [ ] todo\nHTTPS证书 现在HTTPS基本已经成为了一个网站的标配。想要给一个网站添加对HTTPS的支持，就需要针对这个网站的域名申请证书。\nHTTPS证书类型 这里顺便说明一下目前的HTTPS证书大概分为3类。 * 域名型HTTPS 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站； * 企业型HTTPS 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高； * 增强型HTTPS 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。\n我们看到越是高等级的证书，审核的严格程度也就越高。并在浏览器中会有一定程度的展示，也会给用户一种更为安全的感觉，当然价格也是更加昂贵。\nHTTPS证书内容和结构  Certificate  Version Number（证书版本） Serial Number(序列号) Signature Algorithm ID（该和客户端使用的签名算法） Issuer Name(证书签发者 DN) Validity period(有效期)  Not Before(生效开始时间) Not After(有效结束时间)  Subject name(证书使用者) Subject Public Key Info(证书)  Public Key Algorithm(公钥算法) Subject Public Key(证书公钥)  Issuer Unique Identifier (optional)(签发者唯一身份信息，可选) Subject Unique Identifier (optional)(使用者唯一身份信息，可选) Extensions (optional)(扩展字段)  \u0026hellip;  Signature(CA机构对证书的签名)   参考 X.509 wiki X.509 数字证书的基本原理及应用 X.509证书的读取与解释\n如何获得HTTPS证书 简单来说获的HTTPS证书有两种方式 * 在有CA认证的机构申请 * 自己生成\n1.通过CA机构申请 申请CA机构认证的证书大致需要以下步骤\n1.1 生成CSR(Certificate Signing Request)文件 主要方式有两种，本地生成和在线生成\n 通过openssl命令本地生成CSR\nopenssl req -new -nodes -sha256 -newkey rsa:2048 -keyout myprivate.key -out mydomain.csr -new 指定生成一个新的CSR， nodes指定私钥文件不被加密, sha256 指定摘要算法， keyout生成私钥, newkey rsa:2048 指定私钥类型和长度， 最终生成CSR文件mydomain.csr。 通过线上网站生成，一般需要填写下面的内容。   线上的工具会把公钥加入到CSR文件中，并同时生成私钥。\n参考:在线CSR申请\n1.2 CA机构对证书签名 接下来就需要按照CA机构的要求，和想要申请的证书类型，提交相关材料。\nCA收到CSR并验证相关材料，并审核通过之后。需要进行的很重要的一个步骤就是:使用CA机构的私钥对提供证书中的内容进行签名，并把签名的结果存放在证书的数字签名部分。\nCA机构签名完，并发送给我们之后，我们就能够把证书部署在我们的服务器中了。\n2.自己生成证书 参考 自己生成HTTPS证书\n大家可以参考上面的文章自己创建一个证书试试。 自己创建的证书同样可以完成上面的步骤。只不过有一点就是，因为自己生成的证书没有得到CA机构的私钥签名，所以当浏览器通过HTTPS握手获得服务器证书的时候，没有办法确定这个证书是否就是来自请求的服务器。 这个时候浏览器就会给出该网站不安全的提示。\n如果客户端不能确认证书是安全，但是却贸然使用，就会有受到中间人攻击的风险。\n中间人攻击 具体的概念大家可以去下面的文章中了解一下，我们这里直接举例说明一下。\n这种中间人攻击的方式，常见于公共的未加密的WIFI。 * A想和B通讯，建立连接，并请求了B的证书。 * C通过提供公共WIFI的方式，监听了A和B的通讯，拦截了B发送给A的证书，并把证书替换成自己的。 * 如果A没有证书检验机制的话，那么A并不能发现证书已经被替换了。 * A还是以为在和B通讯。就会使用已经被替换了的证书中的公钥(也就是C的公钥)进行加密。 * C拦截到消息，使用自己的私钥解密，获得原始的请求数据。然后就能随意篡改，然后使用B的公钥加密，在发送给B，达到了攻击的目的。\n中间人攻击还有另外一种方式，危害性更大。 如果有恶意程序在我们的手机或者浏览器中安装了一个证书，并且诱导我们把这书设置为信任证书。 那么如果有其他恶意程序，在和我们的终端进行HTTPS握手的时候，发送给我们使用上面的证书签名的证书，那么我们的终端将无法识别这个恶意证书。导致中间人攻击的发生。\n要抵御中间人攻击的一个有效方式就是，充分利用证书的认证机制，还有对于证书的安装和信任要各位谨慎。\n参考：中间人攻击-Wiki\n证书认证链 上面的HTTPS流程中提到，客户端收到服务端证书之后，会进行验证。HTTPS证书的认证是链状的，每一个证书都需要它上级的证书来验证是否有效。\n链式结构 目前我们常见的证书链中一般分为3级。不过中间证书这部分，也有可能又分为多级。但是也是保持这样的链式结构。\n 根证书(Root CA)  中介(中间)证书(Intermediates)  终端实体证书(End-user)    终端证书的签发者是中间证书。 中间证书的签发者是上级中间或者根证书。 根证书的签发者是他自己。\nHTTPS的证书链，是一个自顶向下的信任链，每一个证书都需要它的上级证书来验证有效。所以根证书的作用就尤为重要，如果系统根证书被篡改，系统的安全性就受到威胁。\n根证书一般是通过系统，或者浏览器内置到我们的电脑的中的。系统更新或者浏览器更新的时候，也有可能会添加新的根证书。\n所以不要轻易的信任根证书，除非你是开发者，了解自己的所作所为。\n参考: 数字证书\n验证证书 我们以wiki百科的证书链来举例 当我们和wiki的服务器建立HTTPS连接的时候，会获得wiki的(End-User)证书(后面简称为WK证书)。\n服务器获得WK证书后，会用下面的几个方式来验证证书。\n1.证书有效性时间验证 CA在颁发证书时，都为每个证书设定了有效期，包括开始时间与结束时间。系统当前时间不在证书起止时间的话，都认为证书是无效的。\n2.证书完整性验证 上面证书链的时候说到每个证书需要他的上级证书来确保证书的有效性。这个确保的方式就是数字签名。\n所以我们只需要，使用CA证书中的公钥和对应的签名算法来验证一下签名，就能够确认证书的有效性。\n那么现在有一个问题就是，如何获取WK证书的上一级证书呢？ 这里两种可能 1. 这个证书已经存在于你的电脑中了，直接使用就可以 2. 你的电脑中还没有这个证书，需要下载(这里有个疑问就是，根据什么区下载这个证书，很有可能是签发者的DN，但是查了很多资料，并没有找到证据)\n拿到CA证书之后，就能够使用CA证书中的公钥对WK证书验签了。\n一样的道理，CA证书的有效性需要CA的上级证书，也就是Root证书来证明。验证的过程是基本一致的。\n参考: HTTPS 精读之 TLS 证书校验 证书有效性验证、根证书\n3.IP/域名验证 在申请域名的时候，都会指定证书所针对的域名。所以这里就是验证，当前请求的域名，是否在这个证书所包含的域名列表中。\n证书里面的域名范围通常使用通配符来表示。 但是以*.example.com的二级域名范围就不能包含a.b.example.com这个三级域名。\n4.证书吊销验证 浏览器获取到服务器证书后，需要判断该证书是不是已经被CA机构吊销。如果已经吊销需要浏览器给出提示。\n这里只大概说一下证书的吊销校验主要分2种 1. 通过CRL(Certificate Revocation List) 证书吊销列表 需要定时的去更新CA机构提供的CRL文件，这个里面记录了改CA机构下所有被吊销的证书。CRL目前正在被OCSP取代，因为CRL不及时，并且每个CRL文件，比较大，影响用户体验。 2. 通过OCSP(Online Certificate Status Protocol) 在线证书状态协议 这是一个实时的通过证书的序列号去查询证书状态的协议，但是这个有一个问题是，因为每次建立HTTPS链接都需要请求这个接口，所以如果这个接口响应慢的话，十分影响用户的体验。所以需要浏览器这边有一个策略，就是如果在一定时间内OCSP没有响应，那怎么处理。 如果强依赖OCSP的话，会容易引起OCSP的单点故障。\n详细的胡啊 参考： 你不在意的证书吊销机制 PKI体系中的证书吊销\n总结 HTTPS的相关总结就先到这里，不知道有没有解决大家的疑问。如果有疑问或者问题，欢迎大家在评论区继续沟通。\n参考 HTTPS 基本过程\nTLS 协议\n数字证书\n你不在意的证书吊销机制\nPKI体系中的证书吊销\nHTTPS 精读之 TLS 证书校验\n证书有效性验证、根证书\n数字证书\n中间人攻击-Wiki\n自己生成HTTPS证书\n在线CSR申请\nX.509 wiki\nX.509 数字证书的基本原理及应用\nX.509证书的读取与解释\nMAC-Wiki\nDifference between MAC and HMAC?\nSHA算法家族\nRSA和DH算法\nECDHE-wiki\nDH-wiki\nRSA算法原理1\nRSA算法原理2\n密码学套件\n密码学套件表达式\nTLS 中的密钥计算\npre-master secret \nTLS协议\nTLS RFC\nNginx SSL 性能优化\n","permalink":"https://balvboy.github.io/blog/https%E8%AF%A6%E8%A7%A3/","summary":"什么是HTTPS HTTPS简单的说就是安全版的HTTP。 因为HTTP协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，为了安全传输敏感数据，网景公司设计了SSL（Secure Socket Layer），在HTTP的基础上添加了一个安全传输层，对所有的数据都加密后再进行传输，客户端和服务器端收到加密数据后按照之前约定好的秘钥解密。\nHTTPS是如何保证安全的 HTTPS的安全性是建立在密码学的基础之上的，有很多算法起到了至关重要的作用。\nHTTPS的交互过程 通过上面的描述，我们已经能大概知道HTTPS是使用加密算法在浏览器和服务器之前传递秘钥，然后再使用秘钥完成信息的加解密。所以这个秘钥是如何生成的，还有秘钥是如何在浏览器和服务器之间传递的就成了HTTPS的关键，下面我们来详细的了解一下这个过程。\n1.交互流程  Client Hello 客户端（通常是浏览器）先向服务器发出加密通信的请求,请求大概中包括下面内容  支持的协议版本，比如TLS 1.0版。 一个客户端生成的随机数 Random Number-RNc，稍后用于生成\u0026rdquo;对话密钥\u0026rdquo;。 支持的加解密方法，比如对称加密支持AES，秘钥交换算法支持RSA、DH，签名算法支持sha256等。(在更高版本的TLS协议中，交换的是密码学套件，所谓的套件就是一整套的加解密，秘钥交换方案)。 支持的压缩方法。  服务器收到请求,然后响应  确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 一个服务器生成的随机数Random Number-RNs，稍后用于生成\u0026rdquo;对话密钥\u0026rdquo;。 确认使用的加密方法、秘钥交换算法、签名算法等等。 把服务器证书发送给客户端。 服务器要求验证客户端(浏览器)的证书(可选，大部分的服务器都不会要求)。  客户端收到服务器证书之后，会检查证书的有效性，如果服务器证书并不是经过CA机构认证的，浏览器就会在这个时候给用户提出警告。 客户端收到服务器验证客户端证书的请求，会将自己证书发送给服务器。客户端如果没有证书，则需要发送一个不包含证的证书消息。如果服务器需要客户端身份验证才能继续握手，则可能会使用致命的握手失败警报进行响应。(双向认证一般只存在于银行等一些安全性要求比较高的场景中，像早些时候我们使用的网银，里面存储的就是证书，用来在交易的时候和服务器端进行双向认证，保证安全) 服务器收到客户端证书，校验客户端证书是否有效 客户端把把上面流程中发送的所有消息(除了Client Hello)，使用客户端的私钥进行签名，然后发送给服务器。 服务器也保存着之前客户端发送的消息，然后用客户端发送过来的公钥，进行验签。 客户端生成一个Pre-Master-Secret随机数，然后使用服务器证书中的公钥加密，发送给服务器端。 服务器端收到Pre-Master-Secret的加密数据，因为是使用它的公钥加密的，所以可以使用私钥解密得到Pre-Master-Secret。 这时候客户端和服务端都同时知道了，RNc、RNs、Pre-Master-Secret这三个随机数，然后客户端和服务器端使用相同的PRF算法计算得到一个Master-Secret。然后可以从Master-Secret中再生成作为最终客户端和服务器端消息对称加密的秘钥，和对消息进行认证的MAC秘钥。  参考:TLS协议 TLS RFC\n2.Pre-Master-Secret Pre-Master-Secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。 所以，服务端需要对密文中解密出来对的Pre-Master-Secret中的版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被篡改，则立即停止发送任何消息。\n参考：pre-master secret \n3.Master-Secret 客户端和服务端在生成Master-Secret的之后，会把Master-Secret作为PRF的参数，继续运算，最终得到下面6个秘钥，分别用于MAC算法和加解密算法。\n   秘钥名称 秘钥作用     client write MAC key 客户端对发送数据进行MAC计算使用的秘钥，服务端使用同样的秘钥确认数据的完整性   server write MAC key 服务端对返回数据进行MAC计算使用的秘钥，客户端使用同一个秘钥验证完整性   client write key 对称加密key，客户端数据加密，服务端解密   server write key 服务端加密，客户端解密   client write IV 初始化向量，运用于分组对称加密   server write IV 初始化向量，运用于分组对称加密    参考: TLS 中的密钥计算","title":"HTTPS详解 "},{"content":" 字符编码 字符编码是我们在开发过程中无法逃避的问题，经常遇到各种各样的乱码。通常我们会在几个地方设置一下字符编码方式，然后乱码解决了，然后就会把字符编码放到一边，很少有机会或者会想到去专门系统的了解一下字符编码知识。\n我之前也写过一些编码的文章，但是回过头在去看的时候，发现这也不对，那也不对，主要就是因为当时了解的比较片面。这次希望能够把常见的几种编码，和在编程中常见的编码问题搞清楚。\n字符编码和字符集  字符集 字符集的意思就是所有字符的集合，并且每一个字符都有一个唯一的编号。 字符编码 字符编码就是把字符集内字符的编号转换成二进制数据的一种规则。  所以说字符集和字符编码并不是一个东西，字符编码需要依赖于字符集。但是大多数字符编码的名称就是它对应字符集的名称，比如 - ASCII字符集和ASCII字符编码 - GBK字符集和GBK字符编码\n但是有一个例外就是基于Unicode字符集的UTF系列的字符编码，这个我们后面会重点说。 下面简单介绍几个我们比较熟悉的字符集，不会详细讨论设计细节，如果大家有需要可以去查看字符集的维基百科。后面后给出链接。\nASCII ASCII可以认为是最早的字符集，它定义了128个字符，其中包括32个不可见字符(比如一些控制字符 换行，回车等)，还有96个可见字符(大写小写字母，标点符号等)。 ASCII的字符编码也比较简单，就是用二进制来表示字符的序号，因为它一共只有128个，所以只需要用到一个字节的后7位。\nASCII维基百科\nISO 8859-1 ISO 8859-1 这个也是我们很熟悉的字符集，这个字符集是以ASCII为基础，并扩充了一些拉丁字母，也被叫做Latin-1字符集。 因为拉丁国家众多，有很多国家都对这个字符集进行了修改或者扩充。 虽然有这么多的字符集，但是他们有一个共同点，他们都是采用的单字节的编码方式。\nISO-8859-1维基百科\nGBK GBK的全称是汉字内码扩展规范。 其中 - GB是国标的首字母 - K 是扩展的首字母\nGBK的其他信息，我们不做太多说明，有兴趣的可以去维基百科查看\nGBK维基百科\nGBK的编码方式 GBK分为单字节和双字节编码，单字节编码兼容ASCII字符集。 这张图片是GBK的编码分区图。 - 首字节 0-128(不包括128)，都是单字节的编码区域 - 首字节 128-255，第二字节 0-64，这部分区域没有字符，如果出现在这个区域，会被解析为� - 首字节 128-255，第二字节 64-255，这部分主要是中文符号。\n根据上面的编码分区图，我们可以知道GBK是如何区分一个字节是是单字节编码，还是双字节编码的第一个字节，这个很重要，在下面乱码的解析中，我们会分析。 - 如果小于128，则表示是单字节编码 - 如果大于128，则表示是双字节编码\nUnicode 因为世界上的国家有很多，使用的语言和文字也大相径庭，每个国家都有自己使用的字符集和编码，所以有必要使用一个统一的字符集来解决字符集分裂的问题。Unicode就是为了解决这个问题而诞生的。\nUnicode中，是为每种语言都分配了一个区域，并且可以说是涵盖了世界上的所有的字符。  比如Unicode中的前128个字符和ASCII中的字符位置保持一致。 比如中文在Unicode的位置是 4E00-9FFF (19968-40959)  Unicode字符列表\nUnicode和UCS UCS是Universal Multiple-Octet Coded Character Set的简称\nUnicode和UCS的关系可以这么理解。 - 在历史中，有两个机构想要统一世界上的所有字符 - 国际标准化组织(ISO),设计出来的字符集就是UCS - 统一码联盟，设计出来的是Unicode - 后来，他们认识到，世界不需要两个不兼容的字符集，所以开始对这两个字符集进行合并。 - 从Unicode 2.0开始，Unicode采用了与UCS相同的字库和字码使两个字符集互相兼容。 - 但是各自依然保持独立。\nUCS维基百科 Unicode维基百科\nUTF字符编码 需要明白的是，Unicode只是一个符号集，它只规定了符号的序号。字符集中的符号序号涵盖了1个字节，2个字节，3个字节，4个字节。 - 比如汉字的序号范围是 4E00到9FFF，在两字节的范围内。\n那这里就有两个问题， - 第一个问题是，如何有3个字节计算机怎么知道这3个字节是表示一个符号，还是表示3个单字节符号呢？ - 第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用3个或4个字节表示，那么每个英文字母前都必然有2到3个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n为了解决这两个问题，就出现了基于Unicode字符集的字符编码，UTF(Unicode/UCS Transformation Format)。 UTF编码又可以分为 - UTF-8 - 最小可以用一个字节来表示字符，以单字节（8位）为单位对Unicode进行编码 - UTF-16 - 最小需要用2个字节来表示，以2个字节（16位）为单位对Unicode进行编码 - UTF-32 - 最小需要4个字节来表示。以4个字节（32位）为单位对Unicode进行编码\nUTF-8是使用最多的编码方式，下面我们会详细分析一下。 UTF-16和UTF-32我们使用较少，所以就不做分析了，有兴趣的同学可以自行了解一下。\n冷知识：Java的String中保存字符的value字段，使用的是UTF-16编码来存储的 Unicode转换格式维基百科 UTF-8维基百科 UTF-16维基百科 UTF-32维基百科\nUTF-8 UTF-8可以说是目前互联网中最常用的字符编码方式了。 截止到2019年11月， 在所有网页中，UTF-8编码应用率高达94.3%（其中一些仅是ASCII编码，因为它是UTF-8的子集），而在排名最高的1000个网页中占96％。\nUTF-8编码规则  若果Unicode值小于128，则字节的第一位为0，后面的7位为这个符号的Unicode码。比如字母 “A” 的Unicode值是 65。这个规则只试用于 ASCII中定义的字符。所以也解决了上面中的因为字符空间占用问题。使用UTF-8表示英文字符同样只需要1个字节。 对于Unicode值大于128的字符（所有的非ASCII中定于的字符）。假定表示该自己在Unicode中的值，需要n(n\u0026gt;=1)个字节，则使用UTF-8编码是，第一个字节的前n+1位都设置为1，第n+2位设置为0，后面字节的前2位都设置为10。剩下没有设置的二进制位，全部为这个符号的Unicode值。 所以UTF-8表示ASCII字符 需要一个字节。 表示其他的非ASCII 字符，主要用改字符在Unicode中的位置转成2进制所占用的字节数+1个 字节。 也就是说，如果这个字符在Unicde中的位置，需要1个字节来表示，那么UTF-8需要2个字节来表示这个字符，以此类推。  总结一下规则就是； 所以这里总结一个UTF-8的规则就是，用第一个字节的前N位 有几个连续的1来表示，这个字符占了几个字节，然后后面紧连着几个字节如果以10开头则表示，这个字节适合第一个字节一起表示一个字符\n 如果一个字节是0开头，则表示是一个单字节字符 如果是11开头，则表示是一个双字节字符 如果是111开头，则表示是一个3字节字符，  比如汉字中它的UTF-8编码是 1110 0100，10 111000，10 101101  如果是1111开头，则表示是一个4字节字符  UTF-8能够被广为使用的一个原因就是它兼容ASCII。 ASCII是UTF-8的一个子集。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。 因为在Unicode出现之前，ASCII就是使用最广的语言。\nUTF-8编码转换分析 我们还以汉字中为例,它的UTF-8编码是 11100100，10111000，10101101,我们下面来分析一下，如何计算出来的这个结果\n 我们先去网上查一下“中”对应的Unicode码：\\u4e2d 对应的10进制 是 20013，也就是表示中是Unicode中的第20013个字符。 对应的二进制是 ：100111000101101（15位）为了方便转在前面加一个0，转为16位 01001110，00101101。 表示“中”在Unicode中的值，需要2个字节，所以参照上面规则，UTF-8表示这个“中”需要2+1 = 3 个字节 按照上面的规则 n =2 ,所以第一个字节的前2+1位设置为1 ，第4位设置为0，后面2个字节的前两位 都设置为 10 得到1110  ****  , 10  ******  , 10  ******  剩下的位置填写 中的Unicode码的二进制 。剩下的位置共 4+6+6 = 16位，中的Unicode码的二进制也为16位，填入剩余的位置即可。 得到 1110 0100，10 111000，10 101101 。  代码中的乱码问题 乱码的出现 下面我们来聊一聊代码中经常遇到的乱码问题。 先说结论，乱码就是对字符编码(字符转成二进制)和解码(二进制转成字符)使用的编码不同。\n举例说明一下： 计算机A 给 计算机B发送消息,内容为 \u0026ldquo;中国\u0026rdquo;。 - 计算机A中使用的编码是UTF-8,中国这两个字对应的UTF-8编码是E4B8AD E59BBD,对应的二进制是111001001011100010101101111001011001101110111101 - 计算机B，使用的编码是GBK,它收到网络中的数据，按照GBK的编码方式去解码。 - 然后结果必然是和期望的结果不同,解码的结果是涓浗;\n上面的过程，我们可以用一段代码来表示 @Test public void testConvert(){ String str = \u0026#34;中国\u0026#34;; byte[] utfBytes =str.getBytes(Charset.forName(\u0026#34;UTF-8\u0026#34;)); String gbkStr = new String(utfBytes,Charset.forName(\u0026#34;GBK\u0026#34;)); System.out.println(gbkStr); } 下面我们来分析一下这个乱码是如何产生的。 - 计算机B收到的二进制数据是 11100100 10111000 10101101 11100101 10011011 10111101 - B是使用GBK编码进行解码，所以我们按照上面的解码规则来解析 - 首先看第一个字节，大于128，所以是一个双字节编码，则读取前两个字节11100100 10111000 - 转换为16进制是E4B8，在GBK中对应的符号是涓 - 然后看第3个字节，同样大于128，所以也是双字节，然后读取第3和第4的字节10101101 11100101 - 转换为16进制是ADE5,查询GBK码表，显示这个位置并没有字符，所以显示为，但是其实这里是有一个特殊的填充字符的。和找不到字符的情况还是有区别的。下面我们会分析。 - - 然后查询第5个字节，同样大于128，所以也是双字节，然后读取第5和第6的字节`10011011 10111101` - 转换为16进制是9BBD,查询GBK码表，对应的字符时`浗`。 从乱码变回正常字符 通过上面的分析，我们知道我们接受到的字节数据是没有问题的，只要我们使用正确的编码对字节进行解码，就可以了。 \u0026gt; 但是一般在开发过程中，框架都帮我们完成了解码的工作，比如Tomcat。就是说我们获得就已经是乱码了。\n所以说，如果我们能通过乱码，按照相同的编码方式来编码，就能拿到原始的字节数据，然后在使用正确的解码方式来解码，就能够得到正确的数据。\n我们同样用程序来模拟一下上面的过程。（代码中使用的是Hutool的HexUtil工具类）\n@Test public void testFixLuanma() throws UnsupportedEncodingException { //1.获得乱码的数据，因为有些字符(比如)没有办法在编辑器中显示出来，所以使用方法来代替  String gbkString = getGbkString(); System.out.println(\u0026#34;乱码字符:\u0026#34; + gbkString); //2.通过乱码获得原始的字节数据。  byte[] gbksBytes = gbkString.getBytes(\u0026#34;GBK\u0026#34;); //3. 通过正确的编码方式来解码  String utfString = new String(gbksBytes, \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34;正常的字符:\u0026#34; + utfString); } public String getGbkString() { String str = \u0026#34;中国\u0026#34;; byte[] utfBytes = str.getBytes(Charset.forName(\u0026#34;UTF-8\u0026#34;)); System.out.println(HexUtil.encodeHexStr(utfBytes)); String gbkStr = new String(utfBytes, Charset.forName(\u0026#34;GBK\u0026#34;)); return gbkStr; } 一般情况下，我们使用获得乱码的编码方式，再对乱码进行编码，就能获得原始的字节数据。然后在使用正确的编码方式来解码，就能获得正确的字符。\n例外情况 但是也有一种例外情况，如果你变成了乱码，然后在重新编码回来，是无法获得原始的字节数据的，也就没有办法再变成正确的字符了。\n下面还是举例来说明一下\n@Test public void testFixLuanma() throws UnsupportedEncodingException { //1.获得乱码的数据，因为有些字符(比如)没有办法在编辑器中显示出来，所以使用方法来代替  String gbkString = getGbkString(); System.out.println(\u0026#34;乱码字符:\u0026#34; + gbkString); //2.通过乱码获得原始的字节数据。  byte[] gbksBytes = gbkString.getBytes(\u0026#34;GBK\u0026#34;); System.out.println(\u0026#34;gbk编码字节\u0026#34;+HexUtil.encodeHexStr(gbksBytes)); //3. 通过正确的编码方式来解码  String utfString = new String(gbksBytes, \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34;正常的字符:\u0026#34; + utfString); } public String getGbkString() { String str = \u0026#34;干\u0026#34;; System.out.println(\u0026#34;原字符:\u0026#34; + str); byte[] utfBytes = str.getBytes(Charset.forName(\u0026#34;UTF-8\u0026#34;)); System.out.println(\u0026#34;utf8编码字节:\u0026#34;+HexUtil.encodeHexStr(utfBytes)); String gbkStr = new String(utfBytes, Charset.forName(\u0026#34;GBK\u0026#34;)); return gbkStr; } 我们发现，和上面一样的代码，对于不同的原字符，就出现了截然不同的结果。\n我们来分析一下原因。\n 首先我们使用UTF-8对原字符干编码，得到的结果是e5b9b2,转为二进制是11100101 10111001 10110010 使用GBK编码，对这段数据进行解码  首先读取第一个字节，大于128，认定是一个双字节字符，所以读取前两个字节11100101 10111001，对应的16进制是e5b9。 查询GBK码表，对应的字符是骞。 然后读取第三个字节，大于128，认定是一个双字节字符，但是这个只有一个字节，所以是有问题的，就被解析成�。  然后使用GBK编码对乱码重新编码，得到的字节数据是e5b93f 我们看到�,这个字符被编码成了3f。 使用UTF8编码对e5b93f解码，得到�?。  所以说，这里失败的原因是，当转换成GBK编码的时候，因为字节数为3个，所以最后1个字节被认为是错误的编码，被转成了通用错误字符�,导致再转成UTF-8的时候，无法还原成原始的字节数据。\n总结一下  GBK编码图中有一部分非法编码区，落在这个编码区的字符，或者不符合GBK编码规则的字符(比如大于128，但是只有一个字节)，会被解析成�。那么就会造成数据丢失，就无法转换成正确的数据了。 如果原始字节数据，是偶数字节，那么有很大可能都能被GBK正确解码，那么还是能够通过GBK编码获得原始数据的，那就能够重新获得正确的字符 有一种比较常见的情况是，发送方使用UTF-8格式的编码，接收方默认使用ISO-8859-1(Tomcat在不指定解码的时候，默认就是)。因为ISO-8859-1是单字节编码，所以虽然会是转换成乱码，但是每个字节都会有对应的字符，所以当再次使用ISO-8859-1编码，就不回发生数据丢失的情况，会原原本本的得到原始的字节数据，在按照UTF-8解码就可以了。 所以说如果一段字节数据，在使用某种编码解码A时，出现了不在该编码类型A的编码区中的数据。那么再次使用编码类型A编码时，就会出现数据丢失，导致无法还原会正确的字符。  GBK偶数字节乱码修复测试  我们看到原始字符是干哈哈哈，4个字符，使用UTF-8编码16进制是e5b9b2e59388e59388e59388，一共12字节。 使用GBK解码，正好2个自己对应一个字符，得到6个字符。 虽然文字看起来像乱码。 但是每个字节都有用到，没有发生数据丢失，这样我们再次使用gbk编码之后，就能重新得到e5b9b2e59388e59388e59388，原始字节数据。 然后再次使用UTF-8解码就得到原始字符干哈哈哈了。  ISO-8859-1乱码修复测试  这次测试的原始字符换成了干哈哈，UTF-8编码后16进制是e5b9b2e59388e59388 9个字节。 使用ISO-8859-1解码，得到了乱码，我们选中得到的字符，看到其实是9个字符 所以每个每个字节都对应了1个字符，没有数据丢失。 再使用ISO-8859-1对乱码编码，就重新得到了e5b9b2e59388e59388原始字节数据。 然后再次使用UTF-8解码就得到原始字符干哈哈了。  ","permalink":"https://balvboy.github.io/blog/%E7%BC%96%E7%A0%81%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/","summary":"字符编码 字符编码是我们在开发过程中无法逃避的问题，经常遇到各种各样的乱码。通常我们会在几个地方设置一下字符编码方式，然后乱码解决了，然后就会把字符编码放到一边，很少有机会或者会想到去专门系统的了解一下字符编码知识。\n我之前也写过一些编码的文章，但是回过头在去看的时候，发现这也不对，那也不对，主要就是因为当时了解的比较片面。这次希望能够把常见的几种编码，和在编程中常见的编码问题搞清楚。\n字符编码和字符集  字符集 字符集的意思就是所有字符的集合，并且每一个字符都有一个唯一的编号。 字符编码 字符编码就是把字符集内字符的编号转换成二进制数据的一种规则。  所以说字符集和字符编码并不是一个东西，字符编码需要依赖于字符集。但是大多数字符编码的名称就是它对应字符集的名称，比如 - ASCII字符集和ASCII字符编码 - GBK字符集和GBK字符编码\n但是有一个例外就是基于Unicode字符集的UTF系列的字符编码，这个我们后面会重点说。 下面简单介绍几个我们比较熟悉的字符集，不会详细讨论设计细节，如果大家有需要可以去查看字符集的维基百科。后面后给出链接。\nASCII ASCII可以认为是最早的字符集，它定义了128个字符，其中包括32个不可见字符(比如一些控制字符 换行，回车等)，还有96个可见字符(大写小写字母，标点符号等)。 ASCII的字符编码也比较简单，就是用二进制来表示字符的序号，因为它一共只有128个，所以只需要用到一个字节的后7位。\nASCII维基百科\nISO 8859-1 ISO 8859-1 这个也是我们很熟悉的字符集，这个字符集是以ASCII为基础，并扩充了一些拉丁字母，也被叫做Latin-1字符集。 因为拉丁国家众多，有很多国家都对这个字符集进行了修改或者扩充。 虽然有这么多的字符集，但是他们有一个共同点，他们都是采用的单字节的编码方式。\nISO-8859-1维基百科\nGBK GBK的全称是汉字内码扩展规范。 其中 - GB是国标的首字母 - K 是扩展的首字母\nGBK的其他信息，我们不做太多说明，有兴趣的可以去维基百科查看\nGBK维基百科\nGBK的编码方式 GBK分为单字节和双字节编码，单字节编码兼容ASCII字符集。 这张图片是GBK的编码分区图。 - 首字节 0-128(不包括128)，都是单字节的编码区域 - 首字节 128-255，第二字节 0-64，这部分区域没有字符，如果出现在这个区域，会被解析为� - 首字节 128-255，第二字节 64-255，这部分主要是中文符号。\n根据上面的编码分区图，我们可以知道GBK是如何区分一个字节是是单字节编码，还是双字节编码的第一个字节，这个很重要，在下面乱码的解析中，我们会分析。 - 如果小于128，则表示是单字节编码 - 如果大于128，则表示是双字节编码\nUnicode 因为世界上的国家有很多，使用的语言和文字也大相径庭，每个国家都有自己使用的字符集和编码，所以有必要使用一个统一的字符集来解决字符集分裂的问题。Unicode就是为了解决这个问题而诞生的。\nUnicode中，是为每种语言都分配了一个区域，并且可以说是涵盖了世界上的所有的字符。  比如Unicode中的前128个字符和ASCII中的字符位置保持一致。 比如中文在Unicode的位置是 4E00-9FFF (19968-40959)  Unicode字符列表","title":"字符集和字符编码 "},{"content":"一、cron介绍  crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语chronos(χρόνος)，原意是时间。 通常，crontab储存的指令被守护进程激活，crond常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。\n 我理解cron是一个表达式，用来表示一个任务的周期性执行时间。\n二、cron格式 2.1、完整格式 ┌─秒(0-59) | ┌─分鐘(0-59) | │ ┌─小時(0-23) | | │ ┌─日 day of month(1-31) | | | | ┌─月(1-12) | | | | | ┌─星期 day of week(0-7，0和7都表示星期日) | | | | | | ┌─年(可以省略不写) * * * * * * * 开始的时候我把cron的格式分为了两种，分别是Linux crontab中的格式和Java中使用的格式。后面想了想，觉得cron的格式应该只有一种，就是上面的这种包含 7个字段的格式。然后不同的cron实现对于cron格式的实现程度不同。\n比如Linux的crontab，它只能支持5个字段，不能支持秒和年\n2.2、crontab格式 ┌─分鐘（0 - 59） │ ┌─小時（0 - 23） | │ ┌─日 day of month(1-31) | | | ┌─月（1 - 12） | | | | ┌─星期 day of week(0-7，0和7都表示星期日) * * * * *  linux-crontab-校验\n2.3、cron格式总结 因为在网上一直没有找到准确的官方的cron的定义，所以上面的都是我自己的理解。我认为cron这种很通用的表达式，它的定义应该不会太分裂\n三、day of week中数字的定义 在查看文档和测试的过程中发现，同样的一个表达式，会得出不同的执行结果，后来发现是因为对于day-of-week的定义大致分为两种\n3.1、crontab中的定义 在类Unix的系统中的crontab命令中，数字0和7都代表周日,然后1-6分别表示MON-SAT(周一到周六)；\n这里0和7都表示周日，是有一定的历史原因的，是为了兼容之前不同版本的Unix系统。\n This is a matter of portability. In early Unices, some versions of cron accepted 0 as Sunday, and some accepted 7 as Sunday \u0026ndash; this format is an attempt to be portable with both.\n Day of week {0-7} in crontab has 8 options, but we have only 7 days in a week\n3.2、Java中的定义 在Java的不同实现中,我找到了2个，分别是Spring的实现和Quartz的实现\n Spring的CronSequenceGenerator和Linux保持一致；顺便说一下这个类是Spring中@Scheduled注解的默认cron解析类\n Quartz的CronExpression的实现CronExpression和Linux不同，它不支持0，然后1-7分别是SUN-SAT(周日-周六)\n  3.3、解决办法 鉴于不同的实现中，对于day of week数字的定义的区别，最好的办法就是使用星期的简写来代替数字，例如SUN,MON,TUE等等，这样就能保证你的cron不管在哪个Java的cron实现中都能正确运行。\n四、cron每个字段支持的输入 | Field Name | Allowed Values | Allowed Special Characters| |\u0026ndash;|\u0026ndash;|\u0026ndash;| |Seconds | 0-59 | , - * /| |Minutes | 0-59 | , - * /| |Hours | 0-23 | , - * / | |Day-of-month | 1-31 | , - * ? / L W| |Month | 1-12 or JAN-DEC | , - * /| |Day-of-Week | 0-7 or SUN,MON,TUE,WED,THU,FRI,SAT| , - * ? / L #| |Year (Optional)| empty, 1970-2199|, - * /|\n五、cron特殊字符说明 这里先说一下我的理解，对于cron中的特殊字符，应该是有一套比较统一的规则定义，只不过在在不同的cron的实现里，有的只选择实现了一部分的规则。\n就像Linux中的crontab命令，只实现了下面的几种基本特殊字符。\nJava的实现中，Quartz算是实现的功能比较全的，基本上完全实现了所有的特殊字符的功能。\n所以在我们写cron表达式的时候，一定要清楚，我们的表示是会用在什么地方，支持什么样的写法，像我工作中比较常用的就是在Spring中@Scheduled注解，和elastic-job创建定时任务（cron解析使用Quartz）\n5.1、基本特殊字符    字符 描述 举例 解释     , 表示几个会生效的值 1,2,3 in Minutes 表示在第1和第2和第3分钟 都会生效   - 表示生效的范围 1-10 in Minutes 表示在第1到第10分钟会生效   * 表示所有的值都会生效， * in Minutes 表示每分钟都会生效   / 表示增量，可以理解为每隔多长时间 0/30 in Minutes 表示第0分钟生效，然后每隔30分钟生效一次    5.2、? 字符说明  The \u0026lsquo;?\u0026rsquo; character is allowed for the day-of-month and day-of-week fields. It is used to specify \u0026lsquo;no specific value\u0026rsquo;. This is useful when you need to specify something in one of the two fields, but not the other.\n?号只能用在day-of-month和day-of-week字段中。通常用来表示为\u0026rsquo;没有指定的值\u0026rsquo;。当你需要在两个字段之一中指定某些内容而不是另一个字段时，这非常有用。\n 我们使用cron的初衷是想让这个任务定期的执行，比如每个月1日执行什么，或者每周1执行什么。当一个任务在每个月1日，执行的时候，我们通常不会要求它是星期几，同样每周1执行的任务，我们也不会关心当天是几月几号。也就是说，在极大多数的情况下，我们不需要这两个字段同时满足。\n所以说，通常情况下，我们在指定了这两个其中一个字段之后，会把另一个字段设置为'?'。\n或许有人说，我就要每个月1号、并且还必须得是星期一的0点0分0秒，它才能执行，当然我们也能实现(这种同时制定month和week的表达式，不是所有的都支持,比如Quartz就不支持week和month同时设置)\n0 0 0 1 * 1 接下来7次的执行时间 -------------------------- 2020-06-01 00:00:00 2021-02-01 00:00:00 2021-03-01 00:00:00 2021-11-01 00:00:00 2022-08-01 00:00:00 2023-05-01 00:00:00 2024-01-01 00:00:00 spring-cron-online\n那这个时间真的是你想要的吗？\n5.3、L 字符说明 L其实是LAST的简写，就是最后的意思，它可以用在 day-of-month和day-of-week字段中。 它在两个字段中的意思有一些不同\n day-of-month：直接使用L表示这个月的最后一天，如果是1月那就是31号，如果是平年的2月，那就是28号 day-of-month: 使用 L-3,表示这个月的倒数第3天 day-of-week：如果直接使用L,则表示星期六（是从周日开始的，所以周六是最后一天） day-of-week: MONL(为了避免数字造成的混淆直接使用字母)，表示这个月的最后一个周一  5.4、W 字符说明 W在这里代表的是WeekDay(工作日的意思)，它只能使用在day-of-month字段中。 在表达式的使用中，它的作用是指定在同一个月内，离指定日期最近的工作日。\n举例1\n0 0 0 15W * ? 这个表达式字面意思是，在离每个月15号最近的工作日的 0点0分0秒触发 1. 如果15号是 周一到周五中的某一天，那么就在当天触发 2. 如果15号是 周六，那么离周六最近的工作日就是周五(前一天)，那么就会在周五触发； 3. 如果15号是 周日，那么离周日最近的工作日是周一(后一天)，那么就是在周一触发； 这个有一个大前提就是，必须是同一个月内的。通过下面的例子来说明一下\n举例2\n0 0 0 1W * ? 这个表达式字面意思是，在离每个月1号最近的工作日的 0点0分0秒触发 1. 如果1号是 周一到周五中的某一天，那么就在当天触发（这个没问题） 2. 如果1号是 周日，那么离周日最近的工作日是周一(后一天)，那么就是在周一触发； 3. 如果1号是 周六，关键在这里，距离周六最近的工作日是周五(前一天，1号的前一天已经是上个月了)，但是因为大前提是必须是同一个月的，所以只能在后两天的周一触发 5.5、# 字符说明  The \u0026lsquo;#\u0026rsquo; character is allowed for the day-of-week field. This character is used to specify \u0026ldquo;the nth\u0026rdquo; XXX day of the month.\nIf the \u0026lsquo;#\u0026rsquo; character is used, there can only be one expression in the day-of-week field (\u0026ldquo;3#1,6#3\u0026rdquo; is not valid, since there are two expressions).\n # 号只能用在 day-of-week字段中，表示某个月的第几个星期几; 同时说明一下 #前面的是表示星期几，#后面的数字表示第几，还有如果day-of-week使用了#。\n如果day-of-week字段中出现了#,那么day-of-week中就只能有且只有这一种表达式。\n举例\n0 0 0 ? * MON#2 每个月的第二个星期一 0点0分0秒 六、常见cron 每个月的工作日上午9点0分0秒\n0 0 9 ? * MON-FRI 每个月的最后一个周一上午9点0分0秒\n0 0 9 ? * MONL 每个月的最后一个工作日上午9点0分0秒\n0 0 9 LW * ? 这里需要注意的就是 W必须要写在后面 在工作日每隔10分钟执行一次\n0 */10 * ? * MON-FRI 六、参考文章 Quartz-CronExpression\nquartz-cron-校验\nlinux-man-crontab\nlinux-easycron\ncron-wiki\n","permalink":"https://balvboy.github.io/blog/cron/","summary":"\u003ch1 id=\"一-cron介绍\"\u003e一、cron介绍\u003c/h1\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003ecrontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语chronos(χρόνος)，原意是时间。\n通常，crontab储存的指令被守护进程激活，crond常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"cron表达式 "},{"content":" 微信公众号 ","permalink":"https://balvboy.github.io/wechat/","summary":" 微信公众号 ","title":""},{"content":"","permalink":"https://balvboy.github.io/search/","summary":"search","title":"Search"}]